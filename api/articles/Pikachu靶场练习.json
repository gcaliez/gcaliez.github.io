{"title":"Pikachu靶场攻略（持续更新中）","uid":"5a29724b6f0247fd1b534cffc1124eba","slug":"Pikachu靶场练习","date":"2025-11-02T02:00:00.000Z","updated":"2025-11-02T02:23:38.343Z","comments":true,"path":"api/articles/Pikachu靶场练习.json","keywords":null,"cover":"/images/g.jpg","content":"<h1>Pikachu漏洞平台练习</h1>\n<h2 id=\"一、暴力破解\">一、暴力破解</h2>\n<h3 id=\"概述\">概述</h3>\n<ul>\n<li>\n<p>“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。</p>\n</li>\n<li>\n<p>理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：</p>\n</li>\n<li>\n<p>1.是否要求用户设置复杂的密码；<br>\n2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；<br>\n3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；<br>\n4.是否采用了双因素认证；<br>\n…等等</p>\n</li>\n</ul>\n<h3 id=\"暴力破解漏洞测试流程\">暴力破解漏洞测试流程</h3>\n<h4 id=\"1-确认目标登录接口的脆弱性\">1.确认目标登录接口的脆弱性</h4>\n<ul>\n<li>确认目标是否存在暴力破解的漏洞。（确认被暴力破解的“可能性”）</li>\n<li>比如：尝试登录-抓包-观察验证元素和response信息，判断是否存在暴力破解的可能</li>\n</ul>\n<h4 id=\"2-对字典进行优化\">2.对字典进行优化</h4>\n<ul>\n<li>根据实际的情况对字典进行优化，提高爆破过程的效率</li>\n</ul>\n<h4 id=\"3-工具自动化操作\">3.工具自动化操作</h4>\n<ul>\n<li>配置自动化工具（比如线程，超时时间，重试次数等），进行自动化的操作</li>\n</ul>\n<h4 id=\"4-字典优化技巧\">4.字典优化技巧</h4>\n<ul>\n<li><strong>技巧一</strong>：\n<ul>\n<li>根据注册提示信息进行优化对目标站点进行注册，搞清楚账号密码的一些限制，比如目标站点要求密码必须是6位以上，字母数字组合，则可以按照此优化字典，比如去掉不符合要求的密码。</li>\n</ul>\n</li>\n<li><strong>技巧二</strong>：\n<ul>\n<li>如果爆破的是管理后台，往往这种系统的管理员是admin/administrator/root的机率比较高，可以使用这三个账号+随便一个密码，尝试登录，观看返回的结果，确定用户名。</li>\n<li>比如：<br>\n输入xxx/yyyf返回“用户名或密码错误”；<br>\n输入admin/yyy返回“密码错误&quot;，则基本可以确定用户名是admin;<br>\n因此可以只对密码进行爆破即可，提高效率。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-基于表单的暴力破解\">1.基于表单的暴力破解</h3>\n<ul>\n<li>\n<p>基于表单的暴力破解，其实说白了就是没有任何验证码和防护措施的，最为简单的暴力破解</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828132053367.png\" alt=\"image-20250828132053367\"></p>\n</li>\n<li>\n<p>这里我们要利用的是<code>burpsuit</code>这款工具，这个工具在学习安全的道路上会经常使用，小白可以通过b站搜索相关内容进行下载安装</p>\n</li>\n<li>\n<p>要使用这款工具，我们需要导入证书和开启127.0.0.1:8080代理（当然用bp自带的浏览器也是可以的），详细步骤可以参考下这篇文章[Burp Suite CA证书下载及导入教程](<a href=\"https://blog.csdn.net/qq_46700234/article/details/122333508\">Burp Suite CA证书下载及导入教程_burp证书下载-CSDN博客</a>)</p>\n</li>\n<li>\n<p>当一切准备就绪，我们就可以利用bp抓到浏览器的数据包了！（这里插一嘴，如果你的证书和代理都整好了的话还是抓不了本地的包，可以将127.0.0.1或者localhost换成你本地的ipv4地址，win + r 输入cmd，在命令行里面输入ipconfig，找到自己的ipv4地址）</p>\n</li>\n<li>\n<p>首先我们点击<code>Intercept is off</code>这个按钮，将所有的通过这个端口的数据包拦截下来</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828134123789.png\" alt=\"image-20250828134123789\"></p>\n</li>\n<li>\n<p>然后随便输账号和密码，点击登录</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828151711677.png\" alt=\"image-20250828151711677\"></p>\n</li>\n<li>\n<p>可以看到这时已经成功抓到了，接下来我们要将这个登录的这个数据包放到我们的爆破模块，这也是我们抓包的目的</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828152012358.png\" alt=\"image-20250828152012358\"></p>\n</li>\n<li>\n<p>进入到爆破模块后，我们选择一下其中的<code>Cluster bomb</code>的模式，这个相当于将你的字典的所有组合全部进行爆破，也是爆破最常用的模式，详细区别可以看下这篇文章[Burp Suite爆破模块中的四种模式的区别详解和演示(暴力破解)](<a href=\"https://blog.csdn.net/qq_45705626/article/details/127709037\">Burp Suite爆破模块中的四种模式的区别详解和演示(暴力破解)_bpcluster bomb-CSDN博客</a>)</p>\n</li>\n<li>\n<p>选择之后，先按下右边的<code>clear</code>按钮，将自带参数清除，然后选中我们输入的账号和密码，进行<code>add</code></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828153448979.png\" alt=\"image-20250828153448979\"></p>\n</li>\n<li>\n<p>接着，我们点击<code>payloads</code>选项，添加我们要爆破的字典，因为pikachu右上角的提示给了我们正确的密码，这里我们将正确和错误的账号、密码混在一起当做我们的字典，在payload1和2里面分别添加</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828160534553.png\" alt=\"image-20250828160534553\"></p>\n</li>\n<li>\n<p>添加完成后点击右上角的<code>Start attack</code>，开始爆破</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828160800937.png\" alt=\"image-20250828160800937\"></p>\n</li>\n<li>\n<p>爆破成功后，我们不需要一个一个看返回的内容，可以点击<code>length</code>查看长度来进行判断，这里很明显第一行的长度与其他的都不一样，尝试后发现可以成功登录，那么恭喜你最简单的爆破流程你已经学会了。</p>\n</li>\n</ul>\n<h3 id=\"2-验证码绕过-on-server\">2.验证码绕过(on server)</h3>\n<ul>\n<li>\n<p>来到这一关，我们会发现多了一个验证码，当我们尝试输入错的账号密码还有验证码时告诉我们，验证码错误</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828161824925.png\" alt=\"image-20250828161824925\"></p>\n</li>\n<li>\n<p>而当我们输入正确的验证码和错误的账号密码时，则会提示 username or password is not exists～</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828162003010.png\" alt=\"image-20250828162003010\"></p>\n</li>\n<li>\n<p>当我们进行这两次尝试可以发现，只有当页面刷新的时候，验证码才会重新刷新，那我们不刷新页面同一个正确的验证码是否会有效呢，我们这里输入一个正确的验证码和错误的密码抓个包试验一下，并将抓到的包放到<code>Reteater（重放模块）</code>中</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828162644719.png\" alt=\"image-20250828162644719\"></p>\n</li>\n<li>\n<p>修改一下原来的账号和密码，重新发送几次</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828163132504.png\" alt=\"image-20250828163132504\"></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828163210592.png\" alt=\"image-20250828163210592\"></p>\n</li>\n<li>\n<p>这里可以基本确认他的验证码只要不刷新就是有效的，那么抓包放到爆破模块的时候保证验证码是页面上正确的就行，其他操作和上面没有变化</p>\n</li>\n</ul>\n<h3 id=\"3-验证码绕过-on-client\">3.验证码绕过(on client)</h3>\n<ul>\n<li>\n<p>来到第三关，我们依旧先输入错误的账号和验证码进行尝试，而当我们验证码错误的时候，他会出现一个弹窗，提示我们验证码输入错误</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828163642398.png\" alt=\"image-20250828163642398\"></p>\n</li>\n<li>\n<p>但我们点击确认的时候，发现页面并没有任何加载的迹象，但验证码刷新了，由此可以判断，这个验证码的验证实在前端页面上进行的，那么这一关就很简单了，对于懂安全的来说，任何在前端进行的验证，都是没有任何意义的，我们只需要先按<code>f12</code>再按<code>f1</code>，将<code>javascript</code>禁用就可以了</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828164129191.png\" alt=\"image-20250828164129191\"></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828164155506.png\" alt=\"image-20250828164155506\"></p>\n</li>\n<li>\n<p>这里可以看到，验证码已经没有显示了，剩下的还是按照第一关的步骤进行爆破就可以了</p>\n</li>\n</ul>\n<h3 id=\"4-token防爆破\">4.token防爆破</h3>\n<ul>\n<li>\n<p>在做这关之前，推荐大家可以先去了解一下什么是<code>token</code>，详细可以看这篇文章<a href=\"%5B%E4%BB%80%E4%B9%88%E6%98%AFtoken%EF%BC%9Ftoken%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F_token%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/sunyctf/article/details/126509232#:~:text=%E7%9B%B8%E4%BF%A1%E5%BE%88%E5%A4%9A%E4%BB%8E%E4%BA%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%9C%8B%E5%8F%8B%E9%83%BD%E5%90%AC%E8%AF%B4%E8%BF%87token%E8%BF%99%E4%B9%88%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E4%BB%96%E8%A1%8C%E4%B8%9A%E7%9A%84%E4%BA%BA%E5%B0%B1%E5%BE%88%E5%B0%91%E4%BA%86%E8%A7%A3%E5%88%B0token%EF%BC%8C%E4%B8%8B%E9%9D%A2%E5%B0%B1%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%9D%A5%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Btoken%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9Ftoken%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%E8%BF%99%E4%B8%80%E5%9D%97%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%B8%8C%E6%9C%9B%E8%83%BD%E5%B8%AE%E5%8A%A9%E5%88%B0%E5%A4%A7%E5%AE%B6%E3%80%82)\">什么是token？token是用来干嘛的？</a>，总的来说<code>token</code>就相当于给每个请求发一个独一无二的编号，用它来进行验证</p>\n</li>\n<li>\n<p>我们这里先<code>f12</code>进行查看</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828202748729.png\" alt=\"image-20250828202748729\"></p>\n</li>\n<li>\n<p>在登录按钮的上面可以看到题目的<code>token</code>，在有<code>token</code>的干扰下，我们的爆破流程要稍加改变，因为即使有<code>token</code>连发两个也会报错，但由于<code>token</code>的值回显在前端页面上，我们就可以配置一个正则重定向，让BP每次爆破的时候自动爬取这个<code>token</code>值</p>\n</li>\n<li>\n<p>还是先随便输入密码，进行登录抓包，并发送到爆破模块，这里我们选择的攻击模式是<code>Pitchfork</code>，他的功能就是多个字典同时进行</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828203715252-1756385190263-1.png\" alt=\"image-20250828203715252\"></p>\n</li>\n<li>\n<p>接着我们点击<code>Setings</code>，在下面找到<code>Gerp-Extract</code>，然后依次点击这两个按钮</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828204521538.png\" alt=\"image-20250828204521538\"></p>\n</li>\n<li>\n<p>在下面搜索<code>token</code>，找到那个<code>token</code>值，选中复制，然后点击ok</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828204914788.png\" alt=\"image-20250828204914788\"></p>\n</li>\n<li>\n<p>然后回到<code>payloads</code>选项，前两个账号密码添加的方式不变，第三个<code>token</code>的时候，选择<code>Recursive grep（递归搜索）</code>，将我们刚才复制的<code>token</code>值粘贴到下面</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828205440466.png\" alt=\"image-20250828205440466\"></p>\n</li>\n<li>\n<p>接着来到<code>resource pool</code>模块，选择创建新的资源池，并把最大请求数改为1</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828205658793.png\" alt=\"image-20250828205658793\"></p>\n</li>\n<li>\n<p>然后开始攻击即可</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828205900283.png\" alt=\"image-20250828205900283\"></p>\n</li>\n<li>\n<p>最后爆破成功！</p>\n</li>\n</ul>\n<h2 id=\"二、XSS（跨站脚本攻击）\">二、XSS（跨站脚本攻击）</h2>\n<h3 id=\"概述-2\">概述</h3>\n<ul>\n<li>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写&quot;CSS&quot;冲突，故又称XSS。一般XSS可以分为如下几种常见类型：\n<ul>\n<li>反射型 XSS</li>\n<li>存储型 XSS</li>\n<li>DOM型 XSS</li>\n</ul>\n</li>\n<li>XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。</li>\n<li>XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。</li>\n<li>形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。</li>\n<li>因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:\n<ul>\n<li>输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;</li>\n<li>输出转义：根据输出点的位置对输出到前端的内容进行适当转义;</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-反射型-XSS-（get）\">1.反射型 XSS （get）</h3>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906164701762.png\" alt=\"image-20250906164701762\"></p>\n<ul>\n<li>\n<p>打开题目，问我们我们最喜欢的 NBA 球星，这里我们随便输入一个</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906164847521.png\" alt=\"image-20250906164847521\"></p>\n</li>\n<li>\n<p>通过观察我们发现，我们输入的球星名字会在前端页面显示出来，那么这里就可能存在<code>XSS</code>漏洞</p>\n</li>\n<li>\n<p>由于他是通过<code>GET</code>请求来进行传参的，那我们尝试构造前端语言的<code>payload</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"><span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>但当我们输入到 (‘xss’) 的时候发现超过了长度限制</p>\n</li>\n<li>\n<p>那么我们<code>f12</code>，选中这个输入框，将最大长度改成100</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906170108326.png\" alt=\"image-20250906170108326\"></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906170201873.png\" alt=\"image-20250906170201873\"></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906170219625.png\" alt=\"image-20250906170219625\"></p>\n</li>\n</ul>\n<h3 id=\"2-反射型-XSS-（post）\">2.反射型 XSS （post）</h3>\n<ul>\n<li>打开题目，发现是一个登录页面，我们点一下提示，先进行账号登录（也可以利用上面学到的知识，进行暴力破解）</li>\n<li>登录完事后，发现和上一题没什么太大的区别，输入喜欢的球星后，依旧会在前端界面显示，只不过这里使用<code>post</code>进行传参，那我们的操作不变，最后成功造成<code>反射型xss</code></li>\n<li>payload：<code>&lt;script&gt;alert('xss')&lt;/script&gt;</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里简单讲述下get请求和post的区别</span><br><span class=\"line\"></span><br><span class=\"line\">GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们在数据传输方式、安全性、数据量限制等方面存在显著差异。</span><br><span class=\"line\"></span><br><span class=\"line\">数据传输方式 GET 请求通过 URL 传递参数，参数以 key=value 的形式附加在 URL 后，用 ? 分隔，多个参数用 &amp; 连接。例如：/test?name=John&amp;age=30。 POST 请求则将参数放在 HTTP 请求的消息体中，用户无法直接看到这些数据。</span><br><span class=\"line\"></span><br><span class=\"line\">安全性 GET 请求的参数会显示在 URL 中，因此容易被记录在浏览器历史、服务器日志中，安全性较低，尤其不适合传输敏感信息如密码。 POST 请求的参数不会显示在 URL 中，安全性相对较高，适合传输敏感数据。</span><br><span class=\"line\"></span><br><span class=\"line\">数据量限制 GET 请求受 URL 长度限制（通常为 2048 个字符），因此传输数据量较小。 POST 请求没有明确的数据长度限制，可以传输大量数据，适合文件上传等场景。</span><br><span class=\"line\"></span><br><span class=\"line\">缓存和历史记录 GET 请求可以被缓存，参数会保留在浏览器历史记录中，适合用于获取数据。 POST 请求不会被缓存，参数也不会保留在历史记录中。</span><br><span class=\"line\"></span><br><span class=\"line\">编码类型 GET 请求只支持 ASCII 字符，传输非 ASCII 数据时需要编码。 POST 请求支持多种编码方式，包括 application/x-www-form-urlencoded 和 multipart/form-data，后者适用于二进制数据。</span><br><span class=\"line\"></span><br><span class=\"line\">性能和效率 GET 请求通常只需要一个 TCP 数据包即可完成，效率较高。 POST 请求可能需要两个 TCP 数据包：第一个发送请求头，第二个发送请求体，因此性能稍逊。</span><br><span class=\"line\"></span><br><span class=\"line\">使用场景 GET 适用于获取数据，例如查询操作。 POST 适用于提交数据，例如表单提交或文件上传。</span><br><span class=\"line\"></span><br><span class=\"line\">总结来说，GET 和 POST 的选择应根据具体需求决定。GET 更适合无状态、无敏感数据的请求，而 POST 则适合需要更高安全性和传输大量数据的场景。</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-存储型-XSS\">3.存储型 XSS</h3>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906173623108.png\" alt=\"image-20250906173623108\"></p>\n<ul>\n<li>\n<p>存储型<code>XSS</code>是持久化的<code>XSS</code>攻击方式，它<strong>将恶意代码存储于服务器端</strong>，比如数据库、留言页面、日志文件等，当其他用户访问该页面时就会触发代码，造成<code>xss</code>攻击</p>\n</li>\n<li>\n<p>这个漏洞的危害就比较大了，因为它是插入到一个正常页面的，你只需要浏览就能够触发</p>\n</li>\n<li>\n<p>那么我们来看这道题，他给了我们一个留言板，说明我们写进去的内容会被存储起来并进行显示，这里很就有可能出现存储型的<code>xss</code>，实战中也可以多留意一下留言板相关的功能</p>\n</li>\n<li>\n<p>payload：<code>&lt;script&gt;alert('xss')&lt;/script&gt;</code></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906175040688.png\" alt=\"image-20250906175040688\"></p>\n</li>\n<li>\n<p>当我们每次刷新界面进行访问的时候都会触发 xss，这就是存储型 xss 的影响</p>\n</li>\n</ul>\n<h3 id=\"4-DOM型-XSS\">4.DOM型 XSS</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里简单介绍下什么是DOM</span><br><span class=\"line\">DOM 是一种用于表示和操作HTML、XML等文档结构的编程接口，通过它可以使用代码来访问、修改和操作Web页面的内容和结构。</span><br><span class=\"line\">与反射型和存储型XSS不同，DOM型XSS不需要将恶意脚本传输到服务器，而是直接在客户端执行，因此更难检测和防御。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>详细可见：[DOM-XSS攻击原理](<a href=\"https://www.cnblogs.com/mysticbinary/p/12542695.html\">DOM-XSS攻击原理与防御 - Mysticbinary - 博客园</a>)</li>\n</ul>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910195631471.png\" alt=\"image-20250910195631471\"></p>\n<ul>\n<li>\n<p>打开题目，我们随便输入一些内容，然后<code>f12</code>检查一下，我们刚才输入的内容</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910200919603.png\" alt=\"image-20250910200919603\"></p>\n</li>\n<li>\n<p>这里我们需要将语句闭合并进行payload的构造，可以看到他这里用的是<code>a</code>标签，各种标签和绕过方法可以看这篇文章： [xss过滤绕过总结](<a href=\"https://www.cnblogs.com/sfsec/p/15178028.html\">XSS过滤绕过总结 - 随风kali - 博客园</a>)</p>\n</li>\n<li>\n<p>但这里双引号闭合却没有成功，我们打开源代码发现，外面其实还有一个单引号</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910201814755.png\" alt=\"image-20250910201814755\"></p>\n</li>\n<li>\n<p>那么我们最后的payload为：<code>' onclick=alert('xss')&gt;</code></p>\n</li>\n<li>\n<p>闭合后的完整语句为：<code>&lt;a href='' onclick=alert(‘xss’)&gt;'&gt;what do you see?&lt;/a&gt;</code></p>\n</li>\n</ul>\n<h3 id=\"5-DOM型-XSS-X\">5.DOM型 XSS-X</h3>\n<ul>\n<li>这一关和上一关的<code>payload</code>没什么区别，唯一的区别就是他是get请求从url获取我们提交的内容</li>\n<li>这里就不过多解释了</li>\n</ul>\n<h3 id=\"6-XSS-盲打\">6.XSS 盲打</h3>\n<ul>\n<li>\n<p>XSS 盲打（Blind Cross-Site Scripting）是跨站脚本攻击的一种高级形式，其核心特点是<strong>攻击者无法直接观察攻击效果</strong>，需依赖特定用户（如管理员）在未来某个时间点触发存储在服务器上的恶意代码。</p>\n</li>\n<li>\n<p>XSS 盲打属于<strong>存储型 XSS 的变种</strong>，但攻击流程存在显著差异。攻击者将恶意脚本注入到网站的输入点（如留言板、用户资料编辑框），脚本被存储在服务器数据库中，<strong>不会立即在当前用户浏览器执行</strong>。当管理员或其他用户访问包含该脚本的页面时，浏览器会自动解析并执行脚本，导致攻击生效。</p>\n</li>\n<li>\n<p>其实简单来说也可以叫黑盒测试</p>\n</li>\n<li>\n<p>我们回到题目，首先我们构造一个 xss 的 payload，检查后发现看不到代码，无法判断成功与否</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>我们点开提示，他告诉了我们后台的地址，我们访问一下</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910213833347.png\" alt=\"image-20250910213833347\"></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910213911579.png\" alt=\"image-20250910213911579\"></p>\n</li>\n<li>\n<p>成功弹窗，我们检查一下，发现语句确实写进去了</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910214008006.png\" alt=\"image-20250910214008006\"></p>\n</li>\n</ul>\n<h3 id=\"7-XSS之过滤\">7.XSS之过滤</h3>\n<ul>\n<li>\n<p>根据我们的题目，我们可以得知他应该是对我们的xss语句进行了一定程度的过滤，我们先用我们之前的payload来尝试一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>发现提交之后只剩个<code>&gt;</code>了</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910215436845.png\" alt=\"image-20250910215436845\"></p>\n</li>\n<li>\n<p>经过尝试我们可以发现，<code>&lt;script&gt;</code>标签被过滤了，但我们可以利用其他的标签来进行xss攻击</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;&quot;</span> onclick=<span class=\"string\">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"8-XSS之htmlspecialchars\">8.XSS之htmlspecialchars</h3>\n<ul>\n<li>\n<p>这里先简单介绍下<code>htmlspecialchars</code>函数是干什么的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">htmlspecialchars() 是 PHP 中的一个内置函数，用于将特定的 HTML 字符转换为 HTML 实体字符，从而防止跨站脚本攻击（XSS）。在 HTML 中，某些字符如 &lt;, &gt;, &quot;, &#x27; 和 &amp; 具有特殊含义，分别代表 HTML 的标签、结束标签、字符引用和实体引用。通过将这些字符转换为 HTML 实体，可以防止它们被浏览器解释为 HTML 标签或字符引用。</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>我们还是用我们原来的payload进行尝试，可以发现并不能成功执行，我们<code>f12</code>进行检查一下</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910224008050.png\" alt=\"image-20250910224008050\"></p>\n</li>\n<li>\n<p>可以发现原来的<code>&lt;</code>变成了<code>&amp;lt</code>原来的<code>&gt;</code>变成了<code>&amp;gt</code></p>\n</li>\n<li>\n<p>那我们直接输入尖括号和一些别的符号测试一下</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911172143855.png\" alt=\"image-20250911172143855\"></p>\n</li>\n<li>\n<p>观察发现他并没有过滤单引号，那么我们就可以利用这一点来构造payload，这里使用的是a标签</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&#x27;&#x27;</span> onclick=<span class=\"string\">&#x27;alert(&quot;xss&quot;)&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>完整语句</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&#x27;&#x27;</span> onclick=<span class=\"string\">&#x27;alert(&quot;xss&quot;)&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>最后成功弹窗</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911172444531.png\" alt=\"image-20250911172444531\"></p>\n</li>\n</ul>\n<h3 id=\"9-XSS之href输出\">9.XSS之href输出</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML &lt;a&gt; 标签的 href 属性用于指定链接的目标 URL。它可以是绝对 URL、相对 URL、锚点、电子邮件地址、电话号码或 JavaScript 代码段。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>我们先进行输入尝试</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911173724588.png\" alt=\"image-20250911173724588\"></p>\n</li>\n<li>\n<p>可以发现我们输入的内容在a标签的<code>href</code>中，而且在url中也能发现输入的内容</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911173940454.png\" alt=\"image-20250911173940454\"></p>\n</li>\n<li>\n<p>我们右键查看下源码后发现，他对我们输入的尖括号和单双引号进行了过滤</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911174041566.png\" alt=\"image-20250911174041566\"></p>\n</li>\n<li>\n<p>那么我们就可以尝试用<code>JavaScript</code>协议来执行<code>js</code>语句</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 协议（javascript:）是一种特殊的 URL 协议，用于在浏览器中直接执行 JavaScript 代码。它通常用于动态生成内容或执行特定操作，但需要谨慎使用以避免安全问题。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript 协议的基本用法</span><br><span class=\"line\"></span><br><span class=\"line\">javascript: 协议允许在 URL 中嵌入 JavaScript 代码，浏览器会解析并执行这些代码。例如：</span><br><span class=\"line\"></span><br><span class=\"line\">javascript:alert(&#x27;Hello, World!&#x27;);</span><br><span class=\"line\">当在浏览器地址栏中输入上述代码时，会弹出一个提示框显示 &quot;Hello, World!&quot;。如果代码返回一个值且不是 undefined，浏览器会将返回值作为页面内容显示。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>我们最后的payload为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">javascript</span>:<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911183220078.png\" alt=\"image-20250911183220078\"></p>\n</li>\n</ul>\n<h3 id=\"10-XSS之js输出\">10.XSS之js输出</h3>\n<ul>\n<li>\n<p>依旧输出之前的payload进行简单的尝试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;scirpt&gt;<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>并没有成功，我们查看下源码</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911183916965.png\" alt=\"image-20250911183916965\"></p>\n</li>\n<li>\n<p>观察发现，<code>&lt;script&gt;</code>多出来一个，那么我们需要将他闭合掉，将语句写进去</p>\n</li>\n<li>\n<p>payload为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"总结\">总结</h3>\n<ul>\n<li>当我们在实战进行挖掘的时候要留意一些可能会出现xss漏洞的地方比如：\n<ul>\n<li>数据交互的地方</li>\n<li>数据输出的地方</li>\n<li>任何可以自定义输入数据的地方都可以尝试 `XSS</li>\n</ul>\n</li>\n<li>进行黑盒测试的时候我们要记住这几个步骤：\n<ul>\n<li>页面中显示的数据找可控的（有些隐藏的）</li>\n<li>利用可控地方发送 <code>JS</code> 代码去看执行加载情况</li>\n<li>成功执行即 <code>XSS</code>，不能成功执行就 <code>F12</code> 看语句输出的地方显示情况（过滤）</li>\n<li>根据显示分析为什么不能执行，尝试绕过（实体化、闭合、关键词过滤等）</li>\n</ul>\n</li>\n<li>pikachu上的偏向基础，大家一定要学会灵活运用</li>\n</ul>\n<h2 id=\"三、CSRF（跨站请求伪造）\">三、CSRF（跨站请求伪造）</h2>\n<h3 id=\"概述-3\">概述</h3>\n<ul>\n<li>\n<p>CSRF（<code>Cross-Site Request Forgery</code>），也叫跨站请求伪造，是一种网络攻击手段，攻击者通过诱导用户在 <strong>已认证的状态下</strong> 访问恶意链接或页面，迫使用户的浏览器向目标服务器发送非预期的请求，从而执行攻击者预设的操作（如转账、修改密码、发表评论等）。</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920110122463.png\" alt=\"image-20250920110122463\"></p>\n</li>\n<li>\n<p>其实很好理解，就像上面那张图一样，假设我现在抓到了支付宝的转账数据包如下：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  http://www.alipay.com/pay.php?name=ling&amp;account=12732834&amp;money=10000</span><br><span class=\"line\"></span><br><span class=\"line\">- 然后我们搭建一个网站，让这个网站去直接加载这个数据包自动跳转，最后把这个网站的网址发给受害者</span><br><span class=\"line\">- 如果这时受害者正处于支付宝的登录的状态下，那么他就会自动进行这个转账</span><br><span class=\"line\">- 这就是典型的 `CSRF` 攻击</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**利用条件**</span><br><span class=\"line\"></span><br><span class=\"line\">- 从上面可以看到，CSRF 的利用条件有三点：</span><br><span class=\"line\">  - 需要请求伪造的数据包（可以通过 cms 之类的自己搭建并抓包想要利用别人的权限进行的操作）</span><br><span class=\"line\">  - 网站没有过滤防护或者有防护但可以绕过</span><br><span class=\"line\">  - 受害者要已经成功登录状态或者打开网站，而且要点击我们的恶意网站</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 1.CSRF（get）</span><br><span class=\"line\"></span><br><span class=\"line\">- 我们先点击右上角的提示，随便登录一个账号</span><br><span class=\"line\"></span><br><span class=\"line\">- 进入之后，是我们登录账号的个人信息</span><br><span class=\"line\"></span><br><span class=\"line\">  ![image-20250920112113291](../images/Pikachu靶场练习/image-20250920112113291.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- 然后我们点击修改个人信息，随便修改几个内容</span><br><span class=\"line\"></span><br><span class=\"line\">  ![image-20250920112701554](../images/Pikachu靶场练习/image-20250920112701554.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- 点击提交，并进行抓包</span><br><span class=\"line\"></span><br><span class=\"line\">  ![image-20250920112809228](../images/Pikachu靶场练习/image-20250920112809228.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- 通过观察我们可以发现，我们修改的内容是通过get请求发送的，并且内容会在url上面显示，那么我们是不是就可以修改上面的参数，来达到我们攻击的目的，这里可以改成我们自己想要修改的内容（比如自己的邮箱之类的），然后将修改后的整个url复制下来，那么我们构成的CSRF攻击payload为</span><br><span class=\"line\"></span><br><span class=\"line\">  ```http</span><br><span class=\"line\">  http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=hacker&amp;phonenum=hacker&amp;add=hacker&amp;email=hacker&amp;submit=submit</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>然后我们将这个payload，发送给已经登录成功的受害者，进行CSRF攻击，这里我们以受害者的视角演示一下</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920113905590.png\" alt=\"image-20250920113905590\"></p>\n</li>\n<li>\n<p>现在受害者的信息是这样的，假如我是lili，别人给我发了这样的网址，不知道是什么，很好奇，于是lili进行了访问</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=hacker&amp;phonenum=hacker&amp;add=hacker&amp;email=hacker&amp;submit=submit</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920114125640.png\" alt=\"image-20250920114125640\"></p>\n</li>\n<li>\n<p>可以看到这时我们的访问的网址内容是我们的个人信息，且已经被修改了，那我们回到我们原来的登录界面，并进行刷新</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920114257382.png\" alt=\"image-20250920114257382\"></p>\n</li>\n<li>\n<p>发现我们原来的内容也被修改了，这就是 CSRF 的攻击流程</p>\n</li>\n<li>\n<p>而利用条件要满足受害者已经成功登录状态或者打开网站，而且要点击我们的恶意网站，这也是CSRF少的原因，这还是没有考虑防护的情况，由此可见想要使用 CSRF 攻击还是很苛刻的</p>\n</li>\n</ul>\n<h3 id=\"2-CSRF（post）\">2.CSRF（post）</h3>\n<ul>\n<li>\n<p>这里只是请求发生了变化，但实际和上面没有太大区别，但这里我用 bp 来进行另外一种 CSRF payload的生成方式来进行讲解</p>\n</li>\n<li>\n<p>首先，我们还是提交修改的内容并进行抓包</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920115418633.png\" alt=\"image-20250920115418633\"></p>\n</li>\n<li>\n<p>然后按下面的这种图依次点击</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920115359377.png\" alt=\"image-20250920115359377\"></p>\n</li>\n<li>\n<p>然后找到我们想要修改的内容，并进行修改</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920115710189.png\" alt=\"image-20250920115710189\"></p>\n</li>\n<li>\n<p>点击 <code>Test in browser</code>，复制生成的链接</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920130947738.png\" alt=\"image-20250920130947738\"></p>\n</li>\n<li>\n<p>然后发给我们的受害者，让他进行访问</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920131344357.png\" alt=\"image-20250920131344357\"></p>\n</li>\n<li>\n<p>点击按钮，之后跳转到了登录界面，可以看到最后成功修改</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920131504883.png\" alt=\"image-20250920131504883\"></p>\n</li>\n<li>\n<p>这样的好处是，我们发的url具有隐蔽性，受害者会以为是这个网站的链接从而取消戒心，除了这种方法，也可以利用短链接来生成payload，这里就不再演示</p>\n</li>\n</ul>\n<h3 id=\"3-CSRF（token）\">3.CSRF（token）</h3>\n<ul>\n<li>\n<p>CSRF（token）顾名思义，这里就是使用了token来进行防护 CSRF 攻击</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250920132601384.png\" alt=\"image-20250920132601384\"></p>\n</li>\n<li>\n<p>查看这道题的源码发现，里面有一个<code>set_token()</code>的函数，当我们每次进行刷新的时候，就会将 <code>session</code>中的<code>token</code>销毁，并生成一个新的发送到前端中，而当我们进行 CSRF 攻击的时候，由于不知道对方当前页面的 <code>token</code>值，从而无法进行 CSRF 攻击</p>\n</li>\n</ul>\n<h2 id=\"四、SQL注入\">四、SQL注入</h2>\n<h3 id=\"概述-4\">概述</h3>\n<ul>\n<li>在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是数据库注入漏洞。<strong>一个严重的SQL注入漏洞，可能会直接导致一家公司破产！</strong></li>\n<li>SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。</li>\n<li>在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：\n<ul>\n<li>对传进SQL语句里面的变量进行过滤，不允许危险字符传入；</li>\n<li>使用参数化（Parameterized Query 或 Parameterized Statement）</li>\n<li>还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了&quot;拼接&quot;的方式,所以使用时需要慎重!</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是sql注入？\">什么是sql注入？</h3>\n<ul>\n<li>\n<p>SQL注入就是指<a href=\"https://so.csdn.net/so/search?q=Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&amp;spm=1001.2101.3001.7020\">Web应用程序</a>对用户输入数据的合理性没有进行判断，前端传入后端的参数是攻击者可控制的，并且根据参数带入数据库查询，攻击者可以通过构造不同的SQL语句来对数据库进行任意查询。下面以PHP语句为例作为展示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q u e r y = &quot; S E L E C T ∗ F R O M u s e r s W H E R E i d = query=&quot; SELECT*FROM users WHERE id=query=&quot;SELECT∗FROMusersWHEREid=_GET [‘id’] &quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>像这样，参数id可控，且可以带入数据库进行查询，那么非法用户就可以任意拼接sql语句进行攻击</p>\n</li>\n<li>\n<p>当然sql注入存在的主要原因就是程序员在开发的时候没有对用户输入的字符串进行过滤、转义，限制或者说是处理的不严谨，导致攻击者可以通过精心构造的字符串去非法获取到数据库中的数据。</p>\n</li>\n</ul>\n<p><strong>数字型注入</strong></p>\n<ul>\n<li>\n<p>当传入的参数为整形时，如果存在注入漏洞，那么我们就可以称他为数字型注入</p>\n</li>\n<li>\n<p>假如这是后端的sql语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from news where id = $id;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>我们通过get传入id的值，然后程序在进行对应的查询，那么如果我们这时候输入的是<code>3'</code>，这时拼接到语句中就会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from news where id = 3&#x27;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>输入<code>and 1=1</code>，拼接到语句中就会执行正常，与原始页面没什么差异</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from news where id = 3 and 1=1;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>输入<code>and 1=2</code>，拼接到语句可以正常执行，但无法查询到结果，返回的数据与原始页面存在差异</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from news where id = 3 and 1=2;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果满足以上几点，则可以判断这里存在数字型的注入</p>\n</li>\n</ul>\n<p><strong>字符型注入</strong></p>\n<ul>\n<li>\n<p>当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的，这里也先拿单引号来让你们理解什么是字符串注入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table where name=&#x27;admin&#x27;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>当我们输入<code>admin'</code>，这时就有三个单引号了，程序无法执行，发生报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table where name=&#x27;admin&#x27;&#x27;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>输入<code>admin'and 1=1</code>，此时的sql语句还是会多出来一个，我们可以用sql语句中的注释符号比如<code>#</code>或者<code>--+</code>，但如果是url传参的话就不要用<code>#</code>了，这个时候返回界面成功了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from table where name=&#x27;admin&#x27;and 1=1 --+&#x27;;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>输入<code>admin' and 1=2 --+</code>，返回错误</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  select * from table where name=&#x27;admin&#x27;and 1=2 --+&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">- 满足以上几点，就可以说是存在字符型注入</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 1.数字型的注入（post）</span><br><span class=\"line\"></span><br><span class=\"line\">- 现在我们用 Pikachu靶场 这道题来演示下数字型注入</span><br><span class=\"line\"></span><br><span class=\"line\">  ![image-20250927131208540](../images/Pikachu靶场练习/image-20250927131208540.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- 他让我们选择一个数字，然后返回相对应的数据，这个场景很符合数字型注入，我们来抓包进行测试一下</span><br><span class=\"line\"></span><br><span class=\"line\">  ![image-20250927131454170](../images/Pikachu靶场练习/image-20250927131454170.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- 右键发送到重放模块，将id =1 改成`1 and 1=1`</span><br><span class=\"line\"></span><br><span class=\"line\">  ![image-20250927131740328](../images/Pikachu靶场练习/image-20250927131740328.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- 可以看到没有任何报错，改成`1 and 1=2`试一下</span><br><span class=\"line\"></span><br><span class=\"line\">  ![image-20250927132243932](../images/Pikachu靶场练习/image-20250927132243932.png)</span><br><span class=\"line\"></span><br><span class=\"line\">- 可以看到并没有进行正确的回显，经过测试说明这里面可能就会有数字型的注入</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 联合注入</span><br><span class=\"line\"></span><br><span class=\"line\">- 如果经过测试，已经知道了注入点和绕过方式，且页面会有我们我们想要的回显，这时就可以用到我们的联合注入了</span><br><span class=\"line\"></span><br><span class=\"line\">- 所谓联合注入，就是在正常传入数据的时候，额外再执行我们插入的恶意语句，就像下面这样</span><br><span class=\"line\"></span><br><span class=\"line\">  ```mysql</span><br><span class=\"line\">  union select 1,2,3,4，group_concat(id,usename,password),6 from admin</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>由于大部分的查询是在数据库里的其中一张表上进行的，虽然可以利用<code>1' or 1=1</code>将这张表里其他的内容都爆出来，但是却不能查到别的表的数据，想要实现这一功能，我们就需要了解到 MySQL 里面自带的一些表</p>\n</li>\n<li>\n<p>在 MySQL 5.0即以上的版本：自带的数据库名为<code>information_schema</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">information_schema  #存储数据库下的数据库名及表名，列名信息的表</span><br><span class=\"line\">&quot;.&quot;代表下一级 select *from security.users</span><br><span class=\"line\">infomation_schema.schemata #记录数据库的表</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927142445567.png\" alt=\"image-20250927142445567\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">information_schema.tables   #记录表名信息的表</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>​\t\t<img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927142557808.png\" alt=\"image-20250927142557808\"></p>\n<ul>\n<li>\n<p>记录列名的表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">information_schema.columns   #记录列名信息表</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927142744108.png\" alt=\"image-20250927142744108\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schema_name：information_schema.schemata  #记录数据库名信息的列名值（数据库名字）</span><br><span class=\"line\"></span><br><span class=\"line\">table_schema：information_schema.tables   #记录数据库名的列名值</span><br><span class=\"line\"></span><br><span class=\"line\">table_name：information_schema.tables     #记录表名的列名值</span><br><span class=\"line\"></span><br><span class=\"line\">column_name：information_schema.columns   #记录列名的列名值</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927142936103.png\" alt=\"image-20250927142936103\"></p>\n</li>\n<li>\n<p>我们可以通过联合查询利用以上这些表来得到我们想要的库名和表名，但在这之前我们还需要进行以下的几个操作</p>\n</li>\n<li>\n<p>确定当前表一共有几列，这样我们才能进行后续操作时不会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  order by 6   #确认有几列，报错与不报错，取不报错那列（如果by 7报错，by 6不报错，那么这个表就有6列</span><br><span class=\"line\"></span><br><span class=\"line\">- 然后再确定一下页面的回显，如果你查询了1,2,3,4,5,6这几列，但页面只显示4和5，那就说明只有4和5列是在页面上回显的，后续操作也要在这两个列上进行</span><br><span class=\"line\"></span><br><span class=\"line\">  ```mysql</span><br><span class=\"line\">  union select 1,2,3,4,5,6   #找能看见回显的</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>接着就可以进行相对应的查询了，先看下数据库的名字和连接的用户（判断是不是root账户）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union select 1,2,3,database(),user(),6    #联合查询数据库名和数据库连接的用户  这里的回显就当做是demo1 root</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>然后就是我们上面提到的那几张表的利用了，通过他们来获取到我们想要的表名和列名（比如账号和密码）,具体的语句看我下面的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union select 1,2,3,4,group_concat(table_name),6 from information_schema.tables where table_schema = &#x27;demo1&#x27;   #查demo1数据库中的表名，group_concat是查全部的表名  回显是admin </span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查完表名查列名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union select 1,2,3,4,group_concat(column_name),6 from information_schema.columns where table_schema = &#x27;demo1&#x27;  and table_name = &#x27;admin&#x27;    #查admin表中的列名 回显为id、username、password</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>最后拿到<code>admin</code>表中的 id、账号和密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union select 1,2,3,4，group_concat(id,usename,password),6 from admin</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-字符型注入\">2.字符型注入</h3>\n<ul>\n<li>\n<p>打开题目，让我们输入我们的姓名，那我们输下<code>kobe</code>试试</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927175945233.png\" alt=\"image-20250927175945233\"></p>\n</li>\n<li>\n<p>也是输入内容，回显相对应的数据，但这里输入的是字符，而不是整形的数字，所以我们猜测这里可能存在字符型注入</p>\n</li>\n<li>\n<p>我们先输入<code>kobe'</code>抓个包放到重放模块测试一下</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927200804576.png\" alt=\"image-20250927200804576\"></p>\n</li>\n<li>\n<p>可以看到页面发生了报错，我们加上注释符号试一下（这里由于是get请求，所以注释符号要用–+）</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927201229373.png\" alt=\"image-20250927201229373\"></p>\n</li>\n<li>\n<p>成功执行，那么这里就很大概率存在字符型的注入，包含的符号就是单引号</p>\n</li>\n<li>\n<p>那么我们就用上面的注入流程，来进行演示下</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927201818737.png\" alt=\"image-20250927201818737\"></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927201834740.png\" alt=\"image-20250927201834740\"></p>\n</li>\n<li>\n<p>这里可以看到当列数为3的时候发生了报错，而列数为2时，页面就正常了（这里的%20是空格的url编码，浏览器进行解码之后就是空格，因为在bp里加空格之后就不是在name的值输入了）</p>\n</li>\n<li>\n<p>然后我们看下回显是在第几列</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927202910617.png\" alt=\"image-20250927202910617\"></p>\n</li>\n<li>\n<p>可以看到都有回显，那我们继续看看他的数据库名和用户名</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250927203025349.png\" alt=\"image-20250927203025349\"></p>\n</li>\n<li>\n<p>分别是pikachu和localhost，接下来就是查询<code>mysql</code>自带的表来获取我们想要的表名</p>\n</li>\n<li>\n<p>由于payload的长度比较长，一个一个加<code>%20</code>比较费劲，所以这里将我们写的payload进行 URL 编码一下，上网随便找个编码网站就行</p>\n</li>\n<li>\n<p>这里提醒一下不要将<code>--+</code>进行url编码，因为在数据库中注释的格式是<code>--</code>后面加个空格，而%20和+都是空格在 URL 中的编码，如果直接将+也进行编码解码后是<code>--+</code>就注释不了了，而<code>#</code>会被浏览器解码识别成锚点，导致后续内容不会被发送到服务器</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250928213700716.png\" alt=\"image-20250928213700716\"></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250928214452353.png\" alt=\"image-20250928214452353\"></p>\n</li>\n<li>\n<p>可以看到pikachu这个数据库里面的表已经被爆出来了，通过对名字的观察，我们想要得到的账号密码可能就在<code>users</code>这张表里面，那我们查询一下这个表的列都是什么</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kobe&#x27; union select group_concat(column_name),2 from information_schema.columns where table_schema = &#x27;pikachu&#x27;  and table_name = &#x27;users&#x27;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250928214935631.png\" alt=\"image-20250928214935631\"></p>\n</li>\n<li>\n<p>可以看到里面的列名分别是<code>username</code>，<code>password</code>正是我们想要的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union select group_concat(level,username,password),2 from users</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250928215227828.png\" alt=\"image-20250928215227828\"></p>\n</li>\n<li>\n<p>成功拿到，最后补充说下<code>group_concat</code>的作用，他是将数据全部变成一句话的显示出来，不用的话只会显示一部分</p>\n</li>\n</ul>\n<h3 id=\"3-搜索型注入\">3.搜索型注入</h3>\n<ul>\n<li>\n<p>搜索型注入，也称为文本框注入，是一种常见的SQL注入漏洞。它发生在网站提供搜索功能时，如果程序员在编写代码时忽略了对用户输入的过滤，就可能产生这种漏洞。这类注入漏洞在国内系统中普遍存在，通常分为POST和GET两种类型。GET型注入一般用于网站搜索，而POST型注入则用于用户登录。</p>\n</li>\n<li>\n<p>判断搜索型注入的方法包括</p>\n<ul>\n<li>搜索关键词后跟一个单引号<code>'</code>，如果出错，则有很大可能性存在漏洞。</li>\n<li>搜索关键词后跟一个百分号<code>%</code>，如果出错，则可能性更大</li>\n<li>搜索关键词后跟<code>% 'and 1=1 and '%'='</code>，观察返回情况。</li>\n<li>搜索关键词后跟<code>% 'and 1=2 and '%'='</code>，观察返回情况。</li>\n<li>根据返回情况判断是否存在搜索型文本框注入。</li>\n</ul>\n</li>\n<li>\n<p>正常搜索时，<code>%</code>用于包裹用户输入，实现模糊匹配；注入时，若直接输入恶意语句而不处理<code>%</code>，会破坏 SQL 语法。</p>\n</li>\n<li>\n<p>我们直接先拿<code>kobe'</code>测试一下，看看回显</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250928215837810.png\" alt=\"image-20250928215837810\"></p>\n</li>\n<li>\n<p>可以在报错中看到<code>%</code>，再结合关键字就能进行查询，判断大概率是模糊匹配，要用<code>%'</code>进行闭合，不过直接用<code>’</code>好像也可以，大家主要了解下模糊匹配和搜索性注入是什么即可，后面的测试流程和上面一样，这里就不过多演示了</p>\n</li>\n</ul>\n<h3 id=\"4-xx型注入\">4.xx型注入</h3>\n<ul>\n<li>\n<p>先输入<code>kobe'</code>和<code>kobe&quot;</code>分别看看返回的结果</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20251001193524669.png\" alt=\"image-20251001193524669\"></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20251001193550201.png\" alt=\"image-20251001193550201\"></p>\n</li>\n<li>\n<p>可以看到单引号的发生了报错，而双引号没有</p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20251001214739358.png\" alt=\"image-20251001214739358\"></p>\n</li>\n<li>\n<p>加上<code>#</code>注释发生了报错，说明除了单引号还有其他的符号包裹着，我们尝试下<code>kobe')#</code></p>\n<p><img src=\"../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20251001214912864.png\" alt=\"image-20251001214912864\"></p>\n</li>\n<li>\n<p>剩下的步骤就和上面一致了，只是多加了个括号</p>\n</li>\n</ul>\n<h3 id=\"5-insert-update-注入\">5.insert/update 注入</h3>\n<ul>\n<li>其实就是报错注入，所谓报错注入就是，开发人员为了方便调试，会将 SQL 语句执行错误后的报错信息输出到前端页面中</li>\n</ul>\n<p><strong>sql未完待续，感觉你们看不懂，我后续再写详细点</strong></p>\n<h2 id=\"五、RCE\">五、RCE</h2>\n<h3 id=\"概述-5\">概述</h3>\n<ul>\n<li>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</li>\n</ul>\n<p><strong>远程系统命令执行</strong></p>\n<ul>\n<li>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口</li>\n<li>比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器</li>\n<li>现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过&quot;自动化运维平台&quot;进行操作。 在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的&quot;收获&quot;-_-</li>\n</ul>\n<p><strong>远程代码执行</strong></p>\n<ul>\n<li>同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。</li>\n<li>因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。</li>\n<li>你可以通过“RCE”对应的测试栏目，来进一步的了解该漏洞。</li>\n</ul>\n<h3 id=\"1-exec-“ping”\">1.exec “ping”</h3>\n<ul>\n<li>在这之前我们先来了解下什么是命令连接符</li>\n<li>在操作系统中，命令连接符用于将多个命令组合在一起执行，实现流程控制或批量操作</li>\n</ul>\n<p><strong>Linux</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">分号（;）：按顺序执行多个命令，前一个命令的执行结果不影响后一个命令。</span><br><span class=\"line\">逻辑与（&amp;&amp;）：仅当前一个命令执行成功（返回状态码为 0）时，才执行后一个命令。</span><br><span class=\"line\">逻辑或（||）：当前一个命令执行失败（返回非 0 状态码）时，才执行后一个命令。</span><br><span class=\"line\">管道符（|）：</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、文件包含漏洞\">六、文件包含漏洞</h2>\n<h2 id=\"七、文件下载漏洞\">七、文件下载漏洞</h2>\n<h2 id=\"八、文件上传漏洞\">八、文件上传漏洞</h2>\n<h2 id=\"九、越权漏洞\">九、越权漏洞</h2>\n<h2 id=\"十、目录遍历漏洞\">十、目录遍历漏洞</h2>\n<h2 id=\"十一、敏感信息泄露\">十一、敏感信息泄露</h2>\n<h2 id=\"十二、PHP反序列化漏洞\">十二、PHP反序列化漏洞</h2>\n<h2 id=\"十三、XXE\">十三、XXE</h2>\n<h2 id=\"十四、不安全的url跳转\">十四、不安全的url跳转</h2>\n<h2 id=\"十五、SSRF\">十五、SSRF</h2>\n","feature":true,"text":"Pikachu漏洞平台练习 一、暴力破解 概述 “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量...","permalink":"/post/Pikachu靶场练习","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"网安基础","slug":"网安基础","count":4,"path":"api/categories/网安基础.json"}],"tags":[{"name":"Web基础","slug":"Web基础","count":1,"path":"api/tags/Web基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">Pikachu漏洞平台练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3\"><span class=\"toc-text\">一、暴力破解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">暴力破解漏洞测试流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%A1%AE%E8%AE%A4%E7%9B%AE%E6%A0%87%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%84%86%E5%BC%B1%E6%80%A7\"><span class=\"toc-text\">1.确认目标登录接口的脆弱性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AF%B9%E5%AD%97%E5%85%B8%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">2.对字典进行优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%B7%A5%E5%85%B7%E8%87%AA%E5%8A%A8%E5%8C%96%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.工具自动化操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%AD%97%E5%85%B8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">4.字典优化技巧</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3\"><span class=\"toc-text\">1.基于表单的暴力破解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87-on-server\"><span class=\"toc-text\">2.验证码绕过(on server)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87-on-client\"><span class=\"toc-text\">3.验证码绕过(on client)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-token%E9%98%B2%E7%88%86%E7%A0%B4\"><span class=\"toc-text\">4.token防爆破</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81XSS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%89\"><span class=\"toc-text\">二、XSS（跨站脚本攻击）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0-2\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS-%EF%BC%88get%EF%BC%89\"><span class=\"toc-text\">1.反射型 XSS （get）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS-%EF%BC%88post%EF%BC%89\"><span class=\"toc-text\">2.反射型 XSS （post）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AD%98%E5%82%A8%E5%9E%8B-XSS\"><span class=\"toc-text\">3.存储型 XSS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-DOM%E5%9E%8B-XSS\"><span class=\"toc-text\">4.DOM型 XSS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-DOM%E5%9E%8B-XSS-X\"><span class=\"toc-text\">5.DOM型 XSS-X</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-XSS-%E7%9B%B2%E6%89%93\"><span class=\"toc-text\">6.XSS 盲打</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-XSS%E4%B9%8B%E8%BF%87%E6%BB%A4\"><span class=\"toc-text\">7.XSS之过滤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-XSS%E4%B9%8Bhtmlspecialchars\"><span class=\"toc-text\">8.XSS之htmlspecialchars</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-XSS%E4%B9%8Bhref%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">9.XSS之href输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-XSS%E4%B9%8Bjs%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">10.XSS之js输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81CSRF%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89\"><span class=\"toc-text\">三、CSRF（跨站请求伪造）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0-3\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-CSRF%EF%BC%88post%EF%BC%89\"><span class=\"toc-text\">2.CSRF（post）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-CSRF%EF%BC%88token%EF%BC%89\"><span class=\"toc-text\">3.CSRF（token）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81SQL%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">四、SQL注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0-4\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFsql%E6%B3%A8%E5%85%A5%EF%BC%9F\"><span class=\"toc-text\">什么是sql注入？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">2.字符型注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%90%9C%E7%B4%A2%E5%9E%8B%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">3.搜索型注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-xx%E5%9E%8B%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">4.xx型注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-insert-update-%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">5.insert&#x2F;update 注入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81RCE\"><span class=\"toc-text\">五、RCE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0-5\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-exec-%E2%80%9Cping%E2%80%9D\"><span class=\"toc-text\">1.exec “ping”</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">六、文件包含漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">七、文件下载漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">八、文件上传漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">九、越权漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E3%80%81%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">十、目录遍历漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80%E3%80%81%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2\"><span class=\"toc-text\">十一、敏感信息泄露</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%8C%E3%80%81PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">十二、PHP反序列化漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%89%E3%80%81XXE\"><span class=\"toc-text\">十三、XXE</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%9B%9B%E3%80%81%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84url%E8%B7%B3%E8%BD%AC\"><span class=\"toc-text\">十四、不安全的url跳转</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%94%E3%80%81SSRF\"><span class=\"toc-text\">十五、SSRF</span></a></li></ol></li></ol>","author":{"name":"归尘aliez","slug":"blog-author","avatar":"/images/guichen.jpg","link":"/","description":"<p>斩断昔日旧枷锁，今日方知我是我</p>Journey of a thousand miles begins with single step.","socials":{"github":"https://github.com/gcaliez","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"网安知识点笔记（持续更新中）","uid":"b08904c0bab28ee83d3b8e8bd866184d","slug":"网安知识点","date":"2025-11-02T02:00:00.000Z","updated":"2025-11-02T02:22:33.782Z","comments":true,"path":"api/articles/网安知识点.json","keywords":null,"cover":"/images/a.jpg","text":"网安知识点 基础入门 一、Web 应用 Web 四大件 1.系统 Linux、windows、macos 2.中间件 我们经常管 web 中间件叫做 web 服...","permalink":"/post/网安知识点","photos":[],"count_time":{"symbolsCount":"233k","symbolsTime":"3:32"},"categories":[{"name":"网安基础","slug":"网安基础","count":4,"path":"api/categories/网安基础.json"}],"tags":[{"name":"Web安全","slug":"Web安全","count":4,"path":"api/tags/Web安全.json"}],"author":{"name":"归尘aliez","slug":"blog-author","avatar":"/images/guichen.jpg","link":"/","description":"<p>斩断昔日旧枷锁，今日方知我是我</p>Journey of a thousand miles begins with single step.","socials":{"github":"https://github.com/gcaliez","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"系统内容","uid":"c0dee51911d3712eb1635eee342507ff","slug":"系统内容","date":"2025-07-22T14:00:00.000Z","updated":"2025-09-20T05:40:43.202Z","comments":true,"path":"api/articles/系统内容.json","keywords":null,"cover":"/images/f.jpg","text":"网安系统内容 一.请求头、响应头 url: URL (Uniform Resource Locator) 是互联网上用于标识和定位资源的字符串，由多个部分组成，...","permalink":"/post/系统内容","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"网安基础","slug":"网安基础","count":4,"path":"api/categories/网安基础.json"}],"tags":[{"name":"Web安全","slug":"Web安全","count":4,"path":"api/tags/Web安全.json"}],"author":{"name":"归尘aliez","slug":"blog-author","avatar":"/images/guichen.jpg","link":"/","description":"<p>斩断昔日旧枷锁，今日方知我是我</p>Journey of a thousand miles begins with single step.","socials":{"github":"https://github.com/gcaliez","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}