{"title":"pikachu靶场攻略（持续更新中）","uid":"53f4cdc62f3d08c9a6f99b25abf6c677","slug":"Pikachu靶场练习","date":"2025-09-13T08:00:00.000Z","updated":"2025-09-13T09:40:08.077Z","comments":true,"path":"api/articles/Pikachu靶场练习.json","keywords":null,"cover":"/images/g.jpg","content":"<h1 id=\"Pikachu漏洞平台练习\"><a href=\"#Pikachu漏洞平台练习\" class=\"headerlink\" title=\"Pikachu漏洞平台练习\"></a>Pikachu漏洞平台练习</h1><h2 id=\"一、暴力破解\"><a href=\"#一、暴力破解\" class=\"headerlink\" title=\"一、暴力破解\"></a>一、暴力破解</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li><p>“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。</p>\n</li>\n<li><p>理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：</p>\n</li>\n<li><p>1.是否要求用户设置复杂的密码；<br>2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；<br>3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；<br>4.是否采用了双因素认证；<br>…等等</p>\n</li>\n</ul>\n<h3 id=\"暴力破解漏洞测试流程\"><a href=\"#暴力破解漏洞测试流程\" class=\"headerlink\" title=\"暴力破解漏洞测试流程\"></a>暴力破解漏洞测试流程</h3><h4 id=\"1-确认目标登录接口的脆弱性\"><a href=\"#1-确认目标登录接口的脆弱性\" class=\"headerlink\" title=\"1.确认目标登录接口的脆弱性\"></a>1.确认目标登录接口的脆弱性</h4><ul>\n<li>确认目标是否存在暴力破解的漏洞。（确认被暴力破解的“可能性”）</li>\n<li>比如：尝试登录-抓包-观察验证元素和response信息，判断是否存在暴力破解的可能</li>\n</ul>\n<h4 id=\"2-对字典进行优化\"><a href=\"#2-对字典进行优化\" class=\"headerlink\" title=\"2.对字典进行优化\"></a>2.对字典进行优化</h4><ul>\n<li>根据实际的情况对字典进行优化，提高爆破过程的效率</li>\n</ul>\n<h4 id=\"3-工具自动化操作\"><a href=\"#3-工具自动化操作\" class=\"headerlink\" title=\"3.工具自动化操作\"></a>3.工具自动化操作</h4><ul>\n<li>配置自动化工具（比如线程，超时时间，重试次数等），进行自动化的操作</li>\n</ul>\n<h4 id=\"4-字典优化技巧\"><a href=\"#4-字典优化技巧\" class=\"headerlink\" title=\"4.字典优化技巧\"></a>4.字典优化技巧</h4><ul>\n<li><strong>技巧一</strong>：<ul>\n<li>根据注册提示信息进行优化对目标站点进行注册，搞清楚账号密码的一些限制，比如目标站点要求密码必须是6位以上，字母数字组合，则可以按照此优化字典，比如去掉不符合要求的密码。</li>\n</ul>\n</li>\n<li><strong>技巧二</strong>：<ul>\n<li>如果爆破的是管理后台，往往这种系统的管理员是admin&#x2F;administrator&#x2F;root的机率比较高，可以使用这三个账号+随便一个密码，尝试登录，观看返回的结果，确定用户名。</li>\n<li>比如：<br>输入xxx&#x2F;yyyf返回“用户名或密码错误”；<br>输入admin&#x2F;yyy返回“密码错误”，则基本可以确定用户名是admin;<br>因此可以只对密码进行爆破即可，提高效率。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-基于表单的暴力破解\"><a href=\"#1-基于表单的暴力破解\" class=\"headerlink\" title=\"1.基于表单的暴力破解\"></a>1.基于表单的暴力破解</h3><ul>\n<li><p>基于表单的暴力破解，其实说白了就是没有任何验证码和防护措施的，最为简单的暴力破解</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828132053367.png\" alt=\"image-20250828132053367\"></p>\n</li>\n<li><p>这里我们要利用的是<code>burpsuit</code>这款工具，这个工具在学习安全的道路上会经常使用，小白可以通过b站搜索相关内容进行下载安装</p>\n</li>\n<li><p>要使用这款工具，我们需要导入证书和开启127.0.0.1:8080代理（当然用bp自带的浏览器也是可以的），详细步骤可以参考下这篇文章[Burp Suite CA证书下载及导入教程](<a href=\"https://blog.csdn.net/qq_46700234/article/details/122333508\">Burp Suite CA证书下载及导入教程_burp证书下载-CSDN博客</a>)</p>\n</li>\n<li><p>当一切准备就绪，我们就可以利用bp抓到浏览器的数据包了！（这里插一嘴，如果你的证书和代理都整好了的话还是抓不了本地的包，可以将127.0.0.1或者localhost换成你本地的ipv4地址，win + r 输入cmd，在命令行里面输入ipconfig，找到自己的ipv4地址）</p>\n</li>\n<li><p>首先我们点击<code>Intercept is off</code>这个按钮，将所有的通过这个端口的数据包拦截下来</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828134123789.png\" alt=\"image-20250828134123789\"></p>\n</li>\n<li><p>然后随便输账号和密码，点击登录</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828151711677.png\" alt=\"image-20250828151711677\"></p>\n</li>\n<li><p>可以看到这时已经成功抓到了，接下来我们要将这个登录的这个数据包放到我们的爆破模块，这也是我们抓包的目的</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828152012358.png\" alt=\"image-20250828152012358\"></p>\n</li>\n<li><p>进入到爆破模块后，我们选择一下其中的<code>Cluster bomb</code>的模式，这个相当于将你的字典的所有组合全部进行爆破，也是爆破最常用的模式，详细区别可以看下这篇文章[Burp Suite爆破模块中的四种模式的区别详解和演示(暴力破解)](<a href=\"https://blog.csdn.net/qq_45705626/article/details/127709037\">Burp Suite爆破模块中的四种模式的区别详解和演示(暴力破解)_bpcluster bomb-CSDN博客</a>)</p>\n</li>\n<li><p>选择之后，先按下右边的<code>clear</code>按钮，将自带参数清除，然后选中我们输入的账号和密码，进行<code>add</code></p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828153448979.png\" alt=\"image-20250828153448979\"></p>\n</li>\n<li><p>接着，我们点击<code>payloads</code>选项，添加我们要爆破的字典，因为pikachu右上角的提示给了我们正确的密码，这里我们将正确和错误的账号、密码混在一起当做我们的字典，在payload1和2里面分别添加</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828160534553.png\" alt=\"image-20250828160534553\"></p>\n</li>\n<li><p>添加完成后点击右上角的<code>Start attack</code>，开始爆破</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828160800937.png\" alt=\"image-20250828160800937\"></p>\n</li>\n<li><p>爆破成功后，我们不需要一个一个看返回的内容，可以点击<code>length</code>查看长度来进行判断，这里很明显第一行的长度与其他的都不一样，尝试后发现可以成功登录，那么恭喜你最简单的爆破流程你已经学会了。</p>\n</li>\n</ul>\n<h3 id=\"2-验证码绕过-on-server\"><a href=\"#2-验证码绕过-on-server\" class=\"headerlink\" title=\"2.验证码绕过(on server)\"></a>2.验证码绕过(on server)</h3><ul>\n<li><p>来到这一关，我们会发现多了一个验证码，当我们尝试输入错的账号密码还有验证码时告诉我们，验证码错误</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828161824925.png\" alt=\"image-20250828161824925\"></p>\n</li>\n<li><p>而当我们输入正确的验证码和错误的账号密码时，则会提示 username or password is not exists～</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828162003010.png\" alt=\"image-20250828162003010\"></p>\n</li>\n<li><p>当我们进行这两次尝试可以发现，只有当页面刷新的时候，验证码才会重新刷新，那我们不刷新页面同一个正确的验证码是否会有效呢，我们这里输入一个正确的验证码和错误的密码抓个包试验一下，并将抓到的包放到<code>Reteater（重放模块）</code>中</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828162644719.png\" alt=\"image-20250828162644719\"></p>\n</li>\n<li><p>修改一下原来的账号和密码，重新发送几次</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828163132504.png\" alt=\"image-20250828163132504\"></p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828163210592.png\" alt=\"image-20250828163210592\"></p>\n</li>\n<li><p>这里可以基本确认他的验证码只要不刷新就是有效的，那么抓包放到爆破模块的时候保证验证码是页面上正确的就行，其他操作和上面没有变化</p>\n</li>\n</ul>\n<h3 id=\"3-验证码绕过-on-client\"><a href=\"#3-验证码绕过-on-client\" class=\"headerlink\" title=\"3.验证码绕过(on client)\"></a>3.验证码绕过(on client)</h3><ul>\n<li><p>来到第三关，我们依旧先输入错误的账号和验证码进行尝试，而当我们验证码错误的时候，他会出现一个弹窗，提示我们验证码输入错误</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828163642398.png\" alt=\"image-20250828163642398\"></p>\n</li>\n<li><p>但我们点击确认的时候，发现页面并没有任何加载的迹象，但验证码刷新了，由此可以判断，这个验证码的验证实在前端页面上进行的，那么这一关就很简单了，对于懂安全的来说，任何在前端进行的验证，都是没有任何意义的，我们只需要先按<code>f12</code>再按<code>f1</code>，将<code>javascript</code>禁用就可以了</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828164129191.png\" alt=\"image-20250828164129191\"></p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828164155506.png\" alt=\"image-20250828164155506\"></p>\n</li>\n<li><p>这里可以看到，验证码已经没有显示了，剩下的还是按照第一关的步骤进行爆破就可以了</p>\n</li>\n</ul>\n<h3 id=\"4-token防爆破\"><a href=\"#4-token防爆破\" class=\"headerlink\" title=\"4.token防爆破\"></a>4.token防爆破</h3><ul>\n<li><p>在做这关之前，推荐大家可以先去了解一下什么是<code>token</code>，详细可以看这篇文章<a href=\"%5B%E4%BB%80%E4%B9%88%E6%98%AFtoken%EF%BC%9Ftoken%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F_token%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/sunyctf/article/details/126509232#:~:text=%E7%9B%B8%E4%BF%A1%E5%BE%88%E5%A4%9A%E4%BB%8E%E4%BA%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%9C%8B%E5%8F%8B%E9%83%BD%E5%90%AC%E8%AF%B4%E8%BF%87token%E8%BF%99%E4%B9%88%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E4%BB%96%E8%A1%8C%E4%B8%9A%E7%9A%84%E4%BA%BA%E5%B0%B1%E5%BE%88%E5%B0%91%E4%BA%86%E8%A7%A3%E5%88%B0token%EF%BC%8C%E4%B8%8B%E9%9D%A2%E5%B0%B1%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%9D%A5%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Btoken%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9Ftoken%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%E8%BF%99%E4%B8%80%E5%9D%97%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%B8%8C%E6%9C%9B%E8%83%BD%E5%B8%AE%E5%8A%A9%E5%88%B0%E5%A4%A7%E5%AE%B6%E3%80%82)\">什么是token？token是用来干嘛的？</a>，总的来说<code>token</code>就相当于给每个请求发一个独一无二的编号，用它来进行验证</p>\n</li>\n<li><p>我们这里先<code>f12</code>进行查看</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828202748729.png\" alt=\"image-20250828202748729\"></p>\n</li>\n<li><p>在登录按钮的上面可以看到题目的<code>token</code>，在有<code>token</code>的干扰下，我们的爆破流程要稍加改变，因为即使有<code>token</code>连发两个也会报错，但由于<code>token</code>的值回显在前端页面上，我们就可以配置一个正则重定向，让BP每次爆破的时候自动爬取这个<code>token</code>值</p>\n</li>\n<li><p>还是先随便输入密码，进行登录抓包，并发送到爆破模块，这里我们选择的攻击模式是<code>Pitchfork</code>，他的功能就是多个字典同时进行</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828203715252-1756385190263-1.png\" alt=\"image-20250828203715252\"></p>\n</li>\n<li><p>接着我们点击<code>Setings</code>，在下面找到<code>Gerp-Extract</code>，然后依次点击这两个按钮</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828204521538.png\" alt=\"image-20250828204521538\"></p>\n</li>\n<li><p>在下面搜索<code>token</code>，找到那个<code>token</code>值，选中复制，然后点击ok</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828204914788.png\" alt=\"image-20250828204914788\"></p>\n</li>\n<li><p>然后回到<code>payloads</code>选项，前两个账号密码添加的方式不变，第三个<code>token</code>的时候，选择<code>Recursive grep（递归搜索）</code>，将我们刚才复制的<code>token</code>值粘贴到下面</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828205440466.png\" alt=\"image-20250828205440466\"></p>\n</li>\n<li><p>接着来到<code>resource pool</code>模块，选择创建新的资源池，并把最大请求数改为1</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828205658793.png\" alt=\"image-20250828205658793\"></p>\n</li>\n<li><p>然后开始攻击即可</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250828205900283.png\" alt=\"image-20250828205900283\"></p>\n</li>\n<li><p>最后爆破成功！</p>\n</li>\n</ul>\n<h2 id=\"二、XSS（跨站脚本攻击）\"><a href=\"#二、XSS（跨站脚本攻击）\" class=\"headerlink\" title=\"二、XSS（跨站脚本攻击）\"></a>二、XSS（跨站脚本攻击）</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：<ul>\n<li>反射型 XSS</li>\n<li>存储型 XSS</li>\n<li>DOM型 XSS</li>\n</ul>\n</li>\n<li>XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。</li>\n<li>XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。</li>\n<li>形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。</li>\n<li>因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:<ul>\n<li>输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;</li>\n<li>输出转义：根据输出点的位置对输出到前端的内容进行适当转义;</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-反射型-XSS-（get）\"><a href=\"#1-反射型-XSS-（get）\" class=\"headerlink\" title=\"1.反射型 XSS （get）\"></a>1.反射型 XSS （get）</h3><p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906164701762.png\" alt=\"image-20250906164701762\"></p>\n<ul>\n<li><p>打开题目，问我们我们最喜欢的 NBA 球星，这里我们随便输入一个</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906164847521.png\" alt=\"image-20250906164847521\"></p>\n</li>\n<li><p>通过观察我们发现，我们输入的球星名字会在前端页面显示出来，那么这里就可能存在<code>XSS</code>漏洞</p>\n</li>\n<li><p>由于他是通过<code>GET</code>请求来进行传参的，那我们尝试构造前端语言的<code>payload</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"><span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>但当我们输入到 (‘xss’) 的时候发现超过了长度限制</p>\n</li>\n<li><p>那么我们<code>f12</code>，选中这个输入框，将最大长度改成100</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906170108326.png\" alt=\"image-20250906170108326\"></p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906170201873.png\" alt=\"image-20250906170201873\"></p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906170219625.png\" alt=\"image-20250906170219625\"></p>\n</li>\n</ul>\n<h3 id=\"2-反射型-XSS-（post）\"><a href=\"#2-反射型-XSS-（post）\" class=\"headerlink\" title=\"2.反射型 XSS （post）\"></a>2.反射型 XSS （post）</h3><ul>\n<li>打开题目，发现是一个登录页面，我们点一下提示，先进行账号登录（也可以利用上面学到的知识，进行暴力破解）</li>\n<li>登录完事后，发现和上一题没什么太大的区别，输入喜欢的球星后，依旧会在前端界面显示，只不过这里使用<code>post</code>进行传参，那我们的操作不变，最后成功造成<code>反射型xss</code></li>\n<li>payload：<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里简单讲述下get请求和post的区别</span><br><span class=\"line\"></span><br><span class=\"line\">GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们在数据传输方式、安全性、数据量限制等方面存在显著差异。</span><br><span class=\"line\"></span><br><span class=\"line\">数据传输方式 GET 请求通过 URL 传递参数，参数以 key=value 的形式附加在 URL 后，用 ? 分隔，多个参数用 &amp; 连接。例如：/test?name=John&amp;age=30。 POST 请求则将参数放在 HTTP 请求的消息体中，用户无法直接看到这些数据。</span><br><span class=\"line\"></span><br><span class=\"line\">安全性 GET 请求的参数会显示在 URL 中，因此容易被记录在浏览器历史、服务器日志中，安全性较低，尤其不适合传输敏感信息如密码。 POST 请求的参数不会显示在 URL 中，安全性相对较高，适合传输敏感数据。</span><br><span class=\"line\"></span><br><span class=\"line\">数据量限制 GET 请求受 URL 长度限制（通常为 2048 个字符），因此传输数据量较小。 POST 请求没有明确的数据长度限制，可以传输大量数据，适合文件上传等场景。</span><br><span class=\"line\"></span><br><span class=\"line\">缓存和历史记录 GET 请求可以被缓存，参数会保留在浏览器历史记录中，适合用于获取数据。 POST 请求不会被缓存，参数也不会保留在历史记录中。</span><br><span class=\"line\"></span><br><span class=\"line\">编码类型 GET 请求只支持 ASCII 字符，传输非 ASCII 数据时需要编码。 POST 请求支持多种编码方式，包括 application/x-www-form-urlencoded 和 multipart/form-data，后者适用于二进制数据。</span><br><span class=\"line\"></span><br><span class=\"line\">性能和效率 GET 请求通常只需要一个 TCP 数据包即可完成，效率较高。 POST 请求可能需要两个 TCP 数据包：第一个发送请求头，第二个发送请求体，因此性能稍逊。</span><br><span class=\"line\"></span><br><span class=\"line\">使用场景 GET 适用于获取数据，例如查询操作。 POST 适用于提交数据，例如表单提交或文件上传。</span><br><span class=\"line\"></span><br><span class=\"line\">总结来说，GET 和 POST 的选择应根据具体需求决定。GET 更适合无状态、无敏感数据的请求，而 POST 则适合需要更高安全性和传输大量数据的场景。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-存储型-XSS\"><a href=\"#3-存储型-XSS\" class=\"headerlink\" title=\"3.存储型 XSS\"></a>3.存储型 XSS</h3><p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906173623108.png\" alt=\"image-20250906173623108\"></p>\n<ul>\n<li><p>存储型<code>XSS</code>是持久化的<code>XSS</code>攻击方式，它<strong>将恶意代码存储于服务器端</strong>，比如数据库、留言页面、日志文件等，当其他用户访问该页面时就会触发代码，造成<code>xss</code>攻击</p>\n</li>\n<li><p>这个漏洞的危害就比较大了，因为它是插入到一个正常页面的，你只需要浏览就能够触发</p>\n</li>\n<li><p>那么我们来看这道题，他给了我们一个留言板，说明我们写进去的内容会被存储起来并进行显示，这里很就有可能出现存储型的<code>xss</code>，实战中也可以多留意一下留言板相关的功能</p>\n</li>\n<li><p>payload：<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250906175040688.png\" alt=\"image-20250906175040688\"></p>\n</li>\n<li><p>当我们每次刷新界面进行访问的时候都会触发 xss，这就是存储型 xss 的影响</p>\n</li>\n</ul>\n<h3 id=\"4-DOM型-XSS\"><a href=\"#4-DOM型-XSS\" class=\"headerlink\" title=\"4.DOM型 XSS\"></a>4.DOM型 XSS</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里简单介绍下什么是DOM</span><br><span class=\"line\">DOM 是一种用于表示和操作HTML、XML等文档结构的编程接口，通过它可以使用代码来访问、修改和操作Web页面的内容和结构。</span><br><span class=\"line\">与反射型和存储型XSS不同，DOM型XSS不需要将恶意脚本传输到服务器，而是直接在客户端执行，因此更难检测和防御。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>详细可见：[DOM-XSS攻击原理](<a href=\"https://www.cnblogs.com/mysticbinary/p/12542695.html\">DOM-XSS攻击原理与防御 - Mysticbinary - 博客园</a>)</li>\n</ul>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910195631471.png\" alt=\"image-20250910195631471\"></p>\n<ul>\n<li><p>打开题目，我们随便输入一些内容，然后<code>f12</code>检查一下，我们刚才输入的内容</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910200919603.png\" alt=\"image-20250910200919603\"></p>\n</li>\n<li><p>这里我们需要将语句闭合并进行payload的构造，可以看到他这里用的是<code>a</code>标签，各种标签和绕过方法可以看这篇文章： [xss过滤绕过总结](<a href=\"https://www.cnblogs.com/sfsec/p/15178028.html\">XSS过滤绕过总结 - 随风kali - 博客园</a>)</p>\n</li>\n<li><p>但这里双引号闭合却没有成功，我们打开源代码发现，外面其实还有一个单引号</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910201814755.png\" alt=\"image-20250910201814755\"></p>\n</li>\n<li><p>那么我们最后的payload为：<code>&#39; onclick=alert(&#39;xss&#39;)&gt;</code></p>\n</li>\n<li><p>闭合后的完整语句为：<code>&lt;a href=&#39;&#39; onclick=alert(‘xss’)&gt;&#39;&gt;what do you see?&lt;/a&gt;</code></p>\n</li>\n</ul>\n<h3 id=\"5-DOM型-XSS-X\"><a href=\"#5-DOM型-XSS-X\" class=\"headerlink\" title=\"5.DOM型 XSS-X\"></a>5.DOM型 XSS-X</h3><ul>\n<li>这一关和上一关的<code>payload</code>没什么区别，唯一的区别就是他是get请求从url获取我们提交的内容</li>\n<li>这里就不过多解释了</li>\n</ul>\n<h3 id=\"6-XSS-盲打\"><a href=\"#6-XSS-盲打\" class=\"headerlink\" title=\"6.XSS 盲打\"></a>6.XSS 盲打</h3><ul>\n<li><p>XSS 盲打（Blind Cross-Site Scripting）是跨站脚本攻击的一种高级形式，其核心特点是<strong>攻击者无法直接观察攻击效果</strong>，需依赖特定用户（如管理员）在未来某个时间点触发存储在服务器上的恶意代码。</p>\n</li>\n<li><p>XSS 盲打属于<strong>存储型 XSS 的变种</strong>，但攻击流程存在显著差异。攻击者将恶意脚本注入到网站的输入点（如留言板、用户资料编辑框），脚本被存储在服务器数据库中，<strong>不会立即在当前用户浏览器执行</strong>。当管理员或其他用户访问包含该脚本的页面时，浏览器会自动解析并执行脚本，导致攻击生效。</p>\n</li>\n<li><p>其实简单来说也可以叫黑盒测试</p>\n</li>\n<li><p>我们回到题目，首先我们构造一个 xss 的 payload，检查后发现看不到代码，无法判断成功与否</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们点开提示，他告诉了我们后台的地址，我们访问一下</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910213833347.png\" alt=\"image-20250910213833347\"></p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910213911579.png\" alt=\"image-20250910213911579\"></p>\n</li>\n<li><p>成功弹窗，我们检查一下，发现语句确实写进去了</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910214008006.png\" alt=\"image-20250910214008006\"></p>\n</li>\n</ul>\n<h3 id=\"7-XSS之过滤\"><a href=\"#7-XSS之过滤\" class=\"headerlink\" title=\"7.XSS之过滤\"></a>7.XSS之过滤</h3><ul>\n<li><p>根据我们的题目，我们可以得知他应该是对我们的xss语句进行了一定程度的过滤，我们先用我们之前的payload来尝试一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发现提交之后只剩个<code>&gt;</code>了</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910215436845.png\" alt=\"image-20250910215436845\"></p>\n</li>\n<li><p>经过尝试我们可以发现，<code>&lt;script&gt;</code>标签被过滤了，但我们可以利用其他的标签来进行xss攻击</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;&quot;</span> onclick=<span class=\"string\">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"8-XSS之htmlspecialchars\"><a href=\"#8-XSS之htmlspecialchars\" class=\"headerlink\" title=\"8.XSS之htmlspecialchars\"></a>8.XSS之htmlspecialchars</h3><ul>\n<li><p>这里先简单介绍下<code>htmlspecialchars</code>函数是干什么的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">htmlspecialchars() 是 PHP 中的一个内置函数，用于将特定的 HTML 字符转换为 HTML 实体字符，从而防止跨站脚本攻击（XSS）。在 HTML 中，某些字符如 &lt;, &gt;, &quot;, &#x27; 和 &amp; 具有特殊含义，分别代表 HTML 的标签、结束标签、字符引用和实体引用。通过将这些字符转换为 HTML 实体，可以防止它们被浏览器解释为 HTML 标签或字符引用。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们还是用我们原来的payload进行尝试，可以发现并不能成功执行，我们<code>f12</code>进行检查一下</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250910224008050.png\" alt=\"image-20250910224008050\"></p>\n</li>\n<li><p>可以发现原来的<code>&lt;</code>变成了<code>&amp;lt</code>原来的<code>&gt;</code>变成了<code>&amp;gt</code></p>\n</li>\n<li><p>那我们直接输入尖括号和一些别的符号测试一下</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911172143855.png\" alt=\"image-20250911172143855\"></p>\n</li>\n<li><p>观察发现他并没有过滤单引号，那么我们就可以利用这一点来构造payload，这里使用的是a标签</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&#x27;&#x27;</span> onclick=<span class=\"string\">&#x27;alert(&quot;xss&quot;)&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完整语句</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&#x27;&#x27;</span> onclick=<span class=\"string\">&#x27;alert(&quot;xss&quot;)&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后成功弹窗</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911172444531.png\" alt=\"image-20250911172444531\"></p>\n</li>\n</ul>\n<h3 id=\"9-XSS之href输出\"><a href=\"#9-XSS之href输出\" class=\"headerlink\" title=\"9.XSS之href输出\"></a>9.XSS之href输出</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML &lt;a&gt; 标签的 href 属性用于指定链接的目标 URL。它可以是绝对 URL、相对 URL、锚点、电子邮件地址、电话号码或 JavaScript 代码段。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>我们先进行输入尝试</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911173724588.png\" alt=\"image-20250911173724588\"></p>\n</li>\n<li><p>可以发现我们输入的内容在a标签的<code>href</code>中，而且在url中也能发现输入的内容</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911173940454.png\" alt=\"image-20250911173940454\"></p>\n</li>\n<li><p>我们右键查看下源码后发现，他对我们输入的尖括号和单双引号进行了过滤</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911174041566.png\" alt=\"image-20250911174041566\"></p>\n</li>\n<li><p>那么我们就可以尝试用<code>JavaScript</code>协议来执行<code>js</code>语句</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 协议（javascript:）是一种特殊的 URL 协议，用于在浏览器中直接执行 JavaScript 代码。它通常用于动态生成内容或执行特定操作，但需要谨慎使用以避免安全问题。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript 协议的基本用法</span><br><span class=\"line\"></span><br><span class=\"line\">javascript: 协议允许在 URL 中嵌入 JavaScript 代码，浏览器会解析并执行这些代码。例如：</span><br><span class=\"line\"></span><br><span class=\"line\">javascript:alert(&#x27;Hello, World!&#x27;);</span><br><span class=\"line\">当在浏览器地址栏中输入上述代码时，会弹出一个提示框显示 &quot;Hello, World!&quot;。如果代码返回一个值且不是 undefined，浏览器会将返回值作为页面内容显示。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>我们最后的payload为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">javascript</span>:<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911183220078.png\" alt=\"image-20250911183220078\"></p>\n</li>\n</ul>\n<h3 id=\"10-XSS之js输出\"><a href=\"#10-XSS之js输出\" class=\"headerlink\" title=\"10.XSS之js输出\"></a>10.XSS之js输出</h3><ul>\n<li><p>依旧输出之前的payload进行简单的尝试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;scirpt&gt;<span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>并没有成功，我们查看下源码</p>\n<p><img src=\"/../images/Pikachu%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/image-20250911183916965.png\" alt=\"image-20250911183916965\"></p>\n</li>\n<li><p>观察发现，<code>&lt;script&gt;</code>多出来一个，那么我们需要将他闭合掉，将语句写进去</p>\n</li>\n<li><p>payload为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>当我们在实战进行挖掘的时候要留意一些可能会出现xss漏洞的地方比如：<ul>\n<li>数据交互的地方</li>\n<li>数据输出的地方</li>\n<li>任何可以自定义输入数据的地方都可以尝试 &#96;XSS</li>\n</ul>\n</li>\n<li>进行黑盒测试的时候我们要记住这几个步骤：<ul>\n<li>页面中显示的数据找可控的（有些隐藏的）</li>\n<li>利用可控地方发送 <code>JS</code> 代码去看执行加载情况</li>\n<li>成功执行即 <code>XSS</code>，不能成功执行就 <code>F12</code> 看语句输出的地方显示情况（过滤）</li>\n<li>根据显示分析为什么不能执行，尝试绕过（实体化、闭合、关键词过滤等）</li>\n</ul>\n</li>\n<li>pikachu上的偏向基础，大家一定要学会灵活运用</li>\n</ul>\n<h2 id=\"三、CSRF（跨站请求伪造）\"><a href=\"#三、CSRF（跨站请求伪造）\" class=\"headerlink\" title=\"三、CSRF（跨站请求伪造）\"></a>三、CSRF（跨站请求伪造）</h2><h2 id=\"四、SQL注入\"><a href=\"#四、SQL注入\" class=\"headerlink\" title=\"四、SQL注入\"></a>四、SQL注入</h2><h2 id=\"五、RCE\"><a href=\"#五、RCE\" class=\"headerlink\" title=\"五、RCE\"></a>五、RCE</h2><h2 id=\"六、文件包含漏洞\"><a href=\"#六、文件包含漏洞\" class=\"headerlink\" title=\"六、文件包含漏洞\"></a>六、文件包含漏洞</h2><h2 id=\"七、文件下载漏洞\"><a href=\"#七、文件下载漏洞\" class=\"headerlink\" title=\"七、文件下载漏洞\"></a>七、文件下载漏洞</h2><h2 id=\"八、文件上传漏洞\"><a href=\"#八、文件上传漏洞\" class=\"headerlink\" title=\"八、文件上传漏洞\"></a>八、文件上传漏洞</h2><h2 id=\"九、越权漏洞\"><a href=\"#九、越权漏洞\" class=\"headerlink\" title=\"九、越权漏洞\"></a>九、越权漏洞</h2><h2 id=\"十、目录遍历漏洞\"><a href=\"#十、目录遍历漏洞\" class=\"headerlink\" title=\"十、目录遍历漏洞\"></a>十、目录遍历漏洞</h2><h2 id=\"十一、敏感信息泄露\"><a href=\"#十一、敏感信息泄露\" class=\"headerlink\" title=\"十一、敏感信息泄露\"></a>十一、敏感信息泄露</h2><h2 id=\"十二、PHP反序列化漏洞\"><a href=\"#十二、PHP反序列化漏洞\" class=\"headerlink\" title=\"十二、PHP反序列化漏洞\"></a>十二、PHP反序列化漏洞</h2><h2 id=\"十三、XXE\"><a href=\"#十三、XXE\" class=\"headerlink\" title=\"十三、XXE\"></a>十三、XXE</h2><h2 id=\"十四、不安全的url跳转\"><a href=\"#十四、不安全的url跳转\" class=\"headerlink\" title=\"十四、不安全的url跳转\"></a>十四、不安全的url跳转</h2><h2 id=\"十五、SSRF\"><a href=\"#十五、SSRF\" class=\"headerlink\" title=\"十五、SSRF\"></a>十五、SSRF</h2>","feature":true,"text":"Pikachu漏洞平台练习一、暴力破解概述 “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认...","permalink":"/post/Pikachu靶场练习","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"网安基础","slug":"网安基础","count":4,"path":"api/categories/网安基础.json"}],"tags":[{"name":"Web基础","slug":"Web基础","count":1,"path":"api/tags/Web基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pikachu%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">Pikachu漏洞平台练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3\"><span class=\"toc-text\">一、暴力破解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">暴力破解漏洞测试流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%A1%AE%E8%AE%A4%E7%9B%AE%E6%A0%87%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%84%86%E5%BC%B1%E6%80%A7\"><span class=\"toc-text\">1.确认目标登录接口的脆弱性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AF%B9%E5%AD%97%E5%85%B8%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">2.对字典进行优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%B7%A5%E5%85%B7%E8%87%AA%E5%8A%A8%E5%8C%96%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.工具自动化操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%AD%97%E5%85%B8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">4.字典优化技巧</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3\"><span class=\"toc-text\">1.基于表单的暴力破解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87-on-server\"><span class=\"toc-text\">2.验证码绕过(on server)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87-on-client\"><span class=\"toc-text\">3.验证码绕过(on client)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-token%E9%98%B2%E7%88%86%E7%A0%B4\"><span class=\"toc-text\">4.token防爆破</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81XSS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%89\"><span class=\"toc-text\">二、XSS（跨站脚本攻击）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0-1\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS-%EF%BC%88get%EF%BC%89\"><span class=\"toc-text\">1.反射型 XSS （get）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS-%EF%BC%88post%EF%BC%89\"><span class=\"toc-text\">2.反射型 XSS （post）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AD%98%E5%82%A8%E5%9E%8B-XSS\"><span class=\"toc-text\">3.存储型 XSS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-DOM%E5%9E%8B-XSS\"><span class=\"toc-text\">4.DOM型 XSS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-DOM%E5%9E%8B-XSS-X\"><span class=\"toc-text\">5.DOM型 XSS-X</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-XSS-%E7%9B%B2%E6%89%93\"><span class=\"toc-text\">6.XSS 盲打</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-XSS%E4%B9%8B%E8%BF%87%E6%BB%A4\"><span class=\"toc-text\">7.XSS之过滤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-XSS%E4%B9%8Bhtmlspecialchars\"><span class=\"toc-text\">8.XSS之htmlspecialchars</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-XSS%E4%B9%8Bhref%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">9.XSS之href输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-XSS%E4%B9%8Bjs%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">10.XSS之js输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81CSRF%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89\"><span class=\"toc-text\">三、CSRF（跨站请求伪造）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81SQL%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">四、SQL注入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81RCE\"><span class=\"toc-text\">五、RCE</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">六、文件包含漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">七、文件下载漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">八、文件上传漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">九、越权漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E3%80%81%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">十、目录遍历漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80%E3%80%81%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2\"><span class=\"toc-text\">十一、敏感信息泄露</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%8C%E3%80%81PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">十二、PHP反序列化漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%89%E3%80%81XXE\"><span class=\"toc-text\">十三、XXE</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%9B%9B%E3%80%81%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84url%E8%B7%B3%E8%BD%AC\"><span class=\"toc-text\">十四、不安全的url跳转</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%94%E3%80%81SSRF\"><span class=\"toc-text\">十五、SSRF</span></a></li></ol></li></ol>","author":{"name":"归尘aliez","slug":"blog-author","avatar":"/images/guichen.jpg","link":"/","description":"<p>斩断昔日旧枷锁，今日方知我是我</p>Journey of a thousand miles begins with single step.","socials":{"github":"https://github.com/gcaliez","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"网安知识点笔记（持续更新中）","uid":"b08904c0bab28ee83d3b8e8bd866184d","slug":"网安知识点","date":"2025-09-13T09:00:00.000Z","updated":"2025-09-13T09:40:08.087Z","comments":true,"path":"api/articles/网安知识点.json","keywords":null,"cover":"/images/a.jpg","text":"网安知识点基础入门一、Web 应用Web 四大件1.系统 Linux、windows、macos 2.中间件 我们经常管 web 中间件叫做 web 服务器或者...","permalink":"/post/网安知识点","photos":[],"count_time":{"symbolsCount":"145k","symbolsTime":"2:12"},"categories":[{"name":"网安基础","slug":"网安基础","count":4,"path":"api/categories/网安基础.json"}],"tags":[{"name":"Web安全","slug":"Web安全","count":4,"path":"api/tags/Web安全.json"}],"author":{"name":"归尘aliez","slug":"blog-author","avatar":"/images/guichen.jpg","link":"/","description":"<p>斩断昔日旧枷锁，今日方知我是我</p>Journey of a thousand miles begins with single step.","socials":{"github":"https://github.com/gcaliez","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"系统内容","uid":"c0dee51911d3712eb1635eee342507ff","slug":"系统内容","date":"2025-07-22T14:00:00.000Z","updated":"2025-09-13T09:40:08.082Z","comments":true,"path":"api/articles/系统内容.json","keywords":null,"cover":"/images/f.jpg","text":"网安系统内容一.请求头、响应头url: URL (Uniform Resource Locator) 是互联网上用于标识和定位资源的字符串，由多个部分组成，每个...","permalink":"/post/系统内容","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"网安基础","slug":"网安基础","count":4,"path":"api/categories/网安基础.json"}],"tags":[{"name":"Web安全","slug":"Web安全","count":4,"path":"api/tags/Web安全.json"}],"author":{"name":"归尘aliez","slug":"blog-author","avatar":"/images/guichen.jpg","link":"/","description":"<p>斩断昔日旧枷锁，今日方知我是我</p>Journey of a thousand miles begins with single step.","socials":{"github":"https://github.com/gcaliez","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}